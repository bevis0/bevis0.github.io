<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构-HashMap | Bevis技术小站</title><meta name="description" content="数据结构-HashMap"><meta name="keywords" content="Java,集合"><meta name="author" content="Bevis"><meta name="copyright" content="Bevis"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="数据结构-HashMap"><meta name="twitter:description" content="数据结构-HashMap"><meta name="twitter:image" content="http://yoursite.com/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="数据结构-HashMap"><meta property="og:url" content="http://yoursite.com/2018/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-HashMap/"><meta property="og:site_name" content="Bevis技术小站"><meta property="og:description" content="数据结构-HashMap"><meta property="og:image" content="http://yoursite.com/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2018/04/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-HashMap/"><link rel="prev" title="数据结构-LinkedHashMap" href="http://yoursite.com/2018/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LinkedHashMap/"><link rel="next" title="数据结构-LinkedList" href="http://yoursite.com/2018/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LinkedList/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Bevis技术小站" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#构造参数含义"><span class="toc-number">1.</span> <span class="toc-text">构造参数含义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#默认初始化值"><span class="toc-number">1.1.</span> <span class="toc-text">默认初始化值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据存储变化"><span class="toc-number">2.</span> <span class="toc-text">数据存储变化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#存储数组"><span class="toc-number">2.1.</span> <span class="toc-text">存储数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数组存储位置定位"><span class="toc-number">2.1.1.</span> <span class="toc-text">数组存储位置定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#碰撞产生的链表"><span class="toc-number">2.1.2.</span> <span class="toc-text">碰撞产生的链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表过长的平衡-红黑树"><span class="toc-number">2.1.3.</span> <span class="toc-text">链表过长的平衡-红黑树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#扩容"><span class="toc-number">3.</span> <span class="toc-text">扩容</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bevis技术小站</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">数据结构-HashMap</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2018-04-23 01:37:08"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2018-04-23</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="构造参数含义"><a href="#构造参数含义" class="headerlink" title="构造参数含义"></a>构造参数含义</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 加载因子</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</span><br><span class="line"></span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity &#x3D; MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    this.loadFactor &#x3D; loadFactor;</span><br><span class="line">    this.threshold &#x3D; tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要涉及几个重要参数：</p>
<ul>
<li>initialCapacity <code>初始化容量，HashMap 数组列表table的长度为2的冥次，如果该容量值并不是2的冥次，则会进行校正，转为比该值大的最近的2的冥次值</code></li>
<li>loadFactor <code>HashMap字段，加载因子，在每次扩容将影响 threshold 的值，threshold = 当前扩容后数组长度 * loadFactor，默认为0.75</code></li>
<li>threshold <code>HashMap字段，指定下次扩容时的门槛，如果HashMap中的size &gt;= threshold 则发生扩容 resize 处理</code></li>
</ul>
<h2 id="默认初始化值"><a href="#默认初始化值" class="headerlink" title="默认初始化值"></a>默认初始化值</h2><p>默认情况下，加载因子如果未指定，则为 <code>DEFAULT_LOAD_FACTOR</code> <code>0.75</code>。</p>
<p>如果未指定容量，并且不要求初始化容量，则默认一开始不对<code>table</code>数组进行初始化，待下次触发扩容，比如进行<code>push</code>、<code>pushAll</code>以及初始化<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code>触发元素添加。在进行初次默认初始化，会将数组容量初始化为 <code>16</code> ，扩容门槛为 <code>16 * 0.75 = 12</code></p>
<h1 id="数据存储变化"><a href="#数据存储变化" class="headerlink" title="数据存储变化"></a>数据存储变化</h1><p>HashMap 数据结构主要分为三层：数组、单向链表、以及红黑树，每达到一定的限制或条件会自动对存储结构发生改变。</p>
<h2 id="存储数组"><a href="#存储数组" class="headerlink" title="存储数组"></a>存储数组</h2><p>在 <code>HashMap</code> 中提供了<code>Node&lt;K, V&gt;[]</code> 数组参数 table，用于对数据添加时的存储。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用于存储的数组，当首次存储，将进入该数组</span><br><span class="line">transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 链表节点类，内部提供 next 指向下一个链表节点</span><br><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       final int hash;</span><br><span class="line">       final K key;</span><br><span class="line">       V value;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           this.hash &#x3D; hash;</span><br><span class="line">           this.key &#x3D; key;</span><br><span class="line">           this.value &#x3D; value;</span><br><span class="line">           this.next &#x3D; next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public final K getKey()        &#123; return key; &#125;</span><br><span class="line">       public final V getValue()      &#123; return value; &#125;</span><br><span class="line">       public final String toString() &#123; return key + &quot;&#x3D;&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">       public final int hashCode() &#123;</span><br><span class="line">           return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public final V setValue(V newValue) &#123;</span><br><span class="line">           V oldValue &#x3D; value;</span><br><span class="line">           value &#x3D; newValue;</span><br><span class="line">           return oldValue;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; 很重要的匹配方法，当形成链表结构后，进行查找时，需要对于链表的每个节点进行匹配</span><br><span class="line">       public final boolean equals(Object o) &#123;</span><br><span class="line">           if (o &#x3D;&#x3D; this)</span><br><span class="line">               return true;</span><br><span class="line">           if (o instanceof Map.Entry) &#123;</span><br><span class="line">               Map.Entry&lt;?,?&gt; e &#x3D; (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">               if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                   Objects.equals(value, e.getValue()))</span><br><span class="line">                   return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在以上代码中，可以知道数组容器中的元素是通过<code>Node</code>对<code>put</code>的value值 进行包装，在该类中，除了必要的参数值<code>value</code>，还有存在<code>next</code>字段，可以指向下一个 Node 。 这形成典型的单项链表结构。</p>
<p>从另一方面讲，通过<code>Node</code>的包装，数组容器<code>table</code>所存储的变为是对链表头节点的存储，为链表产生可能。</p>
<h3 id="数组存储位置定位"><a href="#数组存储位置定位" class="headerlink" title="数组存储位置定位"></a>数组存储位置定位</h3><p>为了方便研究，我从<code>put</code>方法入手。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                boolean evict) &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; &#x2F;&#x2F; 当前数组 table</span><br><span class="line">     Node&lt;K,V&gt; p; &#x2F;&#x2F; 需要插入数组的位置的顶层节点</span><br><span class="line">     int n, i;  &#x2F;&#x2F; n 为当前数组容器容量</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 判断数组容器table 是否被初始化，如果没有进行扩容初始化</span><br><span class="line">     &#x2F;&#x2F; resize</span><br><span class="line">     if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">         n &#x3D; (tab &#x3D; resize()).length;</span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">     &#x2F;&#x2F; 计算当前元素需要插入数组的位置（n - 1) &amp; hash，如果</span><br><span class="line">     &#x2F;&#x2F; 当前数组位置未有元素，则直接插入即可</span><br><span class="line">     if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">         &#x2F;&#x2F; </span><br><span class="line">         tab[i] &#x3D; newNode(hash, key, value, null);</span><br><span class="line">     else &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         if (p.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">             ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">             e &#x3D; p;</span><br><span class="line">         else if (p instanceof TreeNode)</span><br><span class="line">             &#x2F;&#x2F; 如果当前需要插入的位置有元素，并且当前结构升级为</span><br><span class="line">             &#x2F;&#x2F; 红黑树，则执行红黑树插入</span><br><span class="line">             e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">         else &#123;</span><br><span class="line">             &#x2F;&#x2F; 如果当前存在的元素节点不是红黑树结构节点，则开始遍历&#x2F;&#x2F;&#x2F; 链表节点</span><br><span class="line">             for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">                 </span><br><span class="line">                 if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                     &#x2F;&#x2F; 将新增节点添加到链表末端</span><br><span class="line">                     p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                     </span><br><span class="line">                     &#x2F;&#x2F; 如果添加后的链表长度大于等于 7 (TREEIFY_THRESHOLD &#x3D; 8)，则进行红黑树转化</span><br><span class="line">                     if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                         </span><br><span class="line">                     &#x2F;&#x2F; 插入成功后退出循环    </span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line">                 </span><br><span class="line">                 &#x2F;&#x2F; 如果发现插入的节点和当前链表中的某个元素是一致的</span><br><span class="line">                 &#x2F;&#x2F; （匹配 key 和 key.equeals ）则中断添加元素</span><br><span class="line">                 if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                     ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">                     break;</span><br><span class="line">                     </span><br><span class="line">                 &#x2F;&#x2F; 遍历下一个节点    </span><br><span class="line">                 p &#x3D; e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         &#x2F;&#x2F; e 用来记录循环的下一个节点，如果遍历完不为null，则表示还</span><br><span class="line">         &#x2F;&#x2F; 未遍历完节点即退出节点遍历，则存在插入的元素和链表中重复</span><br><span class="line">         &#x2F;&#x2F; 的情况，才会发生遍历中断。</span><br><span class="line">         if (e !&#x3D; null) &#123;</span><br><span class="line">             V oldValue &#x3D; e.value;</span><br><span class="line">             </span><br><span class="line">             &#x2F;&#x2F; 为 null d的情况 或者 设置 onlyIfAbsent &#x3D; false </span><br><span class="line">             &#x2F;&#x2F; 允许替换之前存在节点中的值</span><br><span class="line">             if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)</span><br><span class="line">                 e.value &#x3D; value;</span><br><span class="line">                 </span><br><span class="line">             &#x2F;&#x2F; 用于 hook 的方法，处理插值失败的值的后续处理</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             &#x2F;&#x2F; 返回老值</span><br><span class="line">             return oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     ++modCount;</span><br><span class="line">     &#x2F;&#x2F; 添加成功后记录递增值，并判断是否超过容量门槛 threshold，</span><br><span class="line">     &#x2F;&#x2F; 超过则进行扩容</span><br><span class="line">     if (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">         </span><br><span class="line">     &#x2F;&#x2F; 插入新值成功后的 hook    </span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> static final int hash(Object key) &#123;</span><br><span class="line">     int h;</span><br><span class="line">     return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过跟踪最终<code>push</code> 所执行的方法为<code>putVal</code>。</p>
<p>以上代码我们关注于这行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)</span><br><span class="line">    tab[i] &#x3D; newNode(hash, key, value, null);</span><br></pre></td></tr></table></figure>

<p>这里 <code>tab</code> 即为外部的存储容器<code>table</code>，<code>n</code>为<code>tab.length</code>，而<code>hash</code> 为 <code>put</code> 的key 参数，通过<code>HashMap.hash(Object key)</code> 对Key进行 Hash 处理得的哈希值。</p>
<p>之后对<code>tab</code>的下标记进行计算<code>(n-1）&amp;hash</code>，这相当<code>hash % n</code> 运算，可以获取在<code>n</code>范围内的绝对位置。</p>
<p>在元素初始插入时（元素在数组中插入位置为空，还没有填充任何元素的时候），通过<code>newNode</code> 对元素进行包装并插入到数组列表中即可。</p>
<h3 id="碰撞产生的链表"><a href="#碰撞产生的链表" class="headerlink" title="碰撞产生的链表"></a>碰撞产生的链表</h3><p>面对的大量数据，数组下标的计算然道不会重复？<br>答案是绝对的，肯定会，因此这产生了数据碰撞，我们的<code>Node</code> 类就开始发挥它的作用。</p>
<p>当所需要添加的元素的目标数组位置，发现已经存在元素时，则会执行<code>putVal</code>中这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历当前被占据位置的Node节点</span><br><span class="line"> for (int binCount &#x3D; 0; ; ++binCount) &#123;</span><br><span class="line">     if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">         &#x2F;&#x2F; 将新增节点添加到链表末端</span><br><span class="line">         p.next &#x3D; newNode(hash, key, value, null);</span><br><span class="line">                     </span><br><span class="line">         &#x2F;&#x2F; 如果添加后的链表长度大于等于 8 (TREEIFY_THRESHOLD &#x3D; 8)，则进行红黑树转化, -1 是因为binCount 从0开始计数</span><br><span class="line">         if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">             treeifyBin(tab, hash);</span><br><span class="line">                         </span><br><span class="line">         &#x2F;&#x2F; 插入成功后退出循环    </span><br><span class="line">         break;</span><br><span class="line">     &#125;</span><br><span class="line">                 </span><br><span class="line">     &#x2F;&#x2F; 如果发现插入的节点和当前链表中的某个元素是一致的</span><br><span class="line">     &#x2F;&#x2F; （匹配 key 和 key.equeals ）则中断添加元素</span><br><span class="line">     if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">         ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))</span><br><span class="line">         break;</span><br><span class="line">                     </span><br><span class="line">     &#x2F;&#x2F; 遍历下一个节点    </span><br><span class="line">     p &#x3D; e;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读取被占位置的Node元素，并进行链表遍历（Node.next）</li>
<li>如果在遍历过程中发现当前链表中Key 存在与当前需要插入的元素Key 一致（equals），则中断遍历</li>
<li>如果该元素Key未在该链表中找到相同元素Key，则遍历到最后一个元素Node，使用 <code>newNode</code> 为当前需要添加的元素包装为Node类型，并添加为尾部的下一个节点。</li>
</ul>
<p>具体可以参照例子<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/29472/2A1ED7E05EB7498F899D53A894B9EB14"  alt="image"></p>
<h3 id="链表过长的平衡-红黑树"><a href="#链表过长的平衡-红黑树" class="headerlink" title="链表过长的平衡-红黑树"></a>链表过长的平衡-红黑树</h3><p>链表解决了碰撞问题，但是如果碰撞发生过于频繁，那么会造成链表失重，并且在查询性能上会趋于<code>O(n)</code>，性能较差。</p>
<p>因此为了在这问题中找到平衡方案，HashMap再次改造。</p>
<p>在之前对元素添加链表的<code>putVal</code>代码片段中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st</span><br><span class="line">              treeifyBin(tab, hash);</span><br></pre></td></tr></table></figure>
<p>如果当前该链表的深度大于等于默认值 8 时，则对该链表进行红黑树转化<code>treeifyBin</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">       &#x2F;&#x2F; 这里提供的 hash 为数组容器头部的节点Key hash，通过 (n-1) &amp; </span><br><span class="line">       &#x2F;&#x2F; hash 可以定位该节点在数组中的位置，即指明了需要进行红黑树转化</span><br><span class="line">       &#x2F;&#x2F; 的链表位置</span><br><span class="line">       int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       </span><br><span class="line">       &#x2F;&#x2F; 当前数组容器 table 必须是被初始化了而且长度大于64才</span><br><span class="line">       &#x2F;&#x2F; 允许转化，否则进行数组扩容，重新对存储的元素进行分布，</span><br><span class="line">       &#x2F;&#x2F; 降低最深链表的长度</span><br><span class="line">       if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();</span><br><span class="line">       else if ((e &#x3D; tab[index &#x3D; (n - 1) &amp; hash]) !&#x3D; null) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd &#x3D; null, tl &#x3D; null;</span><br><span class="line">           &#x2F;&#x2F; 包装红黑树节点 TreeNode</span><br><span class="line">           do &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p &#x3D; replacementTreeNode(e, null);</span><br><span class="line">               if (tl &#x3D;&#x3D; null)</span><br><span class="line">                   hd &#x3D; p;</span><br><span class="line">               else &#123;</span><br><span class="line">                   p.prev &#x3D; tl;</span><br><span class="line">                   tl.next &#x3D; p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl &#x3D; p;</span><br><span class="line">           &#125; while ((e &#x3D; e.next) !&#x3D; null);</span><br><span class="line">           </span><br><span class="line">           if ((tab[index] &#x3D; hd) !&#x3D; null)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>从代码中可知道需要进行红黑树转化需要满足：</p>
<p><code>最长链表深度达到8个元素并且数组容器长度达到64</code></p>
<p>否则触发的将是对数组列表的重新扩容，以降低单个链表的长度。</p>
<h1 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h1><p>在之前结构演变中，我们提到数组列表扩容。</p>
<p>为解决列表数据拥挤的问题，除了改变存储的数据结构，还有最直接的对顶层数据列表的容量的扩充，这能直接对整个数组进行元素重新分配，从而降低数据碰撞的概率。</p>
<p>下面看看扩容方法 <code>resize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab &#x3D; table;</span><br><span class="line">        &#x2F;&#x2F; 如果当前数组容器未初始化则获取容量默认为0</span><br><span class="line">        int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;</span><br><span class="line">        int oldThr &#x3D; threshold;</span><br><span class="line">        int newCap, newThr &#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果之前数组容器已经被初始化</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果数组容器tab已经扩容到最大的容量</span><br><span class="line">            &#x2F;&#x2F; 将 threshold 指定为最大Integer值</span><br><span class="line">            &#x2F;&#x2F; 不再支持数组扩容，返回当前tab</span><br><span class="line">            if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold &#x3D; Integer.MAX_VALUE;</span><br><span class="line">                return oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                &#x2F;&#x2F; 校验在之前tab数组容量上增长一倍是否小于</span><br><span class="line">                &#x2F;&#x2F; 最大容量，并且当前tab数组大于等于默认初</span><br><span class="line">                &#x2F;&#x2F; 始化容量 16 (DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                &#x2F;&#x2F; 设置下次扩容门槛 threshold 为原来门槛的</span><br><span class="line">                &#x2F;&#x2F; 两倍</span><br><span class="line">                newThr &#x3D; oldThr &lt;&lt; 1; </span><br><span class="line">        &#125;</span><br><span class="line">        else if (oldThr &gt; 0) </span><br><span class="line">            &#x2F;&#x2F; 之前如果指定了扩容门槛 threshold，则将扩容门</span><br><span class="line">            &#x2F;&#x2F; 槛做为新扩充的目标容量值</span><br><span class="line">            newCap &#x3D; oldThr;</span><br><span class="line">        else &#123;               </span><br><span class="line">            &#x2F;&#x2F; 如果之前未初始化tab数组，则进行指定初始化容量</span><br><span class="line">            &#x2F;&#x2F; 为16 (DEFAULT_INITIAL_CAPACITY)，新扩容门槛</span><br><span class="line">            &#x2F;&#x2F; threshold 初始化为 0.75 * 16 &#x3D; 12</span><br><span class="line">            newCap &#x3D; DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 校正措施，如果构造初始化为0会出现，根据新容量和</span><br><span class="line">        &#x2F;&#x2F; 加载因子进行校正，并且限定在 MAXIMUM_CAPACITY 之</span><br><span class="line">        &#x2F;&#x2F; 下。否则使用将新的门槛值设置为  Integer.MAX_VALUE </span><br><span class="line">        &#x2F;&#x2F;（不需要进行扩容</span><br><span class="line">        if (newThr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            float ft &#x3D; (float)newCap * loadFactor;</span><br><span class="line">            newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (int)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 将新扩容门槛设置为 HashMap的字段 threshold 中</span><br><span class="line">        threshold &#x3D; newThr;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 为 table 产生新的扩容数组</span><br><span class="line">        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">        table &#x3D; newTab;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果之前老数组已经有数据，则需要将数据迁移到新的扩容</span><br><span class="line">        &#x2F;&#x2F; 数组中</span><br><span class="line">        if (oldTab !&#x3D; null) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;</span><br><span class="line">                    oldTab[j] &#x3D; null;</span><br><span class="line">                    if (e.next &#x3D;&#x3D; null)</span><br><span class="line">                        &#x2F;&#x2F; 如果数组元素节点只有一个元素，则直接</span><br><span class="line">                        &#x2F;&#x2F; 计算新的数组下标位置并插入到新数组中</span><br><span class="line">                        newTab[e.hash &amp; (newCap - 1)] &#x3D; e;</span><br><span class="line">                    else if (e instanceof TreeNode)</span><br><span class="line">                        &#x2F;&#x2F; 如果数组元素节点已经是红黑树节点，则</span><br><span class="line">                        &#x2F;&#x2F; 进行红黑树分配，不做深入</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                    else &#123; </span><br><span class="line">                        &#x2F;&#x2F; 处理链表结构下的迁移</span><br><span class="line">                        </span><br><span class="line">                        &#x2F;&#x2F; loHead 为拆解后原位置（不变更原位置）的链表</span><br><span class="line">                        &#x2F;&#x2F; 头节点和尾节点</span><br><span class="line">                        Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;</span><br><span class="line">                        </span><br><span class="line">                        &#x2F;&#x2F; 需要变更位置的头节点和尾节点</span><br><span class="line">                        Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        do &#123;</span><br><span class="line">                            next &#x3D; e.next;</span><br><span class="line">                            &#x2F;&#x2F; e.hash &amp; oldCap 和之前 e.has &amp; (oldCap -1)</span><br><span class="line">                            &#x2F;&#x2F; 不同，检查该元素是否在扩容后，需要调整</span><br><span class="line">                            &#x2F;&#x2F; 在数组列表中的存储位置</span><br><span class="line">                            &#x2F;&#x2F; 在之前的 &amp; 运算中，是为了获得 % 结果，</span><br><span class="line">                            &#x2F;&#x2F; 下面提供例子信息，设定当前数组容量为16，</span><br><span class="line">                            &#x2F;&#x2F; 分别对 9 和 20 进行相应的计算</span><br><span class="line">                            &#x2F;&#x2F; </span><br><span class="line">                            &#x2F;&#x2F; 9 存储位置计算</span><br><span class="line">                            &#x2F;&#x2F; hash   : 0000 0000 0000 1001</span><br><span class="line">                            &#x2F;&#x2F; cap - 1: 0000 0000 0000 1111</span><br><span class="line">                            &#x2F;&#x2F; &amp;      : 0000 0000 0000 1001</span><br><span class="line">                            &#x2F;&#x2F;</span><br><span class="line">                            &#x2F;&#x2F; 20 存储位置计算</span><br><span class="line">                            &#x2F;&#x2F; hash   : 0000 0000 0001 0100</span><br><span class="line">                            &#x2F;&#x2F; cap - 1: 0000 0000 0000 1111</span><br><span class="line">                            &#x2F;&#x2F; &amp;      : 0000 0000 0000 0100</span><br><span class="line">                            &#x2F;&#x2F;</span><br><span class="line">                            &#x2F;&#x2F; 由于容量cap一直都为2的冥次方关系，</span><br><span class="line">                            &#x2F;&#x2F; 通过与运算，可以简单进行取余计算</span><br><span class="line">                            &#x2F;&#x2F;</span><br><span class="line">                            &#x2F;&#x2F; 9 溢出计算</span><br><span class="line">                            &#x2F;&#x2F; hash   : 0000 0000 0000 1001</span><br><span class="line">                            &#x2F;&#x2F; cap    : 0000 0000 0001 0000</span><br><span class="line">                            &#x2F;&#x2F; &amp;      : 0000 0000 0000 0000</span><br><span class="line">                            &#x2F;&#x2F;</span><br><span class="line">                            &#x2F;&#x2F; 结果为 0 则该元素在扩容后不需要变更</span><br><span class="line">                            &#x2F;&#x2F; 元素的存储位置（数组下标位置）</span><br><span class="line">                            &#x2F;&#x2F;</span><br><span class="line">                            &#x2F;&#x2F; 20 溢出计算</span><br><span class="line">                            &#x2F;&#x2F; hash   : 0000 0000 0001 0100</span><br><span class="line">                            &#x2F;&#x2F; cap    : 0000 0000 0001 0000</span><br><span class="line">                            &#x2F;&#x2F; &amp;      : 0000 0000 0001 0000</span><br><span class="line">                            &#x2F;&#x2F;</span><br><span class="line">                            &#x2F;&#x2F; 如果不需要移位，则该计算结果不为0</span><br><span class="line">                            &#x2F;&#x2F; </span><br><span class="line">                            &#x2F;&#x2F; 判断不需要进行进行位置变更时</span><br><span class="line">                            if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                &#x2F;&#x2F; 不需要更换存储位置链表的组装</span><br><span class="line">                                if (loTail &#x3D;&#x3D; null)</span><br><span class="line">                                    loHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    loTail.next &#x3D; e;</span><br><span class="line">                                loTail &#x3D; e;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                &#x2F;&#x2F; 需要变更位置节点链表的组装</span><br><span class="line">                                if (hiTail &#x3D;&#x3D; null)</span><br><span class="line">                                    hiHead &#x3D; e;</span><br><span class="line">                                else</span><br><span class="line">                                    hiTail.next &#x3D; e;</span><br><span class="line">                                hiTail &#x3D; e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; while ((e &#x3D; next) !&#x3D; null);</span><br><span class="line">                        if (loTail !&#x3D; null) &#123;</span><br><span class="line">                            loTail.next &#x3D; null;</span><br><span class="line">                            newTab[j] &#x3D; loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (hiTail !&#x3D; null) &#123;</span><br><span class="line">                            hiTail.next &#x3D; null;</span><br><span class="line">                            &#x2F;&#x2F; 这里比较特殊，根据以上计算，如果需要</span><br><span class="line">                            &#x2F;&#x2F; 变更节点，由于每次容量都是一倍增长</span><br><span class="line">                            &#x2F;&#x2F; 因此只需要在原来的容量位置 + 新偏移</span><br><span class="line">                            &#x2F;&#x2F; 位置即可得到新的存储位置</span><br><span class="line">                            newTab[j + oldCap] &#x3D; hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>计算新容量值 newCap 以及新扩容门槛 newThre<ul>
<li>如果之前已经初始化过数组列表table（容量 &gt; 0）<ul>
<li>如果当前数组列表 table 的容量已经达到最大值 1 &lt;&lt; 30，则设置新扩容门槛值为 Integer.MAX_VALUE，阻止由于达到扩容门槛触发下次扩容，并退出当次扩容</li>
<li>如果数组列表 table 的容量不超过最大容量，并且大于默认容量 DEFAULT_INITIAL_CAPACITY （16），则将之前的扩容门槛扩容一倍。</li>
</ul>
</li>
<li>如果之前设置过扩容门槛（oldThr &gt; 0），则将该扩容门槛作为当次需要扩容的目标容量（newCap）</li>
<li>如果未初始化过数组列表 table 并且没有设置扩容门槛 threshold ，则设置新的扩容目标值为 DEFAULT_INITIAL_CAPACITY （16），扩容门槛为 DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY (12)</li>
</ul>
</li>
<li>根据之前的计算得到的新目标容量值（newCap）和新扩容门槛值（newThr）产生新 table 数组列表和设置新的扩容门槛（threshold）</li>
<li>对在老数据列表中的数据迁移到新产生 table 中<ul>
<li>如果当前迁移的数组位置的节点为单个节点，不存在链表结构，则直接计算新存储的位置并设置到新列表中。</li>
<li>如果当前迁移的数组位置的节点为红黑树节点，则进行红黑树变更</li>
<li>如果当前迁移的数组位置的节点存在链表，有多个节点<ul>
<li>根据节点是否需要进行位置变更，重组需要变更的链表和不需要变更位置的链表</li>
<li>将两个节点添加到新数组列表table对应位置上</li>
</ul>
</li>
</ul>
</li>
</ul>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LinkedHashMap/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构-LinkedHashMap</div></div></a></div><div class="next-post pull_right"><a href="/2018/04/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LinkedList/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构-LinkedList</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2018/04/11/数据结构-ArrayList/" title="数据结构-ArrayList"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-11</div><div class="relatedPosts_title">数据结构-ArrayList</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/12/数据结构-LinkedList/" title="数据结构-LinkedList"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-12</div><div class="relatedPosts_title">数据结构-LinkedList</div></div></a></div><div class="relatedPosts_item"><a href="/2018/04/28/数据结构-LinkedHashMap/" title="数据结构-LinkedHashMap"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-04-28</div><div class="relatedPosts_title">数据结构-LinkedHashMap</div></div></a></div><div class="relatedPosts_item"><a href="/2018/05/15/JVM了解/" title="JVM了解"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-05-15</div><div class="relatedPosts_title">JVM了解</div></div></a></div><div class="relatedPosts_item"><a href="/2018/05/16/Java-汇编调试/" title="Java-汇编调试"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-05-16</div><div class="relatedPosts_title">Java-汇编调试</div></div></a></div><div class="relatedPosts_item"><a href="/2018/05/05/数据结构-LruCache/" title="数据结构-LruCache"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-05-05</div><div class="relatedPosts_title">数据结构-LruCache</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2014 - 2020 By Bevis</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>