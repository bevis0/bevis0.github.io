<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bevis技术小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-10T12:44:24.843Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Bevis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OkHttp</title>
    <link href="http://yoursite.com/2019/05/01/OkHttp/"/>
    <id>http://yoursite.com/2019/05/01/OkHttp/</id>
    <published>2019-05-01T10:20:10.000Z</published>
    <updated>2020-04-10T12:44:24.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、主要构件"><a href="#一、主要构件" class="headerlink" title="一、主要构件"></a>一、主要构件</h1><ul><li>OkhttpClient 请求总引擎代理</li><li>Request 请求体信息，通过Request.Builder构造，请求头、请求体信息</li><li>Call 请求连接代理，通过Call可以决定是同步还异步请求处理</li><li>Dispatcher 接收同步/异步请求要求，根据要求对请求进行同步/异步分发</li><li>Interceptor</li></ul><h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.squareup.okhttp3:okhttp:4.4.0&#39;</span><br><span class="line">&#x2F;&#x2F; 单元测试依赖</span><br><span class="line">testImplementation &#39;com.squareup.okhttp3:mockwebserver:4.4.0&#39;</span><br></pre></td></tr></table></figure><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22726/32DF5E930CAC4F18990DCC8E5E18F7D6"  alt="image"></p><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><ul><li>创建OkHttpClient和Request（Request.Builder）对象</li><li>将Request封装Call对象</li><li>调用Call.execute()发起同步请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client &#x3D; new OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build();</span><br><span class="line">Request request &#x3D; new Request.Builder().url(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;).get().build();</span><br><span class="line">Call call &#x3D; client.newCall(request);</span><br><span class="line">try &#123;</span><br><span class="line">    Response response &#x3D; call.execute(); &#x2F;&#x2F; 发送同步请求后将进入阻塞状态</span><br><span class="line">    System.out.println(response.body().string())</span><br><span class="line">&#125; catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><ul><li>创建OkHttpClient和Request（Request.Builder）对象</li><li>将Request封装Call对象</li><li>调用Call.enqueue()发起同步请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client &#x3D; new OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build();</span><br><span class="line">Request request &#x3D; new Request.Builder().url(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;).get().build();</span><br><span class="line">Call call &#x3D; client.newCall(request);</span><br><span class="line">call.enqueue(new Callback()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理异常，注意该处理都是在子线程里面处理的</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void onResponse(Call call, Response response) throw IOException&#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 成功 Response，该处理是在子线程里面处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">try &#123;</span><br><span class="line">    Response response &#x3D; call.execute(); &#x2F;&#x2F; 发送同步请求后将进入阻塞状态</span><br><span class="line">    System.out.println(response.body().string())</span><br><span class="line">&#125; catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Builder-配置"><a href="#Builder-配置" class="headerlink" title="Builder 配置"></a>Builder 配置</h2><p>Builder 提供了大量的配置内容，可以根据自己的需求进行对应的配置生成 Client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> public static final class Builder &#123;</span><br><span class="line">        Dispatcher dispatcher; &#x2F;&#x2F;调度器</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 代理类，默认有三种代理模式DIRECT(直连),HTTP（http代理）,SOCKS（socks代理）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable Proxy proxy;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 协议集合，协议类，用来表示使用的协议版本，比如&#96;http&#x2F;1.0,&#96;http&#x2F;1.1,&#96;spdy&#x2F;3.1,&#96;h2等</span><br><span class="line">         *&#x2F;</span><br><span class="line">        List&lt;Protocol&gt; protocols;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 连接规范，用于配置Socket连接层。对于HTTPS，还能配置安全传输层协议（TLS）版本和密码套件</span><br><span class="line">         *&#x2F;</span><br><span class="line">        List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class="line">        &#x2F;&#x2F;拦截器，可以监听、重写和重试请求等</span><br><span class="line">        &#x2F;&#x2F; interceptors 针对所有连接情况，包括websocket</span><br><span class="line">        final List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F; 针对非websocket的连接</span><br><span class="line">        final List&lt;Interceptor&gt; networkInterceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        EventListener.Factory eventListenerFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 代理选择类，默认不使用代理，即使用直连方式，当然，我们可以自定义配置，</span><br><span class="line">         * 以指定URI使用某种代理，类似代理软件的PAC功能</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ProxySelector proxySelector;</span><br><span class="line">        &#x2F;&#x2F;Cookie的保存获取</span><br><span class="line">        CookieJar cookieJar;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 缓存类，内部使用了DiskLruCache来进行管理缓存，匹配缓存的机制不仅仅是根据url，</span><br><span class="line">         * 而且会根据请求方法和请求头来验证是否可以响应缓存。此外，仅支持GET请求的缓存</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable Cache cache;</span><br><span class="line">        &#x2F;&#x2F;内置缓存</span><br><span class="line">        @Nullable InternalCache internalCache;</span><br><span class="line">        &#x2F;&#x2F;Socket的抽象创建工厂，通过createSocket来创建Socket</span><br><span class="line">        SocketFactory socketFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 安全套接层工厂，HTTPS相关，用于创建SSLSocket。一般配置HTTPS证书信任问题都需要从这里着手。</span><br><span class="line">         * 对于不受信任的证书一般会提示</span><br><span class="line">         * javax.net.ssl.SSLHandshakeException异常。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable SSLSocketFactory sslSocketFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 证书链清洁器，HTTPS相关，用于从[Java]的TLS API构建的原始数组中统计有效的证书链，</span><br><span class="line">         * 然后清除跟TLS握手不相关的证书，提取可信任的证书以便可以受益于证书锁机制。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable CertificateChainCleaner certificateChainCleaner;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 主机名验证器，与HTTPS中的SSL相关，当握手时如果URL的主机名</span><br><span class="line">         * 不是可识别的主机，就会要求进行主机名验证</span><br><span class="line">         *&#x2F;</span><br><span class="line">        HostnameVerifier hostnameVerifier;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 证书锁，HTTPS相关，用于约束哪些证书可以被信任，可以防止一些已知或未知</span><br><span class="line">         * 的中间证书机构带来的攻击行为。如果所有证书都不被信任将抛出SSLPeerUnverifiedException异常。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        CertificatePinner certificatePinner;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 身份认证器，当连接提示未授权时，可以通过重新设置请求头来响应一个</span><br><span class="line">         * 新的Request。状态码401表示远程服务器请求授权，407表示代理服务器请求授权。</span><br><span class="line">         * 该认证器在需要时会被RetryAndFollowUpInterceptor触发。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Authenticator proxyAuthenticator;</span><br><span class="line">        Authenticator authenticator;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 连接池</span><br><span class="line">         *</span><br><span class="line">         * 我们通常将一个客户端和服务端和连接抽象为一个 connection，</span><br><span class="line">         * 而每一个 connection 都会被存放在 connectionPool 中，由它进行统一的管理，</span><br><span class="line">         * 例如有一个相同的 http 请求产生时，connection 就可以得到复用</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ConnectionPool connectionPool;</span><br><span class="line">        &#x2F;&#x2F;域名解析系统</span><br><span class="line">        Dns dns;</span><br><span class="line">        &#x2F;&#x2F;是否遵循SSL重定向</span><br><span class="line">        boolean followSslRedirects;</span><br><span class="line">        &#x2F;&#x2F;是否重定向</span><br><span class="line">        boolean followRedirects;</span><br><span class="line">        &#x2F;&#x2F;失败是否重新连接 hhhhhh6****** 3tn</span><br><span class="line">        boolean retryOnConnectionFailure;</span><br><span class="line">        &#x2F;&#x2F;回调超时</span><br><span class="line">        int callTimeout;</span><br><span class="line">        &#x2F;&#x2F;连接超时</span><br><span class="line">        int connectTimeout;</span><br><span class="line">        &#x2F;&#x2F;读取超时</span><br><span class="line">        int readTimeout;</span><br><span class="line">        &#x2F;&#x2F;写入超时</span><br><span class="line">        int writeTimeout;</span><br><span class="line">        &#x2F;&#x2F;与WebSocket有关，为了保持长连接，我们必须间隔一段时间发送一个ping指令进行保；</span><br><span class="line">        int pingInterval;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、请求流程分析"><a href="#三、请求流程分析" class="headerlink" title="三、请求流程分析"></a>三、请求流程分析</h1><p>大体全貌图</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23957/040003B90E114920918B8C1053C0194C"  alt="image"></p><h2 id="同步请求-1"><a href="#同步请求-1" class="headerlink" title="同步请求"></a>同步请求</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22746/E59131FA16C1481E97D46E456075BB1D"  alt="image"></p><h3 id="RealCalll-execute"><a href="#RealCalll-execute" class="headerlink" title="RealCalll.execute()"></a>RealCalll.execute()</h3><p>这方法主要处理：</p><ul><li>校验任务是否被执行过</li><li>将任务加入同步队列</li><li>触发拦截器处理Request队列内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">override fun execute(): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; 如果Call已经被执行过，则不允许被重复执行</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">     executed &#x3D; true</span><br><span class="line">   &#125;</span><br><span class="line">   timeout.enter()</span><br><span class="line">   callStart()</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Dispatcher 只是将该同步任务加入 runnigSyncCalls 队列中</span><br><span class="line">     client.dispatcher.executed(this)</span><br><span class="line">     &#x2F;&#x2F; 拦截器</span><br><span class="line">     return getResponseWithInterceptorChain()</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     client.dispatcher.finished(this)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Dispatcher-executed-call-RealCall"><a href="#Dispatcher-executed-call-RealCall" class="headerlink" title="Dispatcher.executed(call:RealCall)"></a>Dispatcher.executed(call:RealCall)</h3><p>在Dispatcher 维护着多种队列<code>runningAsyncCalls</code>、<code>runningSyncCalls</code>、‘<code>readyAsyncCalls</code>，这里触发的同步任务，是将任务添加到 <code>runningSyncCalls</code> 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#x2F;&#x2F; ArrayDeque 是Deque的实现类，同样是使用一个数组维护，是线程不安全的集合对象，效率高于栈和LinkeList，可以作为双端队列也可以作为栈</span><br><span class="line">private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">...</span><br><span class="line">@Synchronized internal fun executed(call: RealCall) &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="getResponseWithInterceptorChain-触发拦截器处理"><a href="#getResponseWithInterceptorChain-触发拦截器处理" class="headerlink" title="getResponseWithInterceptorChain 触发拦截器处理"></a>getResponseWithInterceptorChain 触发拦截器处理</h3><p>在Okhttp所有请求中最终都将进入对拦截器的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line"> internal fun getResponseWithInterceptorChain(): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">   val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 添加所有应用拦截器</span><br><span class="line">   interceptors +&#x3D; client.interceptors</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 重试拦截器</span><br><span class="line">   interceptors +&#x3D; RetryAndFollowUpInterceptor(client)</span><br><span class="line">   interceptors +&#x3D; BridgeInterceptor(client.cookieJar)</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 缓存专用拦截器</span><br><span class="line">   interceptors +&#x3D; CacheInterceptor(client.cache)</span><br><span class="line">   interceptors +&#x3D; ConnectInterceptor</span><br><span class="line">   </span><br><span class="line">   if (!forWebSocket) &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果不是websocket 则添加Network拦截器</span><br><span class="line">     interceptors +&#x3D; client.networkInterceptors</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 最后一个才是真正调用服务器请求入口，因此需要保证是最后一个</span><br><span class="line">   interceptors +&#x3D; CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 开始组建责任链，建立包装类，index指向拦截器队列的头部</span><br><span class="line">   val chain &#x3D; RealInterceptorChain(interceptors, this, null, 0, originalRequest,</span><br><span class="line">       client.connectTimeoutMillis,</span><br><span class="line">       client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">   var calledNoMoreExchanges &#x3D; false</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 责任链开始，在每一级的Interceptor都要求调用chain的process方法，这样构成了一级一级向下的责任</span><br><span class="line">     val response &#x3D; chain.proceed(originalRequest)</span><br><span class="line">     if (isCanceled()) &#123;</span><br><span class="line">       response.closeQuietly()</span><br><span class="line">       throw IOException(&quot;Canceled&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">     return response</span><br><span class="line">   &#125; catch (e: IOException) &#123;</span><br><span class="line">     calledNoMoreExchanges &#x3D; true</span><br><span class="line">     throw noMoreExchanges(e) as Throwable</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     if (!calledNoMoreExchanges) &#123;</span><br><span class="line">       noMoreExchanges(null)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>RealInterceptorChain.proceed(request: Request, exchange: Exchange?)</li></ul><p>proceed(request: Requst) 最终由 proceed(request: Request, exchange: Exchange?) 代理执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line">  fun proceed(request: Request, exchange: Exchange?): Response &#123;</span><br><span class="line">    if (index &gt;&#x3D; interceptors.size) throw AssertionError()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录调用proceed次数</span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果有 Exchange，</span><br><span class="line">    check(this.exchange &#x3D;&#x3D; null || this.exchange.connection()!!.supportsUrl(request.url)) &#123;</span><br><span class="line">      &quot;network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 确保每个chain.proceed 只能被调用一次</span><br><span class="line">    check(this.exchange &#x3D;&#x3D; null || calls &lt;&#x3D; 1) &#123;</span><br><span class="line">      &quot;network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里产生指向下一个拦截器（index + 1）的处理链，并将这个作为参数传入给当前的拦截器(index)</span><br><span class="line">    val next &#x3D; RealInterceptorChain(interceptors, call, exchange,</span><br><span class="line">        index + 1, request, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    val interceptor &#x3D; interceptors[index]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行当前所指向的拦截器的intercept方法</span><br><span class="line">    @Suppress(&quot;USELESS_ELVIS&quot;)</span><br><span class="line">    val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">        &quot;interceptor $interceptor returned null&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 确保 procceed() 只能被调用一次</span><br><span class="line">    check(exchange &#x3D;&#x3D; null || index + 1 &gt;&#x3D; interceptors.size || next.calls &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      &quot;network interceptor $interceptor must call proceed() exactly once&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 校验Response</span><br><span class="line">    check(response.body !&#x3D; null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125;</span><br><span class="line"></span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Chain 提供的是将interceptor 进行串联 并以以递归的形式向下传递（要求子intercptor 必须调用 intercept(chain: Interceptor.Chain) 参数 chain.process() 方法），最终进行网络请求的是最后的拦截器类 <code>CallServerInterceptor</code></p><ul><li>CallServerInterceptor.intercept(chain: Interceptor.Chain) 处理网络请求</li></ul><p>在 proceed 的方法处理中，提到了 Exchange 类，这里 Exchange 是对 HTTP 事务的包装(实际指向 ExchangeCodec)，因此在这里面最重要的是使用该类进行处理的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val exchange &#x3D; realChain.exchange()</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    val requestBody &#x3D; request.body</span><br><span class="line">    val sentRequestMillis &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对头部数据进行写入</span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    var invokeStartEvent &#x3D; true</span><br><span class="line">    var responseBuilder: Response.Builder? &#x3D; null</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 处理非 GET 和 HEAD 方式的请求，对body进行处理</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; HTTP&#x2F;1.1 协议里设计100 (Continue) HTTP 状态码的的目的是，在客户端发送 Request Message 之前，HTTP&#x2F;1.1 协议允许客户端先判定服务器是否愿意接受客户端发来的消息主体（基于 Request Headers）。即， 客户端 在 Post（较大）数据到服务端之前，允许双方“握手”，如果匹配上了，Client 才开始发送（较大）数据，如果 client 预期等待“100-continue”的应答，那么它发的请求必须包含一个 &quot; Expect: 100-continue&quot;  的头域！</span><br><span class="line"></span><br><span class="line">      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果头部域包含 Expect:100-continue 则进行预请求，判断服务器是否允许body传递，防止服务器拒收</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; true)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; HTTP&#x2F;2 的全双工，暂时忽略，需要客户端和服务端的支持</span><br><span class="line">        if (requestBody.isDuplex()) &#123;</span><br><span class="line">          &#x2F;&#x2F; Prepare a duplex body so that the application can send a request body later.</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, true).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, false).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用了 Expect: 100-continue 情况</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        &#x2F;&#x2F; 如果不是多路复用的情况</span><br><span class="line">        if (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          &#x2F;&#x2F; If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP&#x2F;1 connection</span><br><span class="line">          &#x2F;&#x2F; from being reused. Otherwise we&#39;re still obligated to transmit the request body to</span><br><span class="line">          &#x2F;&#x2F; leave the connection in a consistent state.</span><br><span class="line">          &#x2F;&#x2F; 执行了该动作，会导致不会有进一步的数据事务发生，</span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 因为不存在 body 体，释放request body资源释放</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 结束请求（返回Response），实际也调用了 Sink.flush()</span><br><span class="line">    if (requestBody &#x3D;&#x3D; null || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 读取 Response 信息（如果还未产生 Response 构建的情况）</span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    var code &#x3D; response.code</span><br><span class="line">    if (code &#x3D;&#x3D; 100) &#123;</span><br><span class="line">      &#x2F;&#x2F; Server sent a 100-continue even though we did not request one. Try again to read the actual</span><br><span class="line">      &#x2F;&#x2F; response status.</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response &#x3D; responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code &#x3D; response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response &#x3D; if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">      &#x2F;&#x2F; Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">      &#x2F;&#x2F; 对于 websocket 和 100-continue 情况</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 普通请求</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase &#x3D; true) ||</span><br><span class="line">        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    if ((code &#x3D;&#x3D; 204 || code &#x3D;&#x3D; 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123;</span><br><span class="line">      throw ProtocolException(</span><br><span class="line">          &quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23141/42B3A1AC46224242AD49DFB2FE684D5C"  alt="image"></p><h3 id="Call-enqueue-responseCallback-Callback"><a href="#Call-enqueue-responseCallback-Callback" class="headerlink" title="Call.enqueue(responseCallback: Callback)"></a>Call.enqueue(responseCallback: Callback)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  callStart()</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样需要对Call进行是否执行过的校验</li><li>对RealCall使用AsyncCall进行包装</li><li>将AsynCall添加Dispatcher的异步队列中</li></ul><h3 id="Dispatcher-enqueue-call-AsyncCall"><a href="#Dispatcher-enqueue-call-AsyncCall" class="headerlink" title="Dispatcher.enqueue(call: AsyncCall)"></a>Dispatcher.enqueue(call: AsyncCall)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal fun enqueue(call: AsyncCall) &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加异步任务的就绪异步执行队列    </span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span><br><span class="line">    &#x2F;&#x2F; the same host.</span><br><span class="line">    if (!call.get().forWebSocket) &#123;</span><br><span class="line">      val existingCall &#x3D; findExistingCallWithHost(call.host())</span><br><span class="line">      if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 触发执行异步内容</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dispatcher-promoteAndExecute"><a href="#Dispatcher-promoteAndExecute" class="headerlink" title="Dispatcher.promoteAndExecute()"></a>Dispatcher.promoteAndExecute()</h3><ul><li>检查正在请求总数是否超限、检查单个Host正在请求数是否超限</li><li>自增当前可请求Host计数器</li><li>开始执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提供线程池用于异步请求任务执行</span><br><span class="line">@get:Synchronized</span><br><span class="line">@get:JvmName(&quot;executorService&quot;) val executorService: ExecutorService</span><br><span class="line">  get() &#123;</span><br><span class="line">    if (executorServiceOrNull &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 无核心线程，并且不限制所启动的线程数量，保留60即退出线程</span><br><span class="line">      executorServiceOrNull &#x3D; ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          SynchronousQueue(), threadFactory(&quot;$okHttpName Dispatcher&quot;, false))</span><br><span class="line">    &#125;</span><br><span class="line">    return executorServiceOrNull!!</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">private fun promoteAndExecute(): Boolean &#123;</span><br><span class="line">  this.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  val isRunning: Boolean</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    val i &#x3D; readyAsyncCalls.iterator()</span><br><span class="line">    while (i.hasNext()) &#123;</span><br><span class="line">      val asyncCall &#x3D; i.next()</span><br><span class="line">      &#x2F;&#x2F; 当前执行的异步认为大于最大数量则终止</span><br><span class="line">      if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity.</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 当前所调用的host请求数量大于最大限制，跳过当前请求</span><br><span class="line">      if (asyncCall.callsPerHost().get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity.</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 将允许执行的任务从就绪队列中移除</span><br><span class="line">      i.remove()</span><br><span class="line">      &#x2F;&#x2F; 记录当前请求host数量计数器</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 将允许执行的任务添加到正在执行队列中</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 是否有正在执行的任务（包括异步和同步任务）</span><br><span class="line">    isRunning &#x3D; runningCallsCount() &gt; 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 开始执行允许执行的队列，executorService 为线程池</span><br><span class="line">  for (i in 0 until executableCalls.size) &#123;</span><br><span class="line">    val asyncCall &#x3D; executableCalls[i]</span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RealCall-executeOn-executorService-ExecutorService"><a href="#RealCall-executeOn-executorService-ExecutorService" class="headerlink" title="RealCall.executeOn(executorService: ExecutorService)"></a>RealCall.executeOn(executorService: ExecutorService)</h3><ul><li>执行任务并且处理启动过程中（非执行）发生的异常捕获</li><li>对于异常启动的情况，需要回调给Dispatcher通知结束状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun executeOn(executorService: ExecutorService) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查当前线程是否持有 Dispatcher 锁</span><br><span class="line">      client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">      var success &#x3D; false</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池执行该内容，</span><br><span class="line">        executorService.execute(this)</span><br><span class="line">        success &#x3D; true</span><br><span class="line">      &#125; catch (e: RejectedExecutionException) &#123;</span><br><span class="line">        val ioException &#x3D; InterruptedIOException(&quot;executor rejected&quot;)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        &#x2F;&#x2F; 对于异常情况，会在 noMoreExchanges中根据情况释放连接</span><br><span class="line">        noMoreExchanges(ioException)</span><br><span class="line">        &#x2F;&#x2F; 回调给之前传入的Callback失败信息</span><br><span class="line">        responseCallback.onFailure(this@RealCall, ioException)</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 通知Dispatcher结束请求</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">          client.dispatcher.finished(this) &#x2F;&#x2F; This call is no longer running!</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从以上线程池执行可以看出<code>AsyncCall</code>本身是一个<code>Runnable</code>对象，因此具体的执行内容需要从<code>AsyncCall.run()</code> 入手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  override fun run() &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里只是命名线程名，并且对闭包内容在内部进行执行</span><br><span class="line">    threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 标记是否需要进行回调结果，由于异常可能发生在 onResponse 的时候，所以为了避免两次callback回调，进行标记处理</span><br><span class="line">      var signalledCallback &#x3D; false</span><br><span class="line">      timeout.enter()</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 在这里又重新进入了 getResponseWithInterceptorChain 的分析，参照同步请求的流程</span><br><span class="line">        val response &#x3D; getResponseWithInterceptorChain()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 为下面的回调进行标记，以及被回调过，防止再次发生异常时，重复执行回调（异常的回调）</span><br><span class="line">        signalledCallback &#x3D; true</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 对之前传入的 callback 进行成功回调</span><br><span class="line">        responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">      &#125; catch (e: IOException) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          &#x2F;&#x2F; Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(this@RealCall, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (t: Throwable) &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; 异常发生时，对请求进行一些取消行为</span><br><span class="line">        cancel()</span><br><span class="line">        if (!signalledCallback) &#123;</span><br><span class="line">        </span><br><span class="line">          &#x2F;&#x2F; 同样是对失败时的处理，包装异常类，通知之前的回调callback</span><br><span class="line">          val canceledException &#x3D; IOException(&quot;canceled due to $t&quot;)</span><br><span class="line">          canceledException.addSuppressed(t)</span><br><span class="line">          responseCallback.onFailure(this@RealCall, canceledException)</span><br><span class="line">        &#125;</span><br><span class="line">        throw t</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;  结束通知</span><br><span class="line">        client.dispatcher.finished(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dispatcher-finished"><a href="#Dispatcher-finished" class="headerlink" title="Dispatcher.finished()"></a>Dispatcher.finished()</h4><p>无论是在成功或失败请求后，都需要在最后通知Dispatcher进行finished()动作。</p><ul><li>在结束任务通知后 继续调用promoteAndExecute()尝试启动新一轮任务（如果还有异步任务的话）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123;</span><br><span class="line">   &#x2F;&#x2F; 单元测试时用到</span><br><span class="line">   val idleCallback: Runnable?</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     if (!calls.remove(call)) throw AssertionError(&quot;Call wasn&#39;t in-flight!&quot;)</span><br><span class="line">     idleCallback &#x3D; this.idleCallback</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val isRunning &#x3D; promoteAndExecute()</span><br><span class="line"></span><br><span class="line">   if (!isRunning &amp;&amp; idleCallback !&#x3D; null) &#123;</span><br><span class="line">     idleCallback.run()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>在每次结束后都持续检测是否仍然有需要进行处理的任务。</p><h1 id="四、拦截器"><a href="#四、拦截器" class="headerlink" title="四、拦截器"></a>四、拦截器</h1><p>在以上的流程中，我们不难看出，Okhttp 在具体请求优化方面会体现在拦截器中，通过责任链模式，下面解析下各个拦截器的能力。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23954/5D1289AAEE5549BFA22870B476842CF1"  alt="image"></p><h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><p>该拦截器主要负责：</p><ul><li>创建连接ExchangeFinder 用于连接要求</li><li>当发生异常，对可进行恢复重试的连接进行恢复请求</li><li>当发生多次连接情况（重定向、授权要求），自动进行二次或多次连接</li><li>连接资源释放</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  var request &#x3D; chain.request()</span><br><span class="line">  val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">  val call &#x3D; realChain.call()</span><br><span class="line">  &#x2F;&#x2F; 用于计数循环请求（重定向）次数，该次数不能超过20次，否则抛出异常</span><br><span class="line">  var followUpCount &#x3D; 0</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 用于存储上个循环中所获得的Response，用于下次循环产生的Response对之前Response的追溯，可以跟踪重定向的来源等信息</span><br><span class="line">  var priorResponse: Response? &#x3D; null</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化ExchangeFinder ，为后面连接使用</span><br><span class="line">    call.prepareExchangeFinder(request)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断是否发生取消</span><br><span class="line">    if (call.isCanceled()) &#123;</span><br><span class="line">      throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对于异常情况，根据异常信息进行重试处理</span><br><span class="line">    var response: Response</span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取请求后的 Response</span><br><span class="line">      response &#x3D; realChain.proceed(request, null)</span><br><span class="line">      success &#x3D; true</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      &#x2F;&#x2F; RouteException发生于请求开始，因此requestSendStarted为false，如果该连接不可恢复则抛出异常，否则继续循环</span><br><span class="line">      if (!recover(e.lastConnectException, call, false, request)) &#123;</span><br><span class="line">        throw e.firstConnectException</span><br><span class="line">      &#125;</span><br><span class="line">      continue</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      &#x2F;&#x2F; IOException 可能发生于连接过程中，可能已发送部分请求或全部成功，如果是在连接后发生的异常，则请求可能是以及被发送出去了，标记requestSendStarted为true</span><br><span class="line">      val requestSendStarted &#x3D; e !is ConnectionShutdownException</span><br><span class="line">      if (!recover(e, call, requestSendStarted, request)) throw e</span><br><span class="line">      continue</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 不成功时强制关闭资源</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        call.exchangeDoneDueToException()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果上一个请求有返回Response，并且进入二次请求要求的话，则进行重新包装，用于之后的再次请求，</span><br><span class="line">    if (priorResponse !&#x3D; null) &#123;</span><br><span class="line">      response &#x3D; response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">              .body(null)</span><br><span class="line">              .build())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val exchange &#x3D; response.exchange</span><br><span class="line">    val route &#x3D; exchange?.connection()?.route()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据Response结果要求产生新的Request，比如重定向、授权要求等</span><br><span class="line">    val followUp &#x3D; followUpRequest(response, route)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有进一步请求要求则直接返回当前的Response</span><br><span class="line">    if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (exchange !&#x3D; null &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">        call.timeoutEarlyExit()</span><br><span class="line">      &#125;</span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果有多次请求要求，但是设置只允许请求一次的情况，只能返回Response</span><br><span class="line">    val followUpBody &#x3D; followUp.body</span><br><span class="line">    if (followUpBody !&#x3D; null &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理只有关闭的连接和资源的动作</span><br><span class="line">    response.body?.closeQuietly()</span><br><span class="line">    if (call.hasExchange()) &#123;</span><br><span class="line">      exchange?.detachWithViolence()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 限制最大重定向（重新请求）次数不能超过20次</span><br><span class="line">    if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">      throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将请求信息预留给下次循环的请求</span><br><span class="line">    request &#x3D; followUp</span><br><span class="line">    priorResponse &#x3D; response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  private fun recover(</span><br><span class="line">  e: IOException,</span><br><span class="line">  call: RealCall,</span><br><span class="line">  requestSendStarted: Boolean,</span><br><span class="line">  userRequest: Request</span><br><span class="line">): Boolean &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果设置了禁止重试（OkHttpClient.Builder.retryOnConnectionFailure(Boolean)），则不进行重试</span><br><span class="line">  if (!client.retryOnConnectionFailure) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 对于 设置有body的 Request 的 RequestBody.isOneShot 的方法返回trues时，则只允许发送一次，不允许重试请求</span><br><span class="line">  if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 根据异常信息判断该连接是否可以进行恢复重试</span><br><span class="line">  &#x2F;&#x2F; 1. 如果是协议异常则不进行重试</span><br><span class="line">  &#x2F;&#x2F; 2. 如果为中断异常但是不是连接超时的情况也不允许</span><br><span class="line">  &#x2F;&#x2F; 3. 如果是SSL握手异常并且是证书相关异常则不允许</span><br><span class="line">  &#x2F;&#x2F; 4. 如果是SSL验证结果不可信异常则不允许</span><br><span class="line">  if (!isRecoverable(e, requestSendStarted)) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 检测如果不是流传输异常或者没有Route可以尝试的话，则不进行重试</span><br><span class="line">  if (!call.canRetry()) return false</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><p>该拦截器用于处理:</p><ul><li>头部信息修正或者默认值处理，具体修改参考下面注释</li><li>Cookie支持，对服务器返回的Cookie信息回传给CookieJar处理</li><li>Gzip支持，对支持Gzip的请求结果Response进行解析</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 主要进行头部信息填充</span><br><span class="line">   * Content-Type:  来源于 RequestBody.contentType() （覆盖设置）</span><br><span class="line">   * Content-Length: 来源于 RequestBody.contentLength()，如果length &#x3D; -1 则进行 Transfer-Encoding: chunked 头部填充 （覆盖设置）</span><br><span class="line">   * Host: 来源于 Request.url.toHostHeader() （没有才进行填充）</span><br><span class="line">   * Connection: 默认设置 Keep-Alive (如果没有的话才设置，有的话则不继续替换)</span><br><span class="line">   * Accept-Encoding: 如果没设置 Accept-Encoding 并且没有设置Range(断点) 则默认设置 Accept-Encoding: gzip</span><br><span class="line">   * Cookie：这里的 Cookie 来源于 OkHttpClient.Builder.cookieJar(cookieJar: CookieJar)的设置，默认OkHttpClient为 CookieJar.NoCookies，没有Cookie 信息 (覆盖设置)</span><br><span class="line">   * User-Agent: 如果没设置，默认 okhttp&#x2F;4.4.0-SNAPSHOT</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val userRequest &#x3D; chain.request()</span><br><span class="line">    val requestBuilder &#x3D; userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    val body &#x3D; userRequest.body</span><br><span class="line">    if (body !&#x3D; null) &#123;</span><br><span class="line">      val contentType &#x3D; body.contentType()</span><br><span class="line">      if (contentType !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据body的contentType 信息进行 mime 内容头部信息填充</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      val contentLength &#x3D; body.contentLength()</span><br><span class="line">      if (contentLength !&#x3D; -1L) &#123;</span><br><span class="line">        </span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 标记gzip是否设置，用于后面解析Response判断</span><br><span class="line">    var transparentGzip &#x3D; false</span><br><span class="line">    &#x2F;&#x2F; 如果没设置 Accept-Encoding 并且没有设置Range(断点) 则默认设置 Accept-Encoding: gzip</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      transparentGzip &#x3D; true</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的 cookieJar 来源于 OkHttpClient.Builder.cookieJar(cookieJar: CookieJar)的设置，默认OkHttpClient为 CookieJar.NoCookies </span><br><span class="line">    &#x2F;&#x2F; 不设置Cookie 支持（Cookies 为空非null）,如果有则生成头部 Cookie 段</span><br><span class="line">    val cookies &#x3D; cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    if (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val networkResponse &#x3D; chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 解析Cookie 并回传给 CookieJar 进行处理</span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    val responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 处理gzip内容，如果之前设置了 gzip 支持，并且所返回的服务器 Response 同样 Content-Encoding 支持 gzip，则对返回的Response</span><br><span class="line">    &#x2F;&#x2F; 进行 gzip 解析并添加到新的Reponse 中</span><br><span class="line">    if (transparentGzip &amp;&amp;</span><br><span class="line">        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase &#x3D; true) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">      val responseBody &#x3D; networkResponse.body</span><br><span class="line">      if (responseBody !&#x3D; null) &#123;</span><br><span class="line">        val gzipSource &#x3D; GzipSource(responseBody.source())</span><br><span class="line">        val strippedHeaders &#x3D; networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">            .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        val contentType &#x3D; networkResponse.header(&quot;Content-Type&quot;)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><p>前面提到OkHttp 缓存拦截器 CacheInterceptor，在该拦截器中实现了网络缓存的绝大逻辑。</p><p>在intercept 工作中主要处理：</p><ul><li>根据 HTTP的缓存规则（比如根据头部信息、Tag等缓存条件）判断当前所进行的请求，以及在缓存中缓存的内容是否能命中该次请求（通过CacheStrategy进行构造处理）</li><li>对Request是否满足和Response是否满足进行分别处理：<ul><li>如果Request不满足条件（策略会校验是否有网络等情况，如果不满足则返回null) 而缓存Response 满足，则返回缓存Response</li><li>如果Request 和缓存Response 都不满足，则返回504 Response</li><li>如果Request 满足 而 缓存Response不满足，则使用请求后的Respnse</li><li>对于304结果，更新缓存并且返回缓存Response </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  &#x2F;&#x2F; cache 来源于 OkHttpClient.Builder.cache(cache: Cache?)，默认为null</span><br><span class="line">  val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">  val now &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 传入当前请求信息和获得的候选缓存Response，根据一些HTTP缓存规则，判断当前候选Reponse是否可用，对Request也会进行一些判断，比如当前网络是否可用</span><br><span class="line">  val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  val networkRequest &#x3D; strategy.networkRequest &#x2F;&#x2F; 如果网络不可用，则默认这里会为null</span><br><span class="line">  val cacheResponse &#x3D; strategy.cacheResponse &#x2F;&#x2F; 如果cacheCandidate可用，则这里会返回一致，如果不可用则返回null（缓存过期之类的）</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单元测试使用</span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前从缓存中获得的缓存候选和实际计算出的缓存Response不匹配（不符合条件，为空），则抛弃候选缓存Cache</span><br><span class="line">  if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果返回的网络请求为空，则说明网络当前不可用，并且允许缓存Response也为空，则默认返回504即可</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-1L)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果仅是网络不可用导致Request不能请求，那么直接返回命中的Response缓存即可，复用结果</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 执行网络请求</span><br><span class="line">  var networkResponse: Response? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">    networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">    if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果缓存存在，并且服务器返回304则更新下缓存信息并返回</span><br><span class="line">  if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">    if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line"></span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">      &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)</span><br><span class="line">      return response</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果有缓存器，并且缓存策略允许被缓存，则添加到缓存中</span><br><span class="line">  if (cache !&#x3D; null) &#123;</span><br><span class="line">    if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">      val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">      return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  目前缓存只缓存GET请求内容，官方解释说，如果所有的形式都缓存，复杂度高但是收效低，则对于非法的缓存进行移除（GET不需要？)</span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; catch (_: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在CacheInterceptor 中比较重要的是 <code>Cache</code> 类，它提供了整个缓存下的功能。这里分析下该类的主要构成。</p><p>从 Cache 中，我们不难发现，它所有的缓存行为都是通过 <code>DiskLruCache</code>进行代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> internal val cache &#x3D; DiskLruCache(</span><br><span class="line">     fileSystem &#x3D; fileSystem,</span><br><span class="line">     directory &#x3D; directory,</span><br><span class="line">     appVersion &#x3D; VERSION,</span><br><span class="line">     valueCount &#x3D; ENTRY_COUNT,</span><br><span class="line">     maxSize &#x3D; maxSize,</span><br><span class="line">     taskRunner &#x3D; TaskRunner.INSTANCE</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> internal fun get(request: Request): Response? &#123;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Okhttp 都是简单用Url作为索引</span><br><span class="line">   val key &#x3D; key(request.url)</span><br><span class="line">   val snapshot: DiskLruCache.Snapshot &#x3D; try &#123;</span><br><span class="line">       &#x2F;&#x2F; 通过DiskLruCache 获取缓存中的对象，如果没有则直接异常返回null</span><br><span class="line">     cache[key] ?: return null</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Give up because the cache cannot be read.</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 包装为Cache.Entry 对象，在Entry 中对 Snapshot对象进行解析，并对Entry中的字段进行赋值，转化为业务含义的的信息</span><br><span class="line">   val entry: Entry &#x3D; try &#123;</span><br><span class="line">     Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     snapshot.closeQuietly()</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 解析Snaphost中的 Reponse缓存信息，并转化为 Reponse 业务对象</span><br><span class="line">   val response &#x3D; entry.response(snapshot)</span><br><span class="line">   if (!entry.matches(request, response)) &#123;</span><br><span class="line">     response.body?.closeQuietly()</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return response</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">  fun response(snapshot: DiskLruCache.Snapshot): Response &#123;</span><br><span class="line">     val contentType &#x3D; responseHeaders[&quot;Content-Type&quot;]</span><br><span class="line">     val contentLength &#x3D; responseHeaders[&quot;Content-Length&quot;]</span><br><span class="line">     val cacheRequest &#x3D; Request.Builder()</span><br><span class="line">         .url(url)</span><br><span class="line">         .method(requestMethod, null)</span><br><span class="line">         .headers(varyHeaders)</span><br><span class="line">         .build()</span><br><span class="line">     return Response.Builder()</span><br><span class="line">         .request(cacheRequest)</span><br><span class="line">         .protocol(protocol)</span><br><span class="line">         .code(code)</span><br><span class="line">         .message(message)</span><br><span class="line">         .headers(responseHeaders)</span><br><span class="line">         .body(CacheResponseBody(snapshot, contentType, contentLength))</span><br><span class="line">         .handshake(handshake)</span><br><span class="line">         .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">         .receivedResponseAtMillis(receivedResponseMillis)</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>Cache</code>中更多的是对DiskLruCache 所需要处理的信息进行拆包和包装，因此这里我们直接看 <code>DiskLruCache</code>。</p><h4 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h4><p>在 DiskLruCache 主要分成几种对象结构：</p><ul><li>Entry 单个缓存数据的代理对象，用于在 LinkHashMap 中的存储，规定了缓存文件（cleanFiles）、临时文件（dirtyFiles）以及提供了 Snapshot 对象入口，Entry 不对数据有写入能力。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">internal inner class Entry internal constructor(</span><br><span class="line">    internal val key: String</span><br><span class="line">  ) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 数据长度</span><br><span class="line">    internal val lengths: LongArray &#x3D; LongArray(valueCount)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于正式写入的文件</span><br><span class="line">    internal val cleanFiles &#x3D; mutableListOf&lt;File&gt;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于临时数据写入的文件，目前默认都是2个，最终需要调用Edit.commit 才能写入正式文件</span><br><span class="line">    internal val dirtyFiles &#x3D; mutableListOf&lt;File&gt;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 文件是否可读取</span><br><span class="line">    internal var readable: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录当前被编辑的对象，有且只能有一个在编辑</span><br><span class="line">    internal var currentEditor: Editor? &#x3D; null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每一个Snapshot 会产生一个序列号，每次发生Edit.commit后 序列号都会发生变化</span><br><span class="line">    internal var sequenceNumber: Long &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 产生当前Entry对应的Snapshot对象</span><br><span class="line">    internal fun snapshot(): Snapshot?</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Snapshot 负责对缓存数据的详细源记录，包括值信息、磁盘缓存数据源（File Source)、数据长度等。提供给外部获取具体缓存内容使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inner class Snapshot internal constructor(</span><br><span class="line">  private val key: String, </span><br><span class="line">  private val sequenceNumber: Long, &#x2F;&#x2F; 每个独立提交都对应一个</span><br><span class="line">  private val sources: List&lt;Source&gt;, &#x2F;&#x2F; 缓存文件目前只有两个 0 index 为头文件 1 为 body 文件</span><br><span class="line">  private val lengths: LongArray &#x2F;&#x2F; 数据长度信息</span><br><span class="line">) : Closeable &#123;</span><br><span class="line">  fun key(): String &#x3D; key</span><br><span class="line">  &#x2F;&#x2F; 获得一个Edit 对象，对内容进行编辑事务处理。</span><br><span class="line">  fun edit(): Editor? &#x3D; this@DiskLruCache.edit(key, sequenceNumber)</span><br><span class="line">  fun getSource(index: Int): Source &#x3D; sources[index]</span><br><span class="line">  override fun close() &#123;</span><br><span class="line">    for (source in sources) &#123;</span><br><span class="line">      source.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Edit 负责对数据的写入事务处理，在完成事务有需要进行 commit 提交<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Edits the values for an entry. *&#x2F;</span><br><span class="line"> inner class Editor internal constructor(internal val entry: Entry) &#123;</span><br><span class="line">   &#x2F;&#x2F; 用来标记开启几个写入文件</span><br><span class="line">   internal val written: BooleanArray? &#x3D; if (entry.readable) null else BooleanArray(valueCount)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 检查 edit事务是否完成 commit 和 abort 可以触发 done &#x3D; true 动作</span><br><span class="line">   private var done: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 移除临时目录下所有文件</span><br><span class="line">   internal fun detach()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 返回指定的数据源（正式数据）（目前index &#x3D; 0 为头文件  index &#x3D; 1 为body文件）</span><br><span class="line">   fun newSource(index: Int): Source?</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建临时文件的写入代理</span><br><span class="line">   fun newSink(index: Int): Sink </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 提交修改的数据，将临时文件转为正式缓存文件</span><br><span class="line">   fun commit() </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 放弃修改，会将所有临时文件删除</span><br><span class="line">   fun abort() </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="缓存溢出处理"><a href="#缓存溢出处理" class="headerlink" title="缓存溢出处理"></a>缓存溢出处理</h5><p>在每次发生修改、提交都将对内容进行队列内容进行检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 一个包装的线程池</span><br><span class="line"> private val cleanupQueue &#x3D; taskRunner.newQueue()</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 清理任务</span><br><span class="line"> private val cleanupTask &#x3D; object : Task(&quot;$okHttpName Cache&quot;) &#123;</span><br><span class="line">   override fun runOnce(): Long &#123;</span><br><span class="line">     synchronized(this@DiskLruCache) &#123;</span><br><span class="line">       if (!initialized || closed) &#123;</span><br><span class="line">         return -1L &#x2F;&#x2F; Nothing to do.</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">        &#x2F;&#x2F; LinkHashMap 容量检测</span><br><span class="line">         trimToSize()</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         mostRecentTrimFailed &#x3D; true</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">        &#x2F;&#x2F; 日志清除</span><br><span class="line">         if (journalRebuildRequired()) &#123;</span><br><span class="line">           rebuildJournal()</span><br><span class="line">           redundantOpCount &#x3D; 0</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         mostRecentRebuildFailed &#x3D; true</span><br><span class="line">         journalWriter &#x3D; blackholeSink().buffer()</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return -1L</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line">  @get:Synchronized @set:Synchronized var maxSize: Long &#x3D; maxSize</span><br><span class="line">  set(value) &#123;</span><br><span class="line">     field &#x3D; value</span><br><span class="line">     if (initialized) &#123;</span><br><span class="line">       cleanupQueue.schedule(cleanupTask) &#x2F;&#x2F; 初始化缓存容量时对当前缓存进行一次清理</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> fun trimToSize() &#123;</span><br><span class="line">   while (size &gt; maxSize) &#123;</span><br><span class="line">     val toEvict &#x3D; lruEntries.values.iterator().next()</span><br><span class="line">     removeEntry(toEvict)</span><br><span class="line">   &#125;</span><br><span class="line">   mostRecentTrimFailed &#x3D; false</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> internal fun removeEntry(entry: Entry): Boolean &#123;</span><br><span class="line">   entry.currentEditor?.detach() &#x2F;&#x2F; Prevent the edit from completing normally.</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 移除Entry文件，目前为两个</span><br><span class="line">   for (i in 0 until valueCount) &#123;</span><br><span class="line">     fileSystem.delete(entry.cleanFiles[i])</span><br><span class="line">     size -&#x3D; entry.lengths[i]</span><br><span class="line">     entry.lengths[i] &#x3D; 0</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 日志记录</span><br><span class="line">   journalWriter!!.writeUtf8(REMOVE)</span><br><span class="line">       .writeByte(&#39; &#39;.toInt())</span><br><span class="line">       .writeUtf8(entry.key)</span><br><span class="line">       .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">   lruEntries.remove(entry.key)</span><br><span class="line"></span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 获取时清理</span><br><span class="line"> operator fun get(key: String): Snapshot? &#123;</span><br><span class="line">   ...</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     &#x2F;&#x2F; 执行清理</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return snapshot</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 删除时清理 </span><br><span class="line">internal fun removeEntry(entry: Entry): Boolean &#123;</span><br><span class="line">   ....</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true</span><br><span class="line"> &#125;  </span><br><span class="line"> </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h5 id="产生-Edit"><a href="#产生-Edit" class="headerlink" title="产生 Edit"></a>产生 Edit</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Synchronized @Throws(IOException::class)</span><br><span class="line">@JvmOverloads</span><br><span class="line">fun edit(key: String, expectedSequenceNumber: Long &#x3D; ANY_SEQUENCE_NUMBER): Editor? &#123;</span><br><span class="line">  initialize()</span><br><span class="line"></span><br><span class="line">  checkNotClosed()</span><br><span class="line">  &#x2F;&#x2F; 正则命名验证</span><br><span class="line">  validateKey(key)</span><br><span class="line">  var entry: Entry? &#x3D; lruEntries[key]</span><br><span class="line">  &#x2F;&#x2F; 如果指定了序列话数值 expectedSequenceeNumber , 那么就是为了找到之前存入Entry的内容，找不到返回null</span><br><span class="line">  if (expectedSequenceNumber !&#x3D; ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">      (entry &#x3D;&#x3D; null || entry.sequenceNumber !&#x3D; expectedSequenceNumber)) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Snapshot is stale.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 正在编辑中的Entry 不被允许重复编辑</span><br><span class="line">  if (entry?.currentEditor !&#x3D; null) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Another edit is in progress.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 保险丝机制，mostRecentTrimFailed 标记对最近移除溢出数据时发生失败的情况，mostRecentRebuildFailed 日志写入失败的情况</span><br><span class="line">  &#x2F;&#x2F; 如果发生该情况，表示当前该工具存储状态异常，因此执行重新清理的任务，拒绝进行编辑</span><br><span class="line">  if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">    cleanupQueue.schedule(cleanupTask)</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Flush the journal before creating files to prevent file leaks.</span><br><span class="line">  val journalWriter &#x3D; this.journalWriter!!</span><br><span class="line">  journalWriter.writeUtf8(DIRTY)</span><br><span class="line">      .writeByte(&#39; &#39;.toInt())</span><br><span class="line">      .writeUtf8(key)</span><br><span class="line">      .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">  journalWriter.flush()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 日志写入发生异常，不允许进行编辑</span><br><span class="line">  if (hasJournalErrors) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Don&#39;t edit; the journal can&#39;t be written.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">    entry &#x3D; Entry(key)</span><br><span class="line">    lruEntries[key] &#x3D; entry</span><br><span class="line">  &#125;</span><br><span class="line">  val editor &#x3D; Editor(entry)</span><br><span class="line">  entry.currentEditor &#x3D; editor</span><br><span class="line">  return editor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化与备份"><a href="#初始化与备份" class="headerlink" title="初始化与备份"></a>初始化与备份</h5><p>初始化包括几个流程：</p><ul><li>校验文件系统情况，如果丢失则用备份进行还原</li><li>正常初始化，读取目录下所有缓存文件信息</li><li>如果初始化失败，则移除整个缓存文件夹，并重新建立整个缓存文件夹。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">fun initialize() &#123;</span><br><span class="line">    this.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">    if (initialized) &#123;</span><br><span class="line">      return &#x2F;&#x2F; Already initialized.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 验证文件是否正常，如果丢失日志则进行备份还原</span><br><span class="line">    if (fileSystem.exists(journalFileBackup)) &#123;</span><br><span class="line">      if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果正常则删除备份文件，否则使用备份文件</span><br><span class="line">        fileSystem.delete(journalFileBackup)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        fileSystem.rename(journalFileBackup, journalFile)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prefer to pick up where we left off.</span><br><span class="line">    if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        readJournal()</span><br><span class="line">        processJournal()</span><br><span class="line">        initialized &#x3D; true</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 到此初始化完成</span><br><span class="line">        return</span><br><span class="line">      &#125; catch (journalIsCorrupt: IOException) &#123;</span><br><span class="line">        Platform.get().log(</span><br><span class="line">            &quot;DiskLruCache $directory is corrupt: $&#123;journalIsCorrupt.message&#125;, removing&quot;,</span><br><span class="line">            WARN,</span><br><span class="line">            journalIsCorrupt)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果初始化失败则删除整个缓存文件夹，重建整个缓存，维持正常的执行（保险丝机制）</span><br><span class="line">      try &#123;</span><br><span class="line">        delete()</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        closed &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rebuildJournal()</span><br><span class="line"></span><br><span class="line">    initialized &#x3D; true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p><code>ConnectInterceptor</code> 主要负责在执行内容传输前的连接建立流程，比如TCP、TLS等连接的建立，以及授权、验证等。并且在产生连接通道后（RealConnection）将对连接进行缓存（RealConnectionPool），以便于在后面中进行连接复用。在该连接中不涉及数据交互。</p><p>OkHttp对连接做了比较多的优化，在结构上比较复杂，需要先对数据结构熟悉：</p><ul><li>ConnectionSpec <code>描述在HTTP进行连接通道时所需要的配置内容，目前仅涉及HTTPS在TLS版本、加密套件</code></li><li>ConnectionSpecSelector <code>根据提供的ConnectionSpec列表，对SSLSocket进行配置</code></li><li>Route <code>用来描述网络数据包的传输路径，主要描述出和TCP建立的目标点，包括代理的描述。路由信息通过RouteSelector产生，在一个host下可能存在多个链接点，因此可能产生多个Route信息。</code></li><li>RouteDatabase <code>记录失败的Route信息，避免下次使用无效Route，配合RouteSelector使用</code></li><li>RouteSelector <code>根据Proxie代理信息和Address进行合适的Route选择，在RouteSelector 中会将URL、Port信息转化为Proxy，并通过DNS进行查询，将多个连接点封装为所有Route</code></li><li>Protocol <code>连接所使用的协议信息</code></li><li>Address <code>用于存储所有连接前置信息，包含连接所需要的主机名host、端口号port，Dns、代理服务器Proxy、对于包含Https要求，则提供 SSLSocketFactory、HostnameVerifier、CertificatePinner、Authenticator等授权信息，</code></li><li>RealConnection <code>代表着socket链路，每一个RealConnection代表一条跟服务器的通信链路，在该类中完成主要的连接流程（TCP握手、TLS连接验证、协议连接）</code></li></ul><h3 id="RouteSelector、Route-与-Proxy"><a href="#RouteSelector、Route-与-Proxy" class="headerlink" title="RouteSelector、Route 与 Proxy"></a>RouteSelector、Route 与 Proxy</h3><p>在OkHttp 中，同一个域名host下可能存在多个连接点(或者多个代理连接点)，对于这些连接点，OkHttp 抽象成 Route 信息以方便进行连接。</p><h4 id="预处理Proxy"><a href="#预处理Proxy" class="headerlink" title="预处理Proxy"></a>预处理Proxy</h4><p>RouteSelector 初始化中，对Proxy进行预处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">   &#x2F;&#x2F; 初始化 proxy 信息</span><br><span class="line">   resetNextProxy(address.url, address.proxy)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 如果在OkHttpClient.Builder.proxy 定义了则使用该定义内容，否则判断是否设置了 proxySelector(目前只有单元测试用到）</span><br><span class="line"> &#x2F;&#x2F; 如果 ProxySelector.select 返回为null 则返回 默认 Proxy.NO_PROXY 兜底 proxy 。</span><br><span class="line"> private fun resetNextProxy(url: HttpUrl, proxy: Proxy?) &#123;</span><br><span class="line">   eventListener.proxySelectStart(call, url)</span><br><span class="line">   proxies &#x3D; if (proxy !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 OkHttpClient.Builder.proxy 主动设置了代理信息，那么只记录该代理</span><br><span class="line">     listOf(proxy)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果在OkHttpClient 中设置了 proxy 则proxySelector 为 NullProxySelector，否则这里</span><br><span class="line">     &#x2F;&#x2F; proxySelector 返回的是系统（平台）的ProxySelector 否则还是为 NullProxySelector</span><br><span class="line">     &#x2F;&#x2F; NullProxySelector 默认 select 返回一个空集合，因此如果到空集合的话最红返回的是只有一个 NO_PROXY的集合</span><br><span class="line">     &#x2F;&#x2F; 作为兜底，NO_PROXY 默认 type &#x3D; Proxy.Type.DIRECT</span><br><span class="line">     val proxiesOrNull &#x3D; address.proxySelector.select(url.toUri())</span><br><span class="line">     if (proxiesOrNull !&#x3D; null &amp;&amp; proxiesOrNull.isNotEmpty()) &#123;</span><br><span class="line">       proxiesOrNull.toImmutableList()</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       immutableListOf(Proxy.NO_PROXY)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   nextProxyIndex &#x3D; 0</span><br><span class="line">   eventListener.proxySelectEnd(call, url, proxies)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="RouteSelector的使用"><a href="#RouteSelector的使用" class="headerlink" title="RouteSelector的使用"></a>RouteSelector的使用</h4><p>RouteSelector 关键方法为 <code>next</code>，执行该方法将产生一个 <code>Selection</code>对象，用于存储所产生的<code>Route</code>候选集合内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nextProxyIndex 用来标记当前所处理的代理集合的位置，在next和nextProxy中开始进行解析</span><br><span class="line">private fun hasNextProxy(): Boolean &#x3D; nextProxyIndex &lt; proxies.size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Throws(IOException::class)</span><br><span class="line">private fun nextProxy(): Proxy &#123;</span><br><span class="line">  &#x2F;&#x2F; proxy一定会有一个值，至少存在一个 NO_PROXY</span><br><span class="line">  if (!hasNextProxy()) &#123;</span><br><span class="line">    throw SocketException(</span><br><span class="line">        &quot;No route to $&#123;address.url.host&#125;; exhausted proxy configurations: $proxies&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">   val result &#x3D; proxies[nextProxyIndex++]</span><br><span class="line">   resetNextInetSocketAddress(result)</span><br><span class="line">   return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据Proxy和host dns解析所有可用的 InetSocketAddress 并存在 inetSocketAddresses 字段中</span><br><span class="line"> private fun resetNextInetSocketAddress(proxy: Proxy) &#123;</span><br><span class="line">    val mutableInetSocketAddresses &#x3D; mutableListOf&lt;InetSocketAddress&gt;()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化RouteSelector.inetSocketAddresses 属性，将解析的结果存储在该列表中</span><br><span class="line">    inetSocketAddresses &#x3D; mutableInetSocketAddresses</span><br><span class="line"></span><br><span class="line">    val socketHost: String</span><br><span class="line">    val socketPort: Int</span><br><span class="line">    &#x2F;&#x2F; 如果代理类型为直连或者Socket类型，则可以直接用他们提供的host port ，否则通过InetSocketAddress获取真实地址</span><br><span class="line">    if (proxy.type() &#x3D;&#x3D; Proxy.Type.DIRECT || proxy.type() &#x3D;&#x3D; Proxy.Type.SOCKS) &#123;</span><br><span class="line">      socketHost &#x3D; address.url.host</span><br><span class="line">      socketPort &#x3D; address.url.port</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      val proxyAddress &#x3D; proxy.address()</span><br><span class="line">      require(proxyAddress is InetSocketAddress) &#123;</span><br><span class="line">        &quot;Proxy.address() is not an InetSocketAddress: $&#123;proxyAddress.javaClass&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      socketHost &#x3D; proxyAddress.socketHost</span><br><span class="line">      socketPort &#x3D; proxyAddress.port</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查端口设置是否超过范围</span><br><span class="line">    if (socketPort !in 1..65535) &#123;</span><br><span class="line">      throw SocketException(&quot;No route to $socketHost:$socketPort; port is out of range&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 proxy 为 SOCKTS 代理则不需要处理 host dns，否则预处理host 的dns解析结果</span><br><span class="line">    if (proxy.type() &#x3D;&#x3D; Proxy.Type.SOCKS) &#123;</span><br><span class="line">     &#x2F;&#x2F; SOCKS 代理不需要解析host ip, 根据主机名和端口号创建未解析的套接字地址</span><br><span class="line">      mutableInetSocketAddresses +&#x3D; InetSocketAddress.createUnresolved(socketHost, socketPort)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      eventListener.dnsStart(call, socketHost)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 根据提供的host查询到支持的所有ip地址信息</span><br><span class="line">      val addresses &#x3D; address.dns.lookup(socketHost)</span><br><span class="line">      if (addresses.isEmpty()) &#123;</span><br><span class="line">        throw UnknownHostException(&quot;$&#123;address.dns&#125; returned no addresses for $socketHost&quot;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      eventListener.dnsEnd(call, socketHost, addresses)</span><br><span class="line">      &#x2F;&#x2F; 将所解析出来的所有地址封装套接字地址</span><br><span class="line">      for (inetAddress in addresses) &#123;</span><br><span class="line">        mutableInetSocketAddresses +&#x3D; InetSocketAddress(inetAddress, socketPort)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">operator fun next(): Selection &#123;</span><br><span class="line">    if (!hasNext()) throw NoSuchElementException()</span><br><span class="line"></span><br><span class="line">    val routes &#x3D; mutableListOf&lt;Route&gt;()</span><br><span class="line">    while (hasNextProxy()) &#123;</span><br><span class="line">      &#x2F;&#x2F; nextProxy() 读取一个Proxy信息，并对inetSocketAddresses 连接点进行预处理</span><br><span class="line">      val proxy &#x3D; nextProxy()</span><br><span class="line">      for (inetSocketAddress in inetSocketAddresses) &#123;</span><br><span class="line">      &#x2F;&#x2F;  将 inetSocketAddress 包装成 Route</span><br><span class="line">        val route &#x3D; Route(address, proxy, inetSocketAddress)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 该Route是否在黑名单中，否则添加到候选routes中</span><br><span class="line">        if (routeDatabase.shouldPostpone(route)) &#123;</span><br><span class="line">          postponedRoutes +&#x3D; route</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          routes +&#x3D; route</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (routes.isNotEmpty()) &#123;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果没有可用的 Route 就将之前不可用的 Route拿来尽可能尝试下</span><br><span class="line">    if (routes.isEmpty()) &#123;</span><br><span class="line">      routes +&#x3D; postponedRoutes</span><br><span class="line">      postponedRoutes.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Selection(routes)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在next中主要处理：</p><ul><li>读取Proxy信息，如果非Socket代理则对host提前进行dns解析，得到ip</li><li>对Proxy和所解析出所有结果进行Route包装</li><li>将所获得的Route包装集合封装到Selection中，提供给使用方选择连接点</li></ul><h3 id="ConnectionSpec-与-ConnectionSpecSelector"><a href="#ConnectionSpec-与-ConnectionSpecSelector" class="headerlink" title="ConnectionSpec 与 ConnectionSpecSelector"></a>ConnectionSpec 与 ConnectionSpecSelector</h3><p>ConnectionSpec 主要是对连接时对Socket的配置，这里面包括TLS所需要进行的版本和密码套件协商信息，而ConnectionSpecSelector 则对最终选择的ConnectionSpec 进行筛选，目前仅对SSLSocket进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主要对Socket所支持的协议和加密配套进行交集判断</span><br><span class="line">  fun isCompatible(socket: SSLSocket): Boolean &#123;</span><br><span class="line">    if (!isTls) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tlsVersionsAsString !&#x3D; null &amp;&amp;</span><br><span class="line">        !tlsVersionsAsString.hasIntersection(socket.enabledProtocols, naturalOrder())) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cipherSuitesAsString !&#x3D; null &amp;&amp;</span><br><span class="line">        !cipherSuitesAsString.hasIntersection(</span><br><span class="line">            socket.enabledCipherSuites, CipherSuite.ORDER_BY_NAME)) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fun configureSecureSocket(sslSocket: SSLSocket): ConnectionSpec &#123;</span><br><span class="line">    var tlsConfiguration: ConnectionSpec? &#x3D; null</span><br><span class="line">    for (i in nextModeIndex until connectionSpecs.size) &#123;</span><br><span class="line">      val connectionSpec &#x3D; connectionSpecs[i]</span><br><span class="line">      &#x2F;&#x2F; 判断该配置是否和当前连接兼容</span><br><span class="line">      if (connectionSpec.isCompatible(sslSocket)) &#123;</span><br><span class="line">        tlsConfiguration &#x3D; connectionSpec</span><br><span class="line">        nextModeIndex &#x3D; i + 1</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tlsConfiguration &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw UnknownServiceException(&quot;Unable to find acceptable protocols. isFallback&#x3D;$isFallback,&quot; +</span><br><span class="line">          &quot; modes&#x3D;$connectionSpecs,&quot; +</span><br><span class="line">          &quot; supported protocols&#x3D;$&#123;sslSocket.enabledProtocols!!.contentToString()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isFallbackPossible &#x3D; isFallbackPossible(sslSocket)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 对SSLSocket进行配置应用</span><br><span class="line">    tlsConfiguration.apply(sslSocket, isFallback)</span><br><span class="line"></span><br><span class="line">    return tlsConfiguration</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>OkHttp 中配置了几个基本的默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通用加密套件</span><br><span class="line">private val RESTRICTED_CIPHER_SUITES &#x3D; arrayOf(</span><br><span class="line">    &#x2F;&#x2F; TLSv1.3.</span><br><span class="line">    CipherSuite.TLS_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TLSv1.0, TLSv1.1, TLSv1.2.</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所有支持的加密套件，包括后面可能不被支持的加密，用于兼容一些老平台</span><br><span class="line">private val APPROVED_CIPHER_SUITES &#x3D; arrayOf(</span><br><span class="line">    &#x2F;&#x2F; TLSv1.3.</span><br><span class="line">    CipherSuite.TLS_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TLSv1.0, TLSv1.1, TLSv1.2.</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下加密套在Http2.0可能被废弃</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA)</span><br><span class="line"></span><br><span class="line">&#x2F;** 目前主流的配置方案 *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val RESTRICTED_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*RESTRICTED_CIPHER_SUITES) &#x2F;&#x2F; 密码套件</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2) &#x2F;&#x2F; TLS 支持版本</span><br><span class="line">    .supportsTlsExtensions(true) &#x2F;&#x2F; TLS异常</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 适配大部分平台的配置方案(扩大加密套件的支持，以兼容一些平台)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val MODERN_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)</span><br><span class="line">    .supportsTlsExtensions(true)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 向后大部分兼容的的配置方案，包含 TLS1.3、TLS1.2、TLS1.1、TLS1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val COMPATIBLE_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)</span><br><span class="line">    .supportsTlsExtensions(true)</span><br><span class="line">    .build()</span><br><span class="line">    </span><br><span class="line">&#x2F;** 明文配置，用于Http，不进行TLS *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val CLEARTEXT &#x3D; Builder(false).build()</span><br></pre></td></tr></table></figure><p>通过<code>OkHttpClient.Builder.connectionSpecs</code>可以对候选配置内容进行配置，默认情况下使用 <code>DEFAULT_CONNECTION_SPECS</code> 组合</p><h4 id="ConnectionSpec-apply-配置"><a href="#ConnectionSpec-apply-配置" class="headerlink" title="ConnectionSpec.apply 配置"></a>ConnectionSpec.apply 配置</h4><p>apply 主要对最终连接的 SSLSocket 的加密配套和 TLS版本根据 SSLSocket支持的情况和 OkHttp 配置要求的情况进行交集配置。</p><p><code>如果需要对OkHttp TLS 版本或者加密配套相关调整，需要注意改动不仅仅是OkHttp的配置还需要对SSLSocket.setEnableCipherSuites 进行处理，这些内容都可以在 OkHttpClient.Build.sslSocketFactory 进行配置</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">internal fun apply(sslSocket: SSLSocket, isFallback: Boolean) &#123;</span><br><span class="line">  val specToApply &#x3D; supportedSpec(sslSocket, isFallback)</span><br><span class="line">  </span><br><span class="line">  if (specToApply.tlsVersions !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledProtocols &#x3D; specToApply.tlsVersionsAsString</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (specToApply.cipherSuites !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites &#x3D; specToApply.cipherSuitesAsString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主要对SSLSocket 一些支持信息（TLS版本、加密套）和 所配置的内容进行匹配，取交集得到最终要求的TLS版本和配件套</span><br><span class="line">private fun supportedSpec(sslSocket: SSLSocket, isFallback: Boolean): ConnectionSpec &#123;</span><br><span class="line">  &#x2F;&#x2F; 所配置的加密配件和SSLSocket.enabledCipherSuites所支持的配件套交集</span><br><span class="line">  var cipherSuitesIntersection &#x3D; if (cipherSuitesAsString !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites.intersect(cipherSuitesAsString, CipherSuite.ORDER_BY_NAME)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 所配置的TLS版本和SSLSocket.enabledProtocols所支持交集结果</span><br><span class="line">  val tlsVersionsIntersection &#x3D; if (tlsVersionsAsString !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledProtocols.intersect(tlsVersionsAsString, naturalOrder())</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sslSocket.enabledProtocols</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; TLS_FALLBACK_SCSV 支持</span><br><span class="line">  val supportedCipherSuites &#x3D; sslSocket.supportedCipherSuites</span><br><span class="line">  val indexOfFallbackScsv &#x3D; supportedCipherSuites.indexOf(</span><br><span class="line">      &quot;TLS_FALLBACK_SCSV&quot;, CipherSuite.ORDER_BY_NAME)</span><br><span class="line">  if (isFallback &amp;&amp; indexOfFallbackScsv !&#x3D; -1) &#123;</span><br><span class="line">    cipherSuitesIntersection &#x3D; cipherSuitesIntersection.concat(</span><br><span class="line">        supportedCipherSuites[indexOfFallbackScsv])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Builder(this)</span><br><span class="line">      .cipherSuites(*cipherSuitesIntersection)</span><br><span class="line">      .tlsVersions(*tlsVersionsIntersection)</span><br><span class="line">      .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RealConnection中的连接"><a href="#RealConnection中的连接" class="headerlink" title="RealConnection中的连接"></a>RealConnection中的连接</h3><p>真正通道连接发生在 RealConnect.connet 。</p><p>connet 主要分为几个流程：</p><ul><li>获取Socket配置（ConnectionSpec、ConnectionSpecSelector）</li><li>校验如果没有配置SSLSocketFactory，是否支持明文配置（ConnectionSpec.CLEARTEXT），平台是否支持明文传输</li><li>根据Route连接要求，是否只是建立 TCP连接或者隧道连接，在建立连接后进行协议连接（TLS连接、HTTP2.0连接）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">fun connect(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   pingIntervalMillis: Int,</span><br><span class="line">   connectionRetryEnabled: Boolean,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   &#x2F;&#x2F; 要求 protocol 必须为null , 没有连接过</span><br><span class="line">   check(protocol &#x3D;&#x3D; null) &#123; &quot;already connected&quot; &#125;</span><br><span class="line"></span><br><span class="line">   var routeException: RouteException? &#x3D; null</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 获取连接配套配置</span><br><span class="line">   val connectionSpecs &#x3D; route.address.connectionSpecs</span><br><span class="line">   &#x2F;&#x2F; 获得配置选择器</span><br><span class="line">   val connectionSpecSelector &#x3D; ConnectionSpecSelector(connectionSpecs)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果 OkHttpClient.Builder 没有配置 SSLSocketFactory 则表示协议使用明文传输（不适用HTTPS)</span><br><span class="line">   if (route.address.sslSocketFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查明文配置是否在配置列表中</span><br><span class="line">     if (ConnectionSpec.CLEARTEXT !in connectionSpecs) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;CLEARTEXT communication not enabled for client&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F; 检查平台是否支持该域名的明文传输（9.0 默认不支持Http明文传输）</span><br><span class="line">     val host &#x3D; route.address.url.host</span><br><span class="line">     if (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;CLEARTEXT communication to $host not permitted by network security policy&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果设置了SSL 则不允许 H2_PRIOR_KNOWLEDGE 协议（需要明文传输）</span><br><span class="line">     if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;H2_PRIOR_KNOWLEDGE cannot be used with HTTPS&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   while (true) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       &#x2F;&#x2F; 是否要求隧道连接</span><br><span class="line">       if (route.requiresTunnel()) &#123;</span><br><span class="line">         connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">         if (rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">           &#x2F;&#x2F; We were unable to connect the tunnel but properly closed down our resources.</span><br><span class="line">           break</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 建立Socket连接</span><br><span class="line">         connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 确定协议和TLS连接，如果为HTTP2.0 则直接建立连接</span><br><span class="line">       establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">       eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">       break</span><br><span class="line">     &#125; catch (e: IOException) &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立TCP Socket连接</span><br><span class="line"> private fun connectSocket(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   val proxy &#x3D; route.proxy</span><br><span class="line">   val address &#x3D; route.address</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果是直连或者HTTP代理，都需要建立Socket，否则直接创建proxy的Socket代理</span><br><span class="line">   val rawSocket &#x3D; when (proxy.type()) &#123;</span><br><span class="line">     Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">     else -&gt; Socket(proxy)</span><br><span class="line">   &#125;</span><br><span class="line">   this.rawSocket &#x3D; rawSocket</span><br><span class="line"></span><br><span class="line">   eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">   rawSocket.soTimeout &#x3D; readTimeout</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 调用平台创建连接Socket的方法</span><br><span class="line">     Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">   &#125; catch (e: ConnectException) &#123;</span><br><span class="line">     throw ConnectException(&quot;Failed to connect to $&#123;route.socketAddress&#125;&quot;).apply &#123;</span><br><span class="line">       initCause(e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 建立TCP连接后的流控制</span><br><span class="line">     source &#x3D; rawSocket.source().buffer()</span><br><span class="line">     sink &#x3D; rawSocket.sink().buffer()</span><br><span class="line">   &#125; catch (npe: NullPointerException) &#123;</span><br><span class="line">     if (npe.message &#x3D;&#x3D; NPE_THROW_WITH_NULL) &#123;</span><br><span class="line">       throw IOException(npe)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立TLS连接</span><br><span class="line"> private fun connectTls(connectionSpecSelector: ConnectionSpecSelector) &#123;</span><br><span class="line">   val address &#x3D; route.address</span><br><span class="line">   val sslSocketFactory &#x3D; address.sslSocketFactory</span><br><span class="line">   var success &#x3D; false</span><br><span class="line">   var sslSocket: SSLSocket? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 调用 OkHttpClient.Build.sslSocketFactory 构造 SSLSocket</span><br><span class="line">     &#x2F;&#x2F; Create the wrapper over the connected socket.</span><br><span class="line">     sslSocket &#x3D; sslSocketFactory!!.createSocket(</span><br><span class="line">         rawSocket, address.url.host, address.url.port, true &#x2F;* autoClose *&#x2F;) as SSLSocket</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 定义TLS版本和加密配套及其扩展</span><br><span class="line">     val connectionSpec &#x3D; connectionSpecSelector.configureSecureSocket(sslSocket)</span><br><span class="line">     &#x2F;&#x2F; 如果支持TLS扩展，调用平台扩展</span><br><span class="line">     if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">       Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 进行握手</span><br><span class="line">     &#x2F;&#x2F; Force handshake. This can throw!</span><br><span class="line">     sslSocket.startHandshake()</span><br><span class="line">     &#x2F;&#x2F; block for session establishment</span><br><span class="line">     val sslSocketSession &#x3D; sslSocket.session</span><br><span class="line">     val unverifiedHandshake &#x3D; sslSocketSession.handshake()</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 证书验证（OkHostnameVerifier），验证地址和目标地址ip，如果不通过则抛出</span><br><span class="line">     if (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) &#123;</span><br><span class="line">       &#x2F;&#x2F; 验证不通过则抛出异常</span><br><span class="line">       val peerCertificates &#x3D; unverifiedHandshake.peerCertificates</span><br><span class="line">       if (peerCertificates.isNotEmpty()) &#123;</span><br><span class="line">         val cert &#x3D; peerCertificates[0] as X509Certificate</span><br><span class="line">         throw SSLPeerUnverifiedException(&quot;&quot;&quot;</span><br><span class="line">             |Hostname $&#123;address.url.host&#125; not verified:</span><br><span class="line">             |    certificate: $&#123;CertificatePinner.pin(cert)&#125;</span><br><span class="line">             |    DN: $&#123;cert.subjectDN.name&#125;</span><br><span class="line">             |    subjectAltNames: $&#123;OkHostnameVerifier.allSubjectAltNames(cert)&#125;</span><br><span class="line">             &quot;&quot;&quot;.trimMargin())</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         throw SSLPeerUnverifiedException(</span><br><span class="line">             &quot;Hostname $&#123;address.url.host&#125; not verified (no certificates)&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 证书锁定器，用来抵抗CA攻击、中间人攻击</span><br><span class="line">     val certificatePinner &#x3D; address.certificatePinner!!</span><br><span class="line"></span><br><span class="line">     handshake &#x3D; Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,</span><br><span class="line">         unverifiedHandshake.localCertificates) &#123;</span><br><span class="line">       &#x2F;&#x2F; certificateChainCleaner 用来验证证书链，并且排除一些和TLS握手无关的证书，返回可用的CA证书链</span><br><span class="line">       certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,</span><br><span class="line">           address.url.host)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 验证该host的证书支持的 hash 类型</span><br><span class="line">     certificatePinner.check(address.url.host) &#123;</span><br><span class="line">       handshake!!.peerCertificates.map &#123; it as X509Certificate &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; ALPN 扩展协议处理</span><br><span class="line">     val maybeProtocol &#x3D; if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">       Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       null</span><br><span class="line">     &#125;</span><br><span class="line">     socket &#x3D; sslSocket</span><br><span class="line">     source &#x3D; sslSocket.source().buffer()</span><br><span class="line">     sink &#x3D; sslSocket.sink().buffer()</span><br><span class="line">     protocol &#x3D; if (maybeProtocol !&#x3D; null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1</span><br><span class="line">     success &#x3D; true</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     &#x2F;&#x2F; 握手后操作</span><br><span class="line">     if (sslSocket !&#x3D; null) &#123;</span><br><span class="line">       Platform.get().afterHandshake(sslSocket)</span><br><span class="line">     &#125;</span><br><span class="line">     if (!success) &#123;</span><br><span class="line">       sslSocket?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立隧道连接</span><br><span class="line"> private fun connectTunnel(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   &#x2F;&#x2F; 封装请求头</span><br><span class="line">   var tunnelRequest: Request &#x3D; createTunnelRequest()</span><br><span class="line">   val url &#x3D; tunnelRequest.url</span><br><span class="line">   &#x2F;&#x2F; 做多尝试21次建立</span><br><span class="line">   for (i in 0 until MAX_TUNNEL_ATTEMPTS) &#123;</span><br><span class="line">     &#x2F;&#x2F; 先建立TCP连接</span><br><span class="line">     connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 创建隧道连接</span><br><span class="line">     tunnelRequest &#x3D; createTunnel(readTimeout, writeTimeout, tunnelRequest, url)</span><br><span class="line">         ?: break </span><br><span class="line"></span><br><span class="line">     rawSocket?.closeQuietly()</span><br><span class="line">     rawSocket &#x3D; null</span><br><span class="line">     sink &#x3D; null</span><br><span class="line">     source &#x3D; null</span><br><span class="line">     eventListener.connectEnd(call, route.socketAddress, route.proxy, null)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="回归findConnection"><a href="#回归findConnection" class="headerlink" title="回归findConnection"></a>回归findConnection</h3><p>回归到 <code>ConnectInterceptor.intercept</code> 方法，在该方法中，主要对调用 <code>RealCall.newExchange</code> 获取 <code>Exchange</code> 代理对象，通过 <code>Exchange</code> 可以建立的连接上进行数据交互。</p><p>在 <code>newExchange</code> 中主要经历几个流程：</p><p><code>RealCall.newExchange（返回 Exchange） -&gt; ExchangeFinder.find (返回 ExchangeCodec) -&gt; ExchangeFinder.findHealthyConnection （返回 RealConnection ）-&gt; ExchangeFinder.findConnection （返回 RealConnection）</code></p><p>在 findConnection 中获得主要负责连接的代理对象 <code>RealConnection</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">private fun findConnection(</span><br><span class="line">  connectTimeout: Int,</span><br><span class="line">  readTimeout: Int,</span><br><span class="line">  writeTimeout: Int,</span><br><span class="line">  pingIntervalMillis: Int,</span><br><span class="line">  connectionRetryEnabled: Boolean</span><br><span class="line">): RealConnection &#123;</span><br><span class="line">  var foundPooledConnection &#x3D; false</span><br><span class="line">  var result: RealConnection? &#x3D; null</span><br><span class="line">  var selectedRoute: Route? &#x3D; null</span><br><span class="line">  var releasedConnection: RealConnection?</span><br><span class="line">  val toClose: Socket?</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用被取消则直接退出</span><br><span class="line">    if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    hasStreamFailure &#x3D; false &#x2F;&#x2F; This is a fresh attempt.</span><br><span class="line"></span><br><span class="line">    releasedConnection &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果call.connection的连接不允许创建新的传输（noNewExcahnges)，则返回当前连接的Socket，以用于释放连接</span><br><span class="line">    toClose &#x3D; if (call.connection !&#x3D; null &amp;&amp; call.connection!!.noNewExchanges) &#123;</span><br><span class="line">      call.releaseConnectionNoEvents()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果call 以及存在 connection 则复用结果</span><br><span class="line">    if (call.connection !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 使用以及存在连接代替</span><br><span class="line">      &#x2F;&#x2F; We had an already-allocated connection and it&#39;s good.</span><br><span class="line">      result &#x3D; call.connection</span><br><span class="line">      releasedConnection &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果为null ，代表当前call 不存在使用中的连接，从之前的连接池中查询</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断连接池中是否存在符合条件的连接（已经被回收）</span><br><span class="line">      if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; call.connection</span><br><span class="line">      &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果未找到合适复用连接 则查看是否有需要优先选择的路由路线</span><br><span class="line">        selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">        nextRouteToTry &#x3D; null</span><br><span class="line">      &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果没有，则直接重新计算路由</span><br><span class="line">        selectedRoute &#x3D; call.connection!!.route()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">  if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">    eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">  &#125;</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在之前中已经找到已经可使用的连接</span><br><span class="line">  if (result !&#x3D; null) &#123;</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var newRouteSelection &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果还没有Route选定并且 RouteSelection 还未初始化，则进行初始化，以备下面使用</span><br><span class="line">  if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">    newRouteSelection &#x3D; true</span><br><span class="line">    routeSelection &#x3D; routeSelector.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查调用是否被取消</span><br><span class="line">    if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果新建 RouteSelection 则进行重新Route的获取</span><br><span class="line">    if (newRouteSelection) &#123;</span><br><span class="line">      routes &#x3D; routeSelection!!.routes</span><br><span class="line">      &#x2F;&#x2F; 获取连接池中适合call所使用的连接，如果返回true在表示已有合适的连接和call绑定（call.acquireConnectionNoEvents）</span><br><span class="line">      if (connectionPool.callAcquirePooledConnection(address, call, routes, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; call.connection &#x2F;&#x2F; 获取当前所获得的复用的连接</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没在连接池中获得复用连接，则从路由节点中获得新的路由点（尝试在接下来中进行连接）</span><br><span class="line">    if (!foundPooledConnection) &#123;</span><br><span class="line">      if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果之前还没对Route路线进行选择，则进行路由选择</span><br><span class="line">        selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建连接</span><br><span class="line">      result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">      connectingConnection &#x3D; result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果在连接池中找到则返回结果</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 开执TCP TLS 连接</span><br><span class="line">  result!!.connect(</span><br><span class="line">      connectTimeout,</span><br><span class="line">      readTimeout,</span><br><span class="line">      writeTimeout,</span><br><span class="line">      pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled,</span><br><span class="line">      call,</span><br><span class="line">      eventListener</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 连接成功后，如果routeDatabase列表中（失败节点）存在该Route则从黑名单中移除</span><br><span class="line">  call.client.routeDatabase.connected(result!!.route())</span><br><span class="line"></span><br><span class="line">  var socket: Socket? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    connectingConnection &#x3D; null</span><br><span class="line">    if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123;</span><br><span class="line">      result!!.noNewExchanges &#x3D; true</span><br><span class="line">      socket &#x3D; result!!.socket()</span><br><span class="line">      result &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">      nextRouteToTry &#x3D; selectedRoute</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      connectionPool.put(result!!)</span><br><span class="line">      call.acquireConnectionNoEvents(result!!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  return result!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在流程中 findConnection 是比较重要的一个流程。这里实现了OkHttp 连接复用流程。对于连接成功后的连接 通过 <code>RealConnectionPool.put</code> 进行缓存。</p><h4 id="ConnectionPool-连接复用"><a href="#ConnectionPool-连接复用" class="headerlink" title="ConnectionPool 连接复用"></a>ConnectionPool 连接复用</h4><p>ConnectionPool 在整个连接过程中，记录着连接的变化</p><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p><code>CallServerInterceptor</code> 负责在数据传输上的处理，包括在HTTP上传递头部和Body信息（应用层数据传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"> override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val exchange &#x3D; realChain.exchange()</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    val requestBody &#x3D; request.body</span><br><span class="line">    val sentRequestMillis &#x3D; System.currentTimeMillis()</span><br><span class="line">    &#x2F;&#x2F; 向 Exchange 写入头部信息</span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    var invokeStartEvent &#x3D; true</span><br><span class="line">    var responseBuilder: Response.Builder? &#x3D; null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组装RequestBody，如果该次事务不需要则 exchange.noRequestBody()</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 100-continue 状况，表示需要多次传输</span><br><span class="line">      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行请求</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; true)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否支持二进制body（HTTP2.0）</span><br><span class="line">        if (requestBody.isDuplex()) &#123;</span><br><span class="line">          &#x2F;&#x2F; 创建二进制RequestBody</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, true).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 直接发送body内容</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, false).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        &#x2F;&#x2F; 不支持多路，关闭事务</span><br><span class="line">        if (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行不带body的请求</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 到这里如果不支持二进制body HTTP2.0 则完成该次请求</span><br><span class="line">    if (requestBody &#x3D;&#x3D; null || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取请求结果</span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    var code &#x3D; response.code</span><br><span class="line">    if (code &#x3D;&#x3D; 100) &#123;</span><br><span class="line">      &#x2F;&#x2F; Server sent a 100-continue even though we did not request one. Try again to read the actual</span><br><span class="line">      &#x2F;&#x2F; response status.</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response &#x3D; responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code &#x3D; response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response &#x3D; if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">      &#x2F;&#x2F; Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase &#x3D; true) ||</span><br><span class="line">        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    if ((code &#x3D;&#x3D; 204 || code &#x3D;&#x3D; 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123;</span><br><span class="line">      throw ProtocolException(</span><br><span class="line">          &quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、主要构件&quot;&gt;&lt;a href=&quot;#一、主要构件&quot; class=&quot;headerlink&quot; title=&quot;一、主要构件&quot;&gt;&lt;/a&gt;一、主要构件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;OkhttpClient 请求总引擎代理&lt;/li&gt;
&lt;li&gt;Request 请求体信息，通过Re
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="OkHttp" scheme="http://yoursite.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack-Lifecycle</title>
    <link href="http://yoursite.com/2019/02/14/Jetpack-Lifecycle/"/>
    <id>http://yoursite.com/2019/02/14/Jetpack-Lifecycle/</id>
    <published>2019-02-14T15:32:35.000Z</published>
    <updated>2020-04-14T15:35:05.412Z</updated>
    
    <content type="html"><![CDATA[<p>Lifecycle 是 Jetpack 的一套生命周期监控框架，目的是用于对进程、 Activity 和 Fragment 生命周期感知。</p><p>方便开发者在一些开发细节上对生命周期的感知强化，比如防止内存泄露、内存控制、周期性任务等情况，比较出名的方案是 Glide 对于<code>Request</code> 自实现的一套管理方案，目前有了这套官方的支持，就不在需要处理注册通知、以及观察者销毁等事宜。</p><h1 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h1><p>基于androidX项目的Gradle依赖配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def lifecycle_version &#x3D; &quot;2.2.0&quot;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ktx 包是对 androidx.lifecycle:lifecycle-runtime:2.2.0  包kotlin方面的增强，如果不需要kotlin 可以换回该包</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果使用的是java8 ，可以用该扩展包进行接口监听</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    kapt &quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lifecycle-extensions 依赖已经在2.2.0过期不再使用</code></p><ul><li>lifecycle-runtime-ktx 依赖关系</li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27283/WEBRESOURCE4b53087605cb1000c78ac8d8d259984e"  alt="image.png"></p><p>lifecycle-runtime-ktx 的 maven 依赖关系上，编译时已经包含：</p><ul><li>androidx.lifecycle:lifecycle-runtime:2.2.0</li><li>org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0 (协程)</li></ul><h1 id="二、基本组成"><a href="#二、基本组成" class="headerlink" title="二、基本组成"></a>二、基本组成</h1><p><code>Lifecycle</code> 主要包括几个主要结构：</p><ul><li><p>LifecycleOwner <code>生命周期被观察者，主要被 AppCompatActivity、Fragment、LifecycleService 等需要被监控的目标类上实现，目前在androidX组件、aac 组件里面基本默认实现</code></p></li><li><p>LifecycleObserver <code>观察者接口，默认空实现，根据所提供的不同生命周期进行不同的接口（目前是Fragment 和 Activity），比如 FullLifecycleObserver 提供了Activity的生命周期监控，目前android主要提供两种观察者 LifecycleEventObserver 和 FullLifecycleObserver,</code></p></li><li><p>Lifecycle <code>提供观察者对被观察者的注册、注销、状态反馈，由 LifecycleOwner 提供</code></p></li><li><p>LifecycleRegistry <code>Lifecycle实现的子类，是观察者注册器，对LifecycleObserver进行注册、注销相关动作</code></p></li></ul><h1 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val presenter by lazy &#123;</span><br><span class="line">        MainPresenter()</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(presenter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainPresenter: DefaultLifecycleObserver &#123;&#125;</span><br></pre></td></tr></table></figure><p>androidX 依赖的 <code>AppCompatActivity</code>、<code>Fragment</code> 默认都实现了 <code>LifecycleOwner</code> 接口，通过<code>getLifecycle</code>获取注册器进行注册。</p><p>对于观察者，还可以通过注解形式实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MainPresenter: LifecycleObserver &#123;</span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    fun onCreate() &#123;</span><br><span class="line">        Log.e(&quot;bevis&quot;, &quot;onCreate&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    fun onResume() &#123;</span><br><span class="line">        Log.e(&quot;bevis&quot;, &quot;onResume&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、原理初析"><a href="#四、原理初析" class="headerlink" title="四、原理初析"></a>四、原理初析</h1><p>Lifecycle 框架是个典型的观察者框架，只是这种模式被官方默认支持。</p><h2 id="注册与包装-Observer"><a href="#注册与包装-Observer" class="headerlink" title="注册与包装 Observer"></a>注册与包装 Observer</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27659/WEBRESOURCE448a5de37537f1150ef966f3527a1412"  alt="image.png"></p><p>整个流程主要集中在 <code>addObserver</code> 方法中，这边具体分析下这流程：</p><ul><li>将观察者构造为 ObserverWithState，并初始化状态（INITIALIZED 或 DESTROYED）</li><li>根据观察者的实现，生成不同的适配器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FullLifecycleObserverAdapter 适用于 FullLifecycleObserver</span><br><span class="line"></span><br><span class="line">SingleGeneratedAdapterObserver</span><br><span class="line"></span><br><span class="line">CompositeGeneratedAdaptersObserver</span><br><span class="line"></span><br><span class="line">ReflectiveGenericLifecycleObserver</span><br></pre></td></tr></table></figure></li><li>更新新添加观察者的状态，直到和被观察者状态保持 一致。<ul><li>如果添加观察者时，它的状态滞后于被观察者，则会将所有未经过的状态执行一遍，比如当前Activity 状态为 onResume，则观察者会将 onCreate -&gt; onStart -&gt; onResume 都执行一遍。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">public class LifecycleRegistry extends Lifecycle &#123;</span><br><span class="line">    ...</span><br><span class="line">    public void addObserver(@NonNull LifecycleObserver observer) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查当前被观察者是否处于 DESTROYED ，如果是先初始化值为 </span><br><span class="line">        &#x2F;&#x2F; DESTROYED 否则 INITIALIZED</span><br><span class="line">        State initialState &#x3D; mState &#x3D;&#x3D; DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">        &#x2F;&#x2F; 初始化观察者包装类，该包装类有观察者对象和当前观察者感知到的状态 &#x2F;&#x2F; 值。</span><br><span class="line">        ObserverWithState statefulObserver &#x3D; new ObserverWithState(observer, initialState);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 缓存到索引中</span><br><span class="line">        ObserverWithState previous &#x3D; mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果之前已经添加过则不重新进行后续的初始化</span><br><span class="line">        if (previous !&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 这是个弱引用，如果被观察者销毁了，则会返回null，那么久不进行</span><br><span class="line">        &#x2F;&#x2F; 后续的流程</span><br><span class="line">        LifecycleOwner lifecycleOwner &#x3D; mLifecycleOwner.get();</span><br><span class="line">        if (lifecycleOwner &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; it is null we should be destroyed. Fallback quickly</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果当前其他的观察者处于状态更新中（sync()执行中）或者</span><br><span class="line">        &#x2F;&#x2F; 当前正在添加的观察者（添加事务还没执行完）不为空，则在完成当前对象添加后重新更新状态(sync())</span><br><span class="line">        boolean isReentrance &#x3D; mAddingObserverCounter !&#x3D; 0 || mHandlingEvent;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获得当前实际被观察者状态</span><br><span class="line">        State targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 标记正在执行添加事务流程的标记位</span><br><span class="line">        mAddingObserverCounter++;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果观察者状态比目标状态低，则将状态一级一级递增，并在递增过程中</span><br><span class="line">        &#x2F;&#x2F; 通知新添加的观察者状态变更</span><br><span class="line">        while ((statefulObserver.mState.compareTo(targetState) &lt; 0</span><br><span class="line">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">            pushParentState(statefulObserver.mState);</span><br><span class="line">            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">            &#x2F;&#x2F; 为了防止更新过程中被观察者状态已经变更，则重新更新目标状态</span><br><span class="line">            targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 更新所有被观察者状态</span><br><span class="line">        if (!isReentrance) &#123;</span><br><span class="line">            &#x2F;&#x2F; we do sync only on the top level.</span><br><span class="line">            sync();</span><br><span class="line">        &#125;</span><br><span class="line">        mAddingObserverCounter--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    private State calculateTargetState(LifecycleObserver observer) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous &#x3D; mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">        State siblingState &#x3D; previous !&#x3D; null ? previous.getValue().mState : null;</span><br><span class="line">        State parentState &#x3D; !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)</span><br><span class="line">                : null;</span><br><span class="line">        return min(min(mState, siblingState), parentState);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    static class ObserverWithState &#123;</span><br><span class="line">        State mState;</span><br><span class="line">        LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">        ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">            mLifecycleObserver &#x3D; Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">            mState &#x3D; initialState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void dispatchEvent(LifecycleOwner owner, Event event) &#123;</span><br><span class="line">            State newState &#x3D; getStateAfter(event);</span><br><span class="line">            mState &#x3D; min(mState, newState);</span><br><span class="line">            mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">            mState &#x3D; newState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">public class Lifecycling &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 该方法是根据观察者生成对应的包装装饰器   </span><br><span class="line">    static LifecycleEventObserver lifecycleEventObserver(Object object) &#123;</span><br><span class="line">        boolean isLifecycleEventObserver &#x3D; object instanceof LifecycleEventObserver;</span><br><span class="line">        boolean isFullLifecycleObserver &#x3D; object instanceof FullLifecycleObserver;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; FullLifecycleObserver 及其子类都是用  </span><br><span class="line">        &#x2F;&#x2F; FullLifecycleObserverAdapter 包装</span><br><span class="line">        if (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123;</span><br><span class="line">            return new FullLifecycleObserverAdapter((FullLifecycleObserver) object,</span><br><span class="line">                    (LifecycleEventObserver) object);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isFullLifecycleObserver) &#123;</span><br><span class="line">            return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; LifecycleEventObserver 及其子类</span><br><span class="line">        if (isLifecycleEventObserver) &#123;</span><br><span class="line">            return (LifecycleEventObserver) object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对于不是规范性的观察者，比如 </span><br><span class="line">        &#x2F;&#x2F; OnLifecycleEvent注解、APT生成对象或者 直接实现于 </span><br><span class="line">        &#x2F;&#x2F; LifecycleObserver的观察者</span><br><span class="line">        final Class&lt;?&gt; klass &#x3D; object.getClass();</span><br><span class="line">        int type &#x3D; getObserverConstructorType(klass);</span><br><span class="line">        &#x2F;&#x2F; 返回构造的类型</span><br><span class="line">        if (type &#x3D;&#x3D; GENERATED_CALLBACK) &#123;</span><br><span class="line">            List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors &#x3D;</span><br><span class="line">                    sClassToAdapters.get(klass);</span><br><span class="line">            if (constructors.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                GeneratedAdapter generatedAdapter &#x3D; createGeneratedAdapter(</span><br><span class="line">                        constructors.get(0), object);</span><br><span class="line">                return new SingleGeneratedAdapterObserver(generatedAdapter);</span><br><span class="line">            &#125;</span><br><span class="line">            GeneratedAdapter[] adapters &#x3D; new GeneratedAdapter[constructors.size()];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">                adapters[i] &#x3D; createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">            &#125;</span><br><span class="line">            return new CompositeGeneratedAdaptersObserver(adapters);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ReflectiveGenericLifecycleObserver(object);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    private static int getObserverConstructorType(Class&lt;?&gt; klass) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先从缓存里面获取CallbackType，没有在进行解析</span><br><span class="line">        Integer callbackCache &#x3D; sCallbackCache.get(klass);</span><br><span class="line">        if (callbackCache !&#x3D; null) &#123;</span><br><span class="line">            return callbackCache;</span><br><span class="line">        &#125;</span><br><span class="line">        int type &#x3D; resolveObserverCallbackType(klass);</span><br><span class="line">        sCallbackCache.put(klass, type);</span><br><span class="line">        return type;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 解析目标类对观察者类</span><br><span class="line">    private static int resolveObserverCallbackType(Class&lt;?&gt; klass) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否是反射类型</span><br><span class="line">        if (klass.getCanonicalName() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return REFLECTIVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果是由APT </span><br><span class="line">        &#x2F;&#x2F; &quot;androidx.lifecycle:lifecycle-compiler:2.2.0&quot;生成的xxx_Lifecycle</span><br><span class="line">        &#x2F;&#x2F; Adapter的类，则根据规范生成构造器信息，并存到</span><br><span class="line">        &#x2F;&#x2F; sClassToAdapters 备用</span><br><span class="line">        Constructor&lt;? extends GeneratedAdapter&gt; constructor &#x3D; generatedConstructor(klass);</span><br><span class="line">        if (constructor !&#x3D; null) &#123;</span><br><span class="line">            sClassToAdapters.put(klass, Collections</span><br><span class="line">                    .&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt;singletonList(constructor));</span><br><span class="line">            return GENERATED_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 检测类中是否包含有 OnLifecycleEvent 注解标记的方法，如果有则</span><br><span class="line">        &#x2F;&#x2F; 将给类callback type 标记为反射类型</span><br><span class="line">        boolean hasLifecycleMethods &#x3D; ClassesInfoCache.sInstance.hasLifecycleMethods(klass);</span><br><span class="line">        if (hasLifecycleMethods) &#123;</span><br><span class="line">            return REFLECTIVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; superclass &#x3D; klass.getSuperclass();</span><br><span class="line">        List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; adapterConstructors &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 判断是否为继承自 LifecycleObserver 的子类</span><br><span class="line">        if (isLifecycleParent(superclass)) &#123;</span><br><span class="line">            if (getObserverConstructorType(superclass) &#x3D;&#x3D; REFLECTIVE_CALLBACK) &#123;</span><br><span class="line">                return REFLECTIVE_CALLBACK;</span><br><span class="line">            &#125;</span><br><span class="line">            adapterConstructors &#x3D; new ArrayList&lt;&gt;(sClassToAdapters.get(superclass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断是否实现自 LifecycleObserver </span><br><span class="line">        &#x2F;&#x2F; 的子类，如果是判断当前类的构造方式</span><br><span class="line">        for (Class&lt;?&gt; intrface : klass.getInterfaces()) &#123;</span><br><span class="line">            if (!isLifecycleParent(intrface)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (getObserverConstructorType(intrface) &#x3D;&#x3D; REFLECTIVE_CALLBACK) &#123;</span><br><span class="line">                return REFLECTIVE_CALLBACK;</span><br><span class="line">            &#125;</span><br><span class="line">            if (adapterConstructors &#x3D;&#x3D; null) &#123;</span><br><span class="line">                adapterConstructors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            adapterConstructors.addAll(sClassToAdapters.get(intrface));</span><br><span class="line">        &#125;</span><br><span class="line">        if (adapterConstructors !&#x3D; null) &#123;</span><br><span class="line">            sClassToAdapters.put(klass, adapterConstructors);</span><br><span class="line">            return GENERATED_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return REFLECTIVE_CALLBACK;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、相关传送门"><a href="#三、相关传送门" class="headerlink" title="三、相关传送门"></a>三、相关传送门</h1><p><a href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev" target="_blank" rel="noopener">AndroidX Google Git 项目地址</a></p><p><a href="https://developer.android.google.cn/jetpack/androidx/releases/lifecycle?hl=it" target="_blank" rel="noopener">Android Life 版本更新日志</a></p><p><a href="https://developer.android.google.cn/jetpack/docs/getting-started?hl=zh_cn" target="_blank" rel="noopener">Jetpack Google文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lifecycle 是 Jetpack 的一套生命周期监控框架，目的是用于对进程、 Activity 和 Fragment 生命周期感知。&lt;/p&gt;
&lt;p&gt;方便开发者在一些开发细节上对生命周期的感知强化，比如防止内存泄露、内存控制、周期性任务等情况，比较出名的方案是 Glid
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android源码编译和阅读</title>
    <link href="http://yoursite.com/2019/01/13/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/01/13/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%98%85%E8%AF%BB/</id>
    <published>2019-01-13T14:05:39.000Z</published>
    <updated>2020-04-13T14:07:30.131Z</updated>
    
    <content type="html"><![CDATA[<p>这几天花了点时间将Android源码 repo 下来，准备巩固下Android全体流程，简单记录下调试环境监理的过程。</p><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><p>在下载的源码项目下，直接可以执行 </p><p><code>source build/envsetup.sh</code></p><p>进行安装前的环境初始化。</p><p>这里注意，如果尝试在非 bash 环境初始化，会抛出一个警告。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26698/WEBRESOURCEffb85d0ab1a91830bb5209f1690c0c9e"  alt="image.png"></p><p>尽管不是异常，不过还是安全起见，切换到bash下去执行。</p><h1 id="编译类型"><a href="#编译类型" class="headerlink" title="编译类型"></a>编译类型</h1><p>执行 <code>lunch</code> 启动目录，Android 提供了几种编译选项：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26716/WEBRESOURCEef95c669a446ff30005d5500da96405f"  alt="image.png"></p><p>根据名字规则 <code>${BUILD}_${BUILD_TYPE}</code>，例如 <code>aosp_arm-eng</code>，BUILD = aosp_arm 而 BUILD_TYPE = eng</p><p>这里主要关注 BUILD_TYPE ：</p><ul><li>eng <code>有额外调试工具配置</code></li><li>user <code>适用于生产环境的版本，对系统的权限有一定约束</code></li><li>userdebug <code>和 user 类似，但是权限上处于root，并且可以进行调试</code></li></ul><p>这里因为我是电脑模拟器执行，因此使用 <code>x86</code> 的aosp版本就行。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26741/WEBRESOURCEb43ac574907067624d128a7487384e9d"  alt="image.png"></p><h1 id="编译idegen调试模块与问题"><a href="#编译idegen调试模块与问题" class="headerlink" title="编译idegen调试模块与问题"></a>编译idegen调试模块与问题</h1><p>开始执行项目编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make idegen</span><br></pre></td></tr></table></figure><p>直到出现</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26789/WEBRESOURCE9d1213f87038081b289b4aaff8bcaf5b"  alt="image.png"></p><p>成功标记即可。</p><p><code>make idegen</code> 生成 <code>idegen.jar</code> 后，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo development&#x2F;tools&#x2F;idegen&#x2F;idegen.sh</span><br></pre></td></tr></table></figure><p>开始漫长的执行等待，直到通知</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26812/WEBRESOURCEf42faa5a9598bc80d99e344d79cb1574"  alt="image.png"></p><p>完成以上所有动作后，会在源码根目录生成三个文件：</p><ul><li><p>android.iml (记录项目所包含的module、依赖关系、SDK版本等等，类似一个XML文件)</p></li><li><p>android.ipr (工程的具体配置，代码以及依赖的lib等信息，使用Android Studio 直接导入该文件)</p></li><li><p>android.iws (主要包含一些个人的配置信息，也有可能在执行上述操作后没有生成，这个没关系，在打开过一次项目之后就会自动生成了)</p></li></ul><p>调整文件读取权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 android.iml</span><br><span class="line">sudo chmod 777 android.ipr</span><br></pre></td></tr></table></figure><p>完成后使用<code>Android Stuido</code> 导入已有项目导入 <code>android.ipr</code> ，由于项目非常大，这里等待会久一点，完成后就可以放飞自我了。</p><h2 id="过程中的问题"><a href="#过程中的问题" class="headerlink" title="过程中的问题"></a>过程中的问题</h2><p>下面记录几个在编译过程中出现了几个问题的解决方法，仅代表我编译环境问题，不同的编译环境可能会产生不同的问题。</p><h3 id="Mac-OS-分区大小写问题"><a href="#Mac-OS-分区大小写问题" class="headerlink" title="Mac OS 分区大小写问题"></a>Mac OS 分区大小写问题</h3><p>由于我当前的 Mac 分区是不区分大小写的分区模式，因此抛出了异常。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26749/WEBRESOURCE4f40f94cceff916960e2cd8b994eb2a7"  alt="image.png"></p><p>这里只需要重新对盘继续分割，并将格式化类型设置为对大小写敏感即可。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26747/WEBRESOURCEf38106d537e15f03c5d5c21d1ba39526"  alt="image.png"></p><p>分区完成后，迁移代码到这里面编译即可</p><h3 id="Mac-SDK-支持问题"><a href="#Mac-SDK-支持问题" class="headerlink" title="Mac SDK 支持问题"></a>Mac SDK 支持问题</h3><p>由于我Mac版本是比较高的，而Android构建支持的版本较小[10.10、10.11、10.12]。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26771/WEBRESOURCE2c2301660cc3aae55c712cb96a396221"  alt="image.png"></p><p>解决方法是去下载以前老的Mac sdk版本，下载可以到<a href="https://github.com/phracker/MacOSX-SDKs" target="_blank" rel="noopener">这里</a>，下载完成后解压到 <code>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</code> 目录下，重新执行编译即可。</p><h3 id="Android-Studio-导入太慢"><a href="#Android-Studio-导入太慢" class="headerlink" title="Android Studio 导入太慢"></a>Android Studio 导入太慢</h3><p>由于项目非常大，因此这里会非常非常久，如果不希望这么慢，可以参考通过修改<code>android.iml</code>文件，在里面添加 <code>&lt;excludeFolder&gt;</code> 配置，剔除不需要同步的模块，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;excludeFloder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;项目名&quot;&gt;</span><br></pre></td></tr></table></figure><p>比如 不需要 <code>build</code> 下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;build&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h1 id="Android-Studio-导入源码"><a href="#Android-Studio-导入源码" class="headerlink" title="Android Studio 导入源码"></a>Android Studio 导入源码</h1><p>导入源码成功后，需要对Android Studio 进行一些配置调整。</p><p>因为我只对项目里面 <code>framework</code> 项目感兴趣，我这个以这个为例子。</p><h2 id="设置目标SDK版本"><a href="#设置目标SDK版本" class="headerlink" title="设置目标SDK版本"></a>设置目标SDK版本</h2><ol><li>进入项目设置 <code>Project Structure</code></li></ol><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26867/WEBRESOURCE22d80acfc60c2b9c3011dca3f08bce5d"  alt="image.png"></p><ol start="2"><li>选择 <code>Project</code> -&gt; 设置 SDK，因为我下载的项目是 Android 8.1 的源码，因此我这使用 API 27<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26876/WEBRESOURCE361fac66cb91d781c30f391eada394df"  alt="image.png"></li></ol><p>如果在这里面没有找到自己想要的 Android SDK 版本，可以通过 <code>Android Studio 菜单</code> -&gt; <code>Preferences</code> -&gt; <code>Android SDK</code></p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26884/WEBRESOURCE574b9031dfd54f14c9cd0e88033feb29"  alt="image.png"></p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26886/WEBRESOURCE4c73a68f7e616b2400509c8b0aa12bfd"  alt="image.png"></p><h2 id="设置项目范围和依赖"><a href="#设置项目范围和依赖" class="headerlink" title="设置项目范围和依赖"></a>设置项目范围和依赖</h2><ol><li>在之前的 <code>Project Structure</code> 下，选择<code>Modules</code> -&gt; <code>android</code> -&gt; <code>Sources</code><br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26872/WEBRESOURCEa2ec2acb4337f19ad85c194b5e739ee8"  alt="image.png"></li></ol><p>在 <code>Sources</code> 中罗列了所有的项目，对于加入管理的项目为 蓝色，被剔除的显示为黄色，具体可以参照 Mark as 的样式, 这里在不关心的项目上，<code>右键 -&gt; 菜单 -&gt; Excluded</code>，剔除对该项目进行管理。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26908/WEBRESOURCEe353f52b530a1d5bf8a85887e0284eac"  alt="image.png"></p><ol start="2"><li>切换到 <code>Dependencies</code> 下，移除其他依赖，仅保留自己需要的依赖。</li></ol><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26928/WEBRESOURCEededb7e6d6243cf0c025c9ff08d4d943"  alt="image.png"></p><p>这里因为要调试 <code>frameworks</code> 所以将 <code>Android SDK</code>、<code>frameworks</code>、<code>external</code> 加入依赖。</p><h2 id="添加SDK支持"><a href="#添加SDK支持" class="headerlink" title="添加SDK支持"></a>添加SDK支持</h2><p>进入 <code>SDKs</code> 项目，添加好所需要的 JDK 和 Android SDK 对应的编译版本。<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26947/WEBRESOURCEecc4e70e0ee03b65c5a77ed0ed9a0ab5"  alt="image.png"></p><p>完成以上动作后，在<code>framework</code>项目下的所有内容不在显示为红色未识别的标记</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26958/WEBRESOURCEba6557de16f22b621f1b79c08da9c2de"  alt="image.png"></p><h1 id="编译模拟器"><a href="#编译模拟器" class="headerlink" title="编译模拟器"></a>编译模拟器</h1><p>IDE 自带的模拟不具备编译的条件，我们需要重新自己编译一个。</p><p>根据之前 <code>编译idegen调试模块</code> ，为了方便编译，我这边选择 <code>aosp_x86_64_eng</code>。</p><p>之后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j6 # -jx x指的是参与编译的cpu核心数</span><br></pre></td></tr></table></figure><p>完成编译后可以执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator</span><br></pre></td></tr></table></figure><p>执行模拟器</p><h1 id="调试连接"><a href="#调试连接" class="headerlink" title="调试连接"></a>调试连接</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天花了点时间将Android源码 repo 下来，准备巩固下Android全体流程，简单记录下调试环境监理的过程。&lt;/p&gt;
&lt;h1 id=&quot;环境部署&quot;&gt;&lt;a href=&quot;#环境部署&quot; class=&quot;headerlink&quot; title=&quot;环境部署&quot;&gt;&lt;/a&gt;环境部署&lt;/h
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>BuildVariants认识</title>
    <link href="http://yoursite.com/2018/06/16/BuildVariants%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2018/06/16/BuildVariants%E8%AE%A4%E8%AF%86/</id>
    <published>2018-06-16T12:45:22.000Z</published>
    <updated>2020-04-10T12:47:45.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>构建变体(Build Variants)有两部分内容构成 :</p><p><code>buildTypes</code>（构建类型） + <code>productFlavors</code>（产品风味）</p><p>通过 <code>android { }</code> 配置变量进行部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    defaultConfig &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        flavorDimensions &quot;api&quot;,&quot;flavor&quot;</span><br><span class="line">        flavor1 &#123;</span><br><span class="line">            dimension &quot;flavor&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flavor2 &#123;</span><br><span class="line">            dimension &quot;flavor&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        api1 &#123;</span><br><span class="line">            dimension &quot;api&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        api2 &#123;</span><br><span class="line">            dimension &quot;api&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h2><p>在一般情况下，项目创建时，项目默认创建了两种构建类型 <code>debug</code> 和 <code>release</code>。</p><p><code>debug</code>是在项目调试阶段的构建类型，而<code>release</code>则是面向发布。</p><p>这两个构建类型方便开发者对两种不同环境进行不同的构建配置。</p><p>比如签名信息、so支持类型、debug信息等。</p><h3 id="buildTypes-DSL"><a href="#buildTypes-DSL" class="headerlink" title="buildTypes DSL"></a>buildTypes DSL</h3><table><thead><tr><th>属性/方法</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>applicationIdSuffix</td><td>为计算后的 applicationId 添加该属性指定的后缀</td><td></td></tr><tr><td>consumerProguardFiles</td><td>将混淆规则文件添加到构建好的AAR中</td><td></td></tr><tr><td>crunchPngs</td><td>是否压缩PNG文件</td><td></td></tr><tr><td>debuggable</td><td>是否生成一个可调试的APk文件</td><td></td></tr><tr><td>embedMicroApp</td><td></td><td></td></tr><tr><td>javaCompileOptions</td><td>可以添加Java编译参数</td><td></td></tr><tr><td>jniDebuggable</td><td>是否生成一个可调试Native的APK文件</td><td></td></tr><tr><td>manifestPlaceholders</td><td>manifest文件占位符配置</td><td></td></tr><tr><td>matchingFallbacks</td><td>指定构建匹配失败时降级的构建类型</td><td></td></tr><tr><td>minifyEnabled</td><td>是否移除无用的代码</td><td></td></tr><tr><td>multiDexEnabled</td><td>Multi-Dex 是否支持</td><td></td></tr><tr><td>multiDexKeepFile</td><td>指定在需要主Dex File 存在的内容的声名文件</td><td></td></tr><tr><td>multiDexKeepProguard</td><td>指定一个文件，用于在编译时对主Dex classes 的额外混淆规则</td><td></td></tr><tr><td>name</td><td>当前构建类型的名字</td><td></td></tr><tr><td>postprocessing</td><td></td><td></td></tr><tr><td>proguardFiles</td><td>指定混淆规则文件</td><td></td></tr><tr><td>pseudoLocalesEnabled</td><td>是否生成仿冒资源，通过 resValue 生成</td><td></td></tr><tr><td>renderscriptDebuggable</td><td>生成一个用于调试 RenderScript 代码的apk</td><td></td></tr><tr><td>renderscriptOptimLevel</td><td>指定 RenderScript的编译优化等级</td><td></td></tr><tr><td>shrinkResources</td><td>是否优化未使用的资源</td><td></td></tr><tr><td>signingConfig</td><td>签名定义</td><td></td></tr><tr><td>testCoverageEnabled</td><td>是否启动覆盖测试</td><td></td></tr><tr><td>useProguard</td><td>是否总是启动代码混淆和资源优化</td><td></td></tr><tr><td>versionNameSuffix</td><td>添加版本后缀</td><td></td></tr><tr><td>zipAlignEnabled</td><td>是否启动zip对其</td><td></td></tr><tr><td>buildConfigField(type, name, value)</td><td>添加一个字段到 BuildConfig Class文件中</td><td></td></tr><tr><td>consumerProguardFile(proguardFile)</td><td>添加一个需要打包进AAR的混淆文件</td><td></td></tr><tr><td>consumerProguardFiles(proguardFiles)</td><td>添加些需要打包进AAR的混淆文件</td><td></td></tr><tr><td>externalNativeBuild(action)</td><td>定义native构建参数</td><td></td></tr><tr><td>initWith(that)</td><td>复制指定build type的所有属性信息</td><td></td></tr><tr><td>proguardFile(proguardFile)</td><td>添加一个混淆定义文件</td><td></td></tr><tr><td>proguardFiles(files)</td><td>添加混淆定义文件</td><td></td></tr><tr><td>resValue(type, name, value)</td><td>添加一个资源信息</td><td></td></tr><tr><td>setProguardFiles(proguardFileIterable)</td><td>设置混淆定义文件</td><td></td></tr></tbody></table><p>仅仅对<code>buildTypes</code>的配置并不能满足我们差异化构建的要求，因此插件中为我们提供了另外的构建配置 <code>productFlavors</code>。</p><h2 id="productFlavors"><a href="#productFlavors" class="headerlink" title="productFlavors"></a>productFlavors</h2><p>productFlavors 和 defaultConfig 同属于 <code>ProductFlavor</code>类。两者的配置内容基本没什么差异，但是在不同变体的构造任务中，对应的变体配置将覆盖默认配置内容。</p><p>productFlavors 需要通过 <code>flavorDimensions</code> 创建“模式”名，以用来对 多个flavor进行组织分组。</p><p>在上面的 <code>productFlavors {...}</code> 例子中，我们声名了两组模式的<code>productFlavor</code>，<code>api</code>和<code>flavor</code>，同时每个模式下，都有两个flavor。</p><p>根据构建的组合规则，Android Plugin 会根据这些分组进行组合关系。以上的例子为例。会产生以下几个 productFalvor组合构建任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. api1Flavor1Debug</span><br><span class="line">2. api1Flavor1Release</span><br><span class="line">3. api2Flavor1Debug</span><br><span class="line">4. api2Flavor1Release </span><br><span class="line">5. api1Flavor2Debug</span><br><span class="line">6. api1Flavor2Release</span><br><span class="line">7. api2Flavor2Debug</span><br><span class="line">8. api2Flavor2Release</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>Gralde产生的变体数量等同于每个flavor模式的组合数量和构建类型数量的乘积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">falvor每个分组数量 * falvor每个分组数量... * BuildType子项数量</span><br></pre></td></tr></table></figure><p>同时产生是名字也是根据 <code>flavorDimensions</code>所声名的模式名顺序进行拼接。</p><p>比如例子中在 <code>flavorDimensions &quot;api&quot;,&quot;flavor&quot;</code>声名后，产生的编译名为<code>api*+flavor*+debug/release</code>的组合关系。</p><h3 id="productFlavor-DSL"><a href="#productFlavor-DSL" class="headerlink" title="productFlavor DSL"></a>productFlavor DSL</h3><h2 id="过滤变体"><a href="#过滤变体" class="headerlink" title="过滤变体"></a>过滤变体</h2><p>变体是Gradle根据配合内容进行组合增加的，往往会比我们所需求的变体要多，因此为了处理掉不不需要的变体。我们可以通过 <code>variantFilter {}</code>进行过滤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">variantFilter &#123;</span><br><span class="line">     if(it.name.contains(&quot;flavor2&quot;))&#123;</span><br><span class="line">         it.setIgnore(true)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>这样对于变体名中包含 <code>flavor2</code> 的构建变体都将不会出现在 Build Variant 中。</p><h2 id="变体源"><a href="#变体源" class="headerlink" title="变体源"></a>变体源</h2><p>变体提供了对构建源的隔离，在不同的变体下，可以配置不同的 <code>sourceSet</code>信息。</p><p>默认情况下，<code>main/</code> 的构建源是默认存在的，无论通过任何变体进行构建都将纳入构建范围，因此这里在 <code>main/</code>下存储的都是哥哥变体都共享的资源，而如果需要根据变体信息进行特殊构建的内容，则需要放到对应的变体目录下。</p><p>比如对于 <code>api1Flavor1Debug</code> 变体。对于以下几个源都将纳入构建范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. api1&#x2F;</span><br><span class="line">2. flavor1&#x2F;</span><br><span class="line">3. debug&#x2F;</span><br><span class="line">4. api1Flavor1&#x2F;</span><br><span class="line">5. flavor1Debug&#x2F;</span><br><span class="line">6. api1Flavor1Debug&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>所以如果在这些目录下如果存在同名文件将导致编译冲突。</p><p>如果需要考虑其他的构建源，则可以考虑通过 <code>sourceSets {}</code>进行设置，因为 <code>sourceSet</code> 也支持变体设置因此可以通过以下设置，对单独构建变体进行设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        api2Flavor2 &#123;</span><br><span class="line">            java.srcDirs &#x3D; [ project.getProjectDir().getAbsolutePath() + &#39;&#x2F;src&#x2F;api2Flavor2&#x2F;temp&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>这样就在 <code>api2Flavor2</code> 变体构建时，将 ‘/src/api2Flavor2/temp’ 纳入构建范围</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>一起编译 java/ 目录中的所有源代码以生成单一的输出。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：对于给定的构建变体，如果找到两个或两个以上定义同一 Java 类的源集目录，Gradle 就会引发一个构建错误。例如，在构建调试 APK 时，您不能同时定义 src&#x2F;debug&#x2F;Utility.java 和 src&#x2F;main&#x2F;Utility.java。这是因为 Gradle 会在构建过程中检查这两个目录并引发“duplicate class”错误。如果针对不同的构建类型需要不同版本的 Utility.java，您可以让每个构建类型定义其自己的文件版本，而不将其包含在 main&#x2F; 源集中。</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><ul><li>所有清单合并为单个清单。将按照上述列表中的相同顺序指定优先级。也就是说，某个构建类型的清单设置会替换某个产品风味的清单设置，依此类推。如需了解更多信息，请阅读合并清单。</li><li>同样，values/ 目录中的文件也会合并在一起。如果两个文件同名，例如存在两个 strings.xml 文件，将按照上述列表中的相同顺序指定优先级。也就是说，在构建类型源集中的文件中定义的值将会替换产品风味中同一文件中定义的值，依此类推。</li><li>res/ 和 asset/ 目录中的资源将打包到一起。如果两个或两个以上的源集中定义有同名资源，将按照上述列表中的相同顺序指定优先级。</li><li>最后，在构建 APK 时，Gradle 会为随库模块依赖项包含的资源和清单分配最低的优先级。</li></ul><h2 id="变体依赖"><a href="#变体依赖" class="headerlink" title="变体依赖"></a>变体依赖</h2><p>正如源设置一样，依赖也支持变体依赖</p><p>可以通过添加变体+依赖方式进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    api2Flavor2Compile &#39;junit:junit:4.12&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;构建变体(Build Variants)有两部分内容构成 :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buildTypes&lt;/code&gt;（构建类型） + 
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Transform的基本应用</title>
    <link href="http://yoursite.com/2018/06/09/Transform%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/09/Transform%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</id>
    <published>2018-06-09T12:51:56.000Z</published>
    <updated>2020-04-10T13:19:56.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android Transform Api 是 Android Gradle Plugin 中提供的一个hook api，该api提供了在 class 转换为 dex 前的加工处理入口，通过该api，我们可以对执行class内容进行更改调整。</p><h2 id="Transform-的基本认识"><a href="#Transform-的基本认识" class="headerlink" title="Transform 的基本认识"></a>Transform 的基本认识</h2><p>Transform 实际是一个普通的回调入口，该回调将根据 Transform 所返回的各个配置，在 class 转换为 dex 前，根据配置内容进行调用，并将结果通过 <code>transform(Context, Collection, Collection, TransformOutputProvider, boolean)【过期】</code> 或 <code>transform(TransformInvocation)</code> 进行返回。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在 Transform 中有几个必须实现的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ClassCollectorTransform extends Transform&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><table><thead><tr><th>方法名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>getName</td><td>Transform Task 命名，该返回名不是作为最后的命名，任务会自动补全该名字</td><td></td></tr><tr><td>getInputType()</td><td>Transform 需要输入的内容类型</td><td></td></tr><tr><td>getScopes</td><td>Transform 搜索范围类型</td><td></td></tr><tr><td>isIncemental</td><td>是否支持增量编译</td><td></td></tr></tbody></table><p>主要参数说明：</p><p>InputType</p><p>该参数指名需要操作的内容，主要：</p><ul><li>CLASSES Java代码</li><li>RESOURCES Java Resource 资源</li></ul><p>除此之外官方提供了一些其他操作内容，但是受限于前置任务的产出物，并不能完全适用于当前阶段的 transform（指定操作内容必须是已产生的产出物）</p><ul><li>DEX</li><li>NATIVE_LIBS</li><li>CLASSES_ENHANCED</li><li>DATA_BINDING</li><li>JAVA_SOURCES</li><li>DEX_ARCHIVE</li></ul><p>Scopes</p><p>该参数指明需要搜索的目标范围，主要提供以下几种内容：</p><ul><li>PROJECT <code>当前项目内容</code></li><li>SUB_PROJECTS <code>子项目内容</code></li><li>EXTERNAL_LIBRARIES <code>外部依赖库</code></li><li>TESTED_CODE <code>测试代码</code></li><li>PROVIDED_ONLY <code>provider 方式的本地或者远程依赖</code></li><li>PROJECT_LOCAL_DEPS <code>项目本地依赖（local jars)</code></li><li>SUB_PROJECTS_LOCAL_DEPS <code>子项目的本地依赖（local jars）</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据以上参数，基本上我们通过使用 InputType + Scope 能实现对应目标内容的输入源的控制。</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>配置完所需要的配置后，接下来就是对所输出的内容进行转换的过程。</p><p>在旧版中，内容是被输出到：</p><p><code>transform(Context contenxt, Collection inputs, Collection referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental)</code>方法中</p><p>这里我们以新版为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(TransformInvocation transformInvocation)</span><br></pre></td></tr></table></figure><p>TransformInvocation 只是对旧版的封装，及其增加一些补充内容，我们只对目前比较常用的一些参数进行描述。</p><p><strong>Context getContext()</strong></p><p>返回任务上下文，实质该Context为 TransformTask 的父类，TransformTask 是继承自 DefaultTask 的任务子类</p><p><strong>Collection getInputs()</strong></p><p>返回InputType Scopes所要求的内容，TransformInput 提供了两种结果输出，一种是jar，一种是 File（被DirectoryInput包装了） 输出，这两种内容我们都需要进行处理。</p><p><strong>TransformOutputProvider getOutputProvider()</strong></p><p>TransformOutputProvider 是官方提供的输出代理类，通过该工具类，我们可以将需要指定输出的内容输出到所要求的目录下。</p><p>下面用一个例子来简单操作下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class ExampleTransform extends Transform &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return &quot;Example&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        return TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation)</span><br><span class="line">        println &quot;begin transform&quot;</span><br><span class="line"></span><br><span class="line">        transformInvocation.getInputs().each &#123; TransformInput input -&gt;</span><br><span class="line">            input.directoryInputs.each &#123; DirectoryInput directoryInput-&gt;</span><br><span class="line">                File outputFile &#x3D; transformInvocation.getOutputProvider().getContentLocation(directoryInput.name,</span><br><span class="line">                        directoryInput.contentTypes, directoryInput.scopes,</span><br><span class="line">                        Format.DIRECTORY)</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, outputFile)</span><br><span class="line"></span><br><span class="line">                println &quot;directory input  &gt;&gt;&gt; $&#123;directoryInput.file.getAbsolutePath()&#125;&quot;</span><br><span class="line">                println &quot;directory output &gt;&gt;&gt; $&#123;outputFile.getAbsolutePath()&#125; \n&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            input.jarInputs.each &#123; JarInput jarInput-&gt;</span><br><span class="line">                String jarName &#x3D; jarInput.name</span><br><span class="line">                File outputFile &#x3D; transformInvocation.getOutputProvider().getContentLocation(jarName,</span><br><span class="line">                        jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line"></span><br><span class="line">                FileUtils.copyFile(jarInput.file, outputFile)</span><br><span class="line"></span><br><span class="line">                println &quot;jar input  &gt;&gt;&gt; $&#123;jarInput.file.getAbsolutePath()&#125;&quot;</span><br><span class="line">                println &quot;jar output &gt;&gt;&gt; $&#123;outputFile.getAbsolutePath()&#125;\n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println &quot;end transform&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">:app:mergeDebugAssets</span><br><span class="line">:app:transformClassesWithExampleForDebug</span><br><span class="line">begin transform</span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;appcompat-v7-27.1.1.aar&#x2F;7228f687c4d3d50971fb2c4144b818e5&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;0.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;constraint-layout-1.1.2.aar&#x2F;1ffd866ac236943344a2db8900ec9ff0&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;1.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-fragment-27.1.1.aar&#x2F;366533887dab6e0bdc7b5f9565c8df3f&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;2.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;animated-vector-drawable-27.1.1.aar&#x2F;9aa09e1b40578aaf51e0fe3c26b1cf2b&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;3.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-core-ui-27.1.1.aar&#x2F;fbf121a4aa433efd0847730e6a71dfa6&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;4.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-core-utils-27.1.1.aar&#x2F;249c37a99952d8b3446a0f10707ef631&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;5.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-vector-drawable-27.1.1.aar&#x2F;0e11925044cb0cd7243a520ef57b6b65&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;6.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-compat-27.1.1.aar&#x2F;89e06865e27940d83a4ef0b84e7a40ec&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;7.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;com.android.support&#x2F;support-annotations&#x2F;27.1.1&#x2F;39ded76b5e1ce1c5b2688e1d25cdc20ecee32007&#x2F;support-annotations-27.1.1.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;8.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;com.android.support.constraint&#x2F;constraint-layout-solver&#x2F;1.1.2&#x2F;bfc967828daffc35ba01c9ee204d98b664930a0f&#x2F;constraint-layout-solver-1.1.2.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;9.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;livedata-core-1.1.0.aar&#x2F;63c28b9d84c74954069ca32d59a8948a&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;10.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;viewmodel-1.1.0.aar&#x2F;e7d22623b4477da4befa3300011bae7f&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;11.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;runtime-1.1.0.aar&#x2F;ddae57800275e6f4fbfcddbc1689ac1c&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;12.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;android.arch.lifecycle&#x2F;common&#x2F;1.1.0&#x2F;edf3f7bfb84a7521d0599efa3b0113a0ee90f85&#x2F;common-1.1.0.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;13.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;runtime-1.1.0.aar&#x2F;6a2bd34a44e70a5ec1df7445a52ad01e&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;14.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;android.arch.core&#x2F;common&#x2F;1.1.0&#x2F;8007981f7d7540d89cd18471b8e5dcd2b4f99167&#x2F;common-1.1.0.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;15.jar</span><br><span class="line"></span><br><span class="line">directory input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;classes&#x2F;debug</span><br><span class="line">directory output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;16 </span><br><span class="line"></span><br><span class="line">end transform</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>在以上例子中我们并未对拦截到的class内容进行任何操作，仅仅只是将它们进行转移，这里需要注意的是，我们对于拦截的内容，需要手动转移到指定的 <code>getContentLocation</code> 地址下，不能随意进行存储，否则将不能正常处理转换后的内容。</p><p>另外根据所指定的产物内容的不同，<code>getContentLocation</code>所存放的地址也不一样。</p><p>这里值得注意的是，如果我们忽略了部分代码的转移，那么在最后的包中，将不再有该代码文件的存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransformManager 提供了较多常用的封装工具，可以参考这里面的API进行调用</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结合以上的内容，已经可以初步获取到所需要产物的输入内容，并能将所输出的内容转移到对应的目录下。在这个流程中，我们可以任意对输入内容进行修改后再进行转移，以达到所需要的代码调整的目的。</p><p>当然对应晦涩难懂的Class 字节码，我们不会直接对字节流进行读取后操作，而是借助于字节码工具，在进行加工处理。</p><p>比较出名的字节码操作库有javassist、asm、aspectJ等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Android Transform Api 是 Android Gradle Plugin 中提供的一个hook api，该api提供了在 
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle中Task应用</title>
    <link href="http://yoursite.com/2018/06/01/Gradle%E4%B8%ADTask%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/01/Gradle%E4%B8%ADTask%E5%BA%94%E7%94%A8/</id>
    <published>2018-06-01T12:50:16.000Z</published>
    <updated>2020-04-10T13:20:09.301Z</updated>
    
    <content type="html"><![CDATA[<p>在认识Task之前需要知道Gradle的生命周期分为： 初始化阶段、配置阶段和执行阶段。</p><p>Task作为Project的单位，也遵循这个生命周期流程。</p><h2 id="Task-的配置、动作与依赖"><a href="#Task-的配置、动作与依赖" class="headerlink" title="Task 的配置、动作与依赖"></a>Task 的配置、动作与依赖</h2><h3 id="Task-的配置"><a href="#Task-的配置" class="headerlink" title="Task 的配置"></a>Task 的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task exampleTask &#123;</span><br><span class="line">    config1 &#x3D; &quot;config 1&quot;</span><br><span class="line">    config2 &#x3D; &quot;config 2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义task时，我们会在定义后跟上一个闭包，这个闭包将在配置阶段执行，因此我们可以在该闭包中，执行对太任务的属性配置和动作添加等。</p><p>注意，配置执行几乎在每次脚本执行流程都将发生。</p><p>执行task的命令比较简单，这里就不举例了，可以直接创建一个 build.gradle（每个构建项目下，默认约定的文件名，没有为什么） 进行试验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle 任务名</span><br></pre></td></tr></table></figure><h3 id="Task-的动作"><a href="#Task-的动作" class="headerlink" title="Task 的动作"></a>Task 的动作</h3><p>与配置不同，Task的动作发生在执行阶段。</p><p>动作添加比较常用的有两种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task exampleTask &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute example task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task exampleTask &#123;</span><br><span class="line">   doLast &#123;</span><br><span class="line">        println &quot;execute example task&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种运算符重载的方式在 gralde 5.0 可能将被废除，因此比较推荐的是使用第二种方式，在配置流程中即实现。当然你也可以直接调用 Task 的 doLast 方法直接添加，这里看个人需求而定，只是相对集中的话，方便管理。</p><h3 id="Task的依赖"><a href="#Task的依赖" class="headerlink" title="Task的依赖"></a>Task的依赖</h3><p>和project 一样，task 也和task 可以产生相互的依赖关系，我们比较常用的场景是，对于 B Task 执行前，我们需要确保 A Task 是执行的，否则将不执行。</p><p>这种情况，我们就可以使用Task 的API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependsOn(tasks: Object...)</span><br></pre></td></tr></table></figure><p>在声明Task时，我们可以通过构建器，对Task对象进行简单的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task exampleATask &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute A Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleBTask(dependsOn: exampleATask) &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute B Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleCTask(dependsOn: [exampleATask,exampleBTask]) &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute C Task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task exampleATask &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute A Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleBTask(dependsOn: exampleATask) &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute A Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleCTask(dependsOn: [exampleATask,exampleBTask]) &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute B Task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别定义A、B、C三个任务，B依赖于A，C依赖于A、B，这里我们执行了C Task，结果输出了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :SubExample:exampleATask</span><br><span class="line">execute A Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleBTask</span><br><span class="line">execute B Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleCTask</span><br><span class="line">execute C Task</span><br></pre></td></tr></table></figure><p>可以看到 Gradle为我们优化了 Task的流程，分别执行了 A、B、C 任务</p><p>这里注意下，如果我们在一个依赖中存在多个依赖，在依赖间并不存在可以推断的顺序时，将不保证按声明顺序执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task exampleATask &lt;&lt; &#123;</span><br><span class="line">println &quot;execute A Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleBTask &lt;&lt; &#123;</span><br><span class="line">println &quot;execute B Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleCTask &lt;&lt; &#123;</span><br><span class="line">println &quot;execute C Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleDTask(dependsOn: [exampleCTask,exampleBTask,exampleATask]) &lt;&lt; &#123;</span><br><span class="line">println &quot;execute D Task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行 <code>exammpleDTask</code>任务，而输出的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :SubExample:exampleATask</span><br><span class="line">execute A Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleBTask</span><br><span class="line">execute B Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleCTask</span><br><span class="line">execute C Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleDTask</span><br><span class="line">execute D Task</span><br><span class="line">dependsOn&#96;的任务关系中，如果前置任务失败，则不会继续执行下面的Task，如果需要保证即使失败也需要执行接下来的任务，则可以使用Task的Api &#96;finalizedBy(paths: Object...)</span><br><span class="line">task exampleDTask(dependsOn: [exampleCTask,exampleBTask,exampleATask]) &#123;</span><br><span class="line">finalizedBy exampleETask</span><br><span class="line">doLast &#123;</span><br><span class="line">println &quot;execute D Task&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上最后需要确保 <code>exampleETask</code> 执行</p><h2 id="自定义Task"><a href="#自定义Task" class="headerlink" title="自定义Task"></a>自定义Task</h2><p>在 task 定义中我们经常看到这样定义的任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task CopyTask(type:Copy) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>type</code> 即是 <code>CopyTask</code> 所声明的Task类型，它继承了 Copy Task 一切特性，这相当于我们的继承概念，而 CopyTask 便是其子类，并在<code>task</code>的声明中产生其实例。</p><p>这里我们将 <code>Copy</code> Task 当做其 Task 的一个模板，因为 copy 任务是经常被复用的，因此将其作为一个内置Task。</p><p>那么类似的情况，如果我们也有一个常用的Task模板，我们应该怎么自定义呢。</p><h3 id="简单自定义Task"><a href="#简单自定义Task" class="headerlink" title="简单自定义Task"></a>简单自定义Task</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">task ExampleSubTask(type:ExampleTask) &#123;</span><br><span class="line">taskParam &#x3D; &quot;ExampleSubTask&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ExampleTask extends DefaultTask &#123;</span><br><span class="line">String taskParam</span><br><span class="line"></span><br><span class="line">@TaskAction</span><br><span class="line">void start()&#123;</span><br><span class="line">println &quot;Example Task start $taskParam&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :ExampleSubTask</span><br><span class="line">Example Task start ExampleSubTask</span><br></pre></td></tr></table></figure><p>这是个简单的例子，我们继承默认的 Task 实现 <code>DefaultTask</code>，然后在对应的 Task 方法签名上声明 <code>@TaskAction</code>，作为任务的执行内容。</p><p>Tip：如果只是简单的实现Task内容，则可以使用<code>DefaultTask</code>，其他的细节可参照其父类进行对应的实现。</p><h2 id="备注-Api"><a href="#备注-Api" class="headerlink" title="备注 Api"></a>备注 Api</h2><h3 id="task依赖"><a href="#task依赖" class="headerlink" title="task依赖"></a>task依赖</h3><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>dependsOn(tasks:Object…)</td><td></td><td></td></tr></tbody></table><h3 id="动作定义"><a href="#动作定义" class="headerlink" title="动作定义"></a>动作定义</h3><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>doFirst(action: Closure)</td><td></td><td></td></tr><tr><td>doLast(action: Closure)</td><td></td><td></td></tr><tr><td>getActions()</td><td></td><td></td></tr></tbody></table><h3 id="输入-输出数据声明"><a href="#输入-输出数据声明" class="headerlink" title="输入/输出数据声明"></a>输入/输出数据声明</h3><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>getInputs()</td><td></td><td></td></tr><tr><td>getOutputs()</td><td></td><td></td></tr></tbody></table><h3 id="getter-setter-属性"><a href="#getter-setter-属性" class="headerlink" title="getter/setter 属性"></a>getter/setter 属性</h3><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>getAnt()</td><td></td><td></td></tr><tr><td>getDescription()</td><td></td><td></td></tr><tr><td>getEnabled()</td><td></td><td></td></tr><tr><td>getGroup()</td><td></td><td></td></tr><tr><td>setDescription(description: String)</td><td></td><td></td></tr><tr><td>setEnabled(enabled: boolean)</td><td></td><td></td></tr><tr><td>setGroup(group: String)</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在认识Task之前需要知道Gradle的生命周期分为： 初始化阶段、配置阶段和执行阶段。&lt;/p&gt;
&lt;p&gt;Task作为Project的单位，也遵循这个生命周期流程。&lt;/p&gt;
&lt;h2 id=&quot;Task-的配置、动作与依赖&quot;&gt;&lt;a href=&quot;#Task-的配置、动作与依赖&quot; c
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin协程初识</title>
    <link href="http://yoursite.com/2018/06/01/Kotlin%E5%8D%8F%E7%A8%8B%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2018/06/01/Kotlin%E5%8D%8F%E7%A8%8B%E5%88%9D%E8%AF%86/</id>
    <published>2018-06-01T08:50:29.000Z</published>
    <updated>2020-04-14T11:28:19.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程相对于线程来说，会更为轻量，不存在上下文切换，减少状态恢复的损失。有效利用了闲置线程资源。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>支持任务挂起、恢复</li><li>非抢占式执行</li><li>非线程阻塞式</li></ul><h2 id="支持动作"><a href="#支持动作" class="headerlink" title="支持动作"></a>支持动作</h2><ul><li>suspend <code>协程挂起，相对于线程挂起来说，线程完全阻塞，而协程的阻塞不会对线程产生影响</code></li></ul><h1 id="Gradle-环境配置"><a href="#Gradle-环境配置" class="headerlink" title="Gradle 环境配置"></a>Gradle 环境配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &#39;org.jetbrains.kotlin.jvm&#39; version &#39;1.3.61&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    &#x2F;&#x2F; jdk8 kotlin 支持</span><br><span class="line">    implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 主要是在kotin 构建环境下，配置该协程依赖</span><br><span class="line">    implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.5&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果之前是Kotlin环境，则只要增加依赖即可</p><p><code>implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.5&quot;</code></p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun main(arg: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(&quot;main thread $&#123;Thread.currentThread().name&#125;  id $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    val job &#x3D; GlobalScope.launch(Dispatchers.IO, CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">        println(&quot;do coroutine task , thread $&#123;Thread.currentThread().name&#125;  id $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(&quot;JOB &#x3D;&#x3D; &gt; $job&quot;)</span><br><span class="line">    &#x2F;&#x2F; 防止程序过早关闭</span><br><span class="line">    Thread.sleep(2000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27453/WEBRESOURCE314bf11130f4deb810a887cccb76cce4"  alt="image.png"></p><p>该例子中，通过调用 GlobalScope 作用域，直接启动一个协程并执行传入到<code>launch</code>方法的闭包的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public fun CoroutineScope.launch(</span><br><span class="line">    context: CoroutineContext &#x3D; EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart &#x3D; CoroutineStart.DEFAULT,</span><br><span class="line">    block: suspend CoroutineScope.() -&gt; Unit</span><br><span class="line">): Job &#123;</span><br><span class="line">    val newContext &#x3D; newCoroutineContext(context)</span><br><span class="line">    val coroutine &#x3D; if (start.isLazy)</span><br><span class="line">        LazyStandaloneCoroutine(newContext, block) else</span><br><span class="line">        StandaloneCoroutine(newContext, active &#x3D; true)</span><br><span class="line">    coroutine.start(start, coroutine, block)</span><br><span class="line">    return coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>launch</code> 中有三个参数：</p><ul><li>context: CoroutineContext <code>协程所执行的上下文环境，即线程池类型</code></li><li>start: CoroutineStart <code>协程启动方式</code></li><li>block: suspend CoroutineScope.() -&gt; Unit <code>协程执行内容</code></li></ul><h2 id="CoroutineScope"><a href="#CoroutineScope" class="headerlink" title="CoroutineScope"></a>CoroutineScope</h2><p>在Kotlin协程中<code>CoroutineScope</code>是一个比较重要的概念，它提供了对协程的作用域范围，通过它，我们可以对它所属的所有协程进行控制。</p><p>对于在协程内部再次创建的协程，该关系可以被传递。<br>比如对于在第一次的协程创建中，如果我们该协程体中，再次声明一个协程，则两协程为父子关系，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GlobalScope.launch &#123;</span><br><span class="line">    ...</span><br><span class="line">    launch &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    launch &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部两个launch产生的协程为顶层launch的协程的子协程。</p><p>在<code>CoroutineScope</code>接口源码中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public interface CoroutineScope &#123;</span><br><span class="line">    public val coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public object GlobalScope : CoroutineScope &#123;</span><br><span class="line">    override val coroutineContext: CoroutineContext</span><br><span class="line">        get() &#x3D; EmptyCoroutineContext</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出 <code>CoroutineScope</code> 里面重要的是对  <code>coroutineContext</code> 的指定，在父子协程中，主要是对该context的传递。</p><p>对于父子协程有几个特点：</p><ul><li>当在协程中在另一个协程的scope中启动，则自动继承它的context。</li><li>新启动子协程Job中在父协程的Job.child 中。</li><li>父协程被取消时，子协程也会被取消</li><li>父协程会等待子协程完成在结束</li></ul><p><code>CoroutineScope</code>可以应用于我们对生命周期的管理，比如当我们需要在Android Activity结束时结束协程，则可以通过实现该接口，让协程绑定，待到合适的时机再进行全部任务的取消。</p><p>在以上例子中的 <code>GlobalScope</code> 是一个顶层<code>CoroutineScope</code>，它创建的协程都是独立运行的<code>CoroutineScope</code>，和外部创建的没有关系，除非启动时指定。</p><h2 id="Dispatchers"><a href="#Dispatchers" class="headerlink" title="Dispatchers"></a>Dispatchers</h2><p>在Kotlin中提供了 <code>kotlinx.coroutines.kotlinx.Dispatchers</code> 工具类，根据自己的需求进行不同的上下文<code>CoroutineContext</code>的选择。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public actual object Dispatchers &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认上下文，启用的线程数量和CPU相同，但是最少有</span><br><span class="line">    &#x2F;&#x2F; 两个线程支持，通常用于计算之类的密集工作</span><br><span class="line">    @JvmStatic</span><br><span class="line">    public actual val Default: CoroutineDispatcher &#x3D; createDefaultDispatcher()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 主线程上下文，和平台有关，比如Android平台指的是</span><br><span class="line">    &#x2F;&#x2F; UI线程，如果平台不支持将抛出异常</span><br><span class="line">    @JvmStatic</span><br><span class="line">    public actual val Main: MainCoroutineDispatcher get() &#x3D; MainDispatcherLoader.dispatcher</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 不指定线程，在调用的线程中执行</span><br><span class="line">    @JvmStatic</span><br><span class="line">    public actual val Unconfined: CoroutineDispatcher &#x3D; kotlinx.coroutines.Unconfined  </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 不会占用主线程，常用于 </span><br><span class="line">    &#x2F;&#x2F; 网络、IO读写等工作，做一些常需要异步的工作，</span><br><span class="line">    &#x2F;&#x2F; on-demand 线程池</span><br><span class="line">    @JvmStatic</span><br><span class="line">    public val IO: CoroutineDispatcher &#x3D; DefaultScheduler.IO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们这边需要进行频繁的计算则使用IO密集型线程池：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun main(arg: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(&quot;main thread $&#123;Thread.currentThread().name&#125;  id $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    GlobalScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">        println(&quot;do coroutine task , thread $&#123;Thread.currentThread().name&#125;  id $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CoroutineStart"><a href="#CoroutineStart" class="headerlink" title="CoroutineStart"></a>CoroutineStart</h2><p>除了可以指定线程环境外，<code>launch</code> 还可以指定启动时机。<br>在 <code>CoroutineStart</code> 提供了几种模式：</p><ul><li><p>DEFAULT <code>默认模式，立即执行</code></p></li><li><p>LAZY <code>在需要的情况下执行，取决于start调用</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(arg: Array&lt;String&gt;) &#123;</span><br><span class="line">    val job &#x3D; GlobalScope.launch(Dispatchers.IO, CoroutineStart.LAZY) &#123;</span><br><span class="line">        println(&quot;do coroutine task , thread $&#123;Thread.currentThread().name&#125;  id $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;Task is Active &#x3D;&#x3D; &gt; $&#123;job.isActive&#125;&quot;)</span><br><span class="line">    job.start()</span><br><span class="line">    println(&quot;Task is Active &#x3D;&#x3D; &gt; $&#123;job.isActive&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Task is Active before start &#x3D;&#x3D; &gt; false</span><br><span class="line">Task is Active after start&#x3D;&#x3D; &gt; true</span><br><span class="line">do coroutine task , thread DefaultDispatcher-worker-1  id 10</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li><li><p>ATOMIC <code>立即执行，但是在执行前无法被取消</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(arg: Array&lt;String&gt;) &#123;</span><br><span class="line">    val job &#x3D; GlobalScope.launch(Dispatchers.IO, CoroutineStart.ATOMIC) &#123;</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;do coroutine task , thread $&#123;Thread.currentThread().name&#125;  id $&#123;Thread.currentThread().id&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    job.cancel()</span><br><span class="line">    println(&quot;Task is Cancelled &#x3D;&#x3D; &gt; $&#123;job.isCancelled&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Task is Cancelled &#x3D;&#x3D; &gt; true</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></li><li><p>UNDISPATCHED <code>会在调用线程立即执行，直到遇到到suspend操作才挂起，之后suspend恢复或者join操作后才切换</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun main(arg: Array&lt;String&gt;) &#123;</span><br><span class="line">    val job &#x3D; GlobalScope.launch(Dispatchers.IO, CoroutineStart.UNDISPATCHED) &#123;</span><br><span class="line">        println(&quot;[$&#123;Thread.currentThread().name&#125;]task1 before suspend&quot;)</span><br><span class="line">        delay(1000)</span><br><span class="line">        println(&quot;[$&#123;Thread.currentThread().name&#125;]task1 after suspend&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main]task1 before suspend</span><br><span class="line">[DefaultDispatcher-worker-1]task1 after suspend</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="关于返回的Job"><a href="#关于返回的Job" class="headerlink" title="关于返回的Job"></a>关于返回的Job</h2><p><code>launch</code>方法会返回一个<code>Job</code>对象，使用该对象可以对协程进行状态的判断、取消等操作。</p><h1 id="其他启动形式"><a href="#其他启动形式" class="headerlink" title="其他启动形式"></a>其他启动形式</h1><p>相较于 <code>launch</code>调用形式，Kotlin 还提供了多种的调用形式。</p><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p><code>launch</code> 的调用是无法获得其他协程下的结果，如果有这种需要，则使用<code>async</code> 替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun main(arg: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(&quot;start&quot;)</span><br><span class="line">    val result &#x3D; GlobalScope.async  &#123;</span><br><span class="line">       return@async &quot;[$&#123;Thread.currentThread().name&#125;]Async Result&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(1000)</span><br><span class="line">    println(&quot;result : $&#123;result.getCompleted()&#125;&quot;)</span><br><span class="line">    println(&quot;end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">result : [DefaultDispatcher-worker-1]Async Result</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h2 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking"></a>runBlocking</h2><p>在之前的例子中，为了防止主线程终止，导致我们协程还没执行完就退出程序，都需要执行 <code>sleep</code> 操作。在Kotlin里面也提供了一种中和方案，可以在协程执行过程中，对调用环境进行阻塞。</p><p>在之前 <code>launch</code> 中如果执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(arg: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(&quot;start&quot;)</span><br><span class="line">    val result &#x3D; GlobalScope.launch  &#123;</span><br><span class="line">        delay(1000L)</span><br><span class="line">       println(&quot;[$&#123;Thread.currentThread().name&#125;]run blocking task&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">end</span><br><span class="line">[DefaultDispatcher-worker-1]run blocking task</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>协程中的内容发生于调用线程执行后，无法满足 start -&gt; 协程 -&gt; end 的执行流程，如果改为 <code>runBlocking</code> 则能满足：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun main(arg: Array&lt;String&gt;) &#123;</span><br><span class="line">    println(&quot;[$&#123;Thread.currentThread().name&#125;]start&quot;)</span><br><span class="line">    val result &#x3D; runBlocking(Dispatchers.IO)  &#123;</span><br><span class="line">        delay(1000L)</span><br><span class="line">        println(&quot;[$&#123;Thread.currentThread().name&#125;]run blocking task&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;[$&#123;Thread.currentThread().name&#125;]end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[main]start</span><br><span class="line">[DefaultDispatcher-worker-1]run blocking task</span><br><span class="line">[main]end</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协程&quot;&gt;&lt;a href=&quot;#协程&quot; class=&quot;headerlink&quot; title=&quot;协程&quot;&gt;&lt;/a&gt;协程&lt;/h1&gt;&lt;p&gt;协程相对于线程来说，会更为轻量，不存在上下文切换，减少状态恢复的损失。有效利用了闲置线程资源。&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Gradle配置Kotlin环境</title>
    <link href="http://yoursite.com/2018/05/24/Gradle%E9%85%8D%E7%BD%AEKotlin%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/05/24/Gradle%E9%85%8D%E7%BD%AEKotlin%E7%8E%AF%E5%A2%83/</id>
    <published>2018-05-24T12:47:07.000Z</published>
    <updated>2020-04-10T12:49:31.082Z</updated>
    
    <content type="html"><![CDATA[<p>在最新的Android Studio 上已经提供了默认的Kotlin工程的模板，但是这些简单的配置远不能满足一个复杂项目的构建要求，因此这里重新做下整理，搬运下Kotlin官方的内容。</p><h2 id="一、基本Kotlin环境配置"><a href="#一、基本Kotlin环境配置" class="headerlink" title="一、基本Kotlin环境配置"></a>一、基本Kotlin环境配置</h2><h3 id="Import-Plugin"><a href="#Import-Plugin" class="headerlink" title="Import Plugin"></a>Import Plugin</h3><p>1.如果Gradle 版本在2.1前可以使用以下引入方式。</p><p>1.1 在脚本文件下添加外部Gradle插件依赖引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version &#x3D; &#39;1.2.61&#39;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>1.2 应用Gradle Kotlin插件</p><p>在需要引入项目（可能你是多项目构建，模块）构建脚本下引入插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &quot;kotlin&quot;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>2.如果Gradle版为2.1或以上，则可以在对应需要引入的构建脚本下方便的使用<code>plugins {}</code>脚本块进行快速引入（不需要再<code>buildscript</code>中声名引入了）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">      id &quot;org.jetbrains.kotlin.jvm&quot; version &quot;1.2.61&quot; &#x2F;&#x2F; 使用社区插件（非内置核心插件）方式引入，需要指定版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p><code>plugins {}</code>默认是指向Gradle自己的<code>https://plugins.gradle.org/m2</code>仓库，实测了下，maven依赖并不全，有时候会发现 not find 些依赖库。</p><p>解决这个问题可以在 <code>settings.gradle</code> 可以对 仓库地址进行配置下。(发现gralde插件还是会在一些比较老的仓库发布，作为备用，可以调整配置下)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h3 id="Set-Source"><a href="#Set-Source" class="headerlink" title="Set Source"></a>Set Source</h3><p>Kotlin 插件默认将 <code>src / main / kotlin /</code>和 <code>src / main / java /</code> 作为 <code>srcDirs</code>路径</p><p>如果项目对默认路径做了调整，需要重新设置该信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main.kotlin.srcDirs +&#x3D; &#39;src&#x2F;main&#x2F;自己的目录&#39; &#x2F;&#x2F; 让 kotlin 知道哪些目录是存在kotlin代码源文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>在 Android Studio 中，还需要额外将kotlin目录添加到 <code>main.java.srcDirs</code>中，以让IDE能正确识别这些目录为源目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  sourceSets &#123;</span><br><span class="line">    main.java.srcDirs +&#x3D; &#39;src&#x2F;main&#x2F;kotlin&#39; &#x2F;&#x2F; 让 Android Studio 知道这些目录是存在代码文件的，自动识别，产生一些IDE的效果</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="二、标准库支持"><a href="#二、标准库支持" class="headerlink" title="二、标准库支持"></a>二、标准库支持</h2><p>在满足构建环境后，我们还需要配置一些在生产环境下，Kotlin代码需要使用的标准函数库，这里在对应的项目下引入标准库即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &quot;org.jetbrains.kotlin:kotlin-stdlib&quot;</span><br><span class="line">    &#x2F;&#x2F; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7&quot; &#x2F;&#x2F; 如果仅需要支持 JDK7的话，直接使用这个</span><br><span class="line">    &#x2F;&#x2F; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot; &#x2F;&#x2F; 如果仅需要支持 JDK8版本的话</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>关于其他的Kotlin库的支持，可以参照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;kotlinlang.org&#x2F;docs&#x2F;reference&#x2F;using-gradle.html#configuring-dependencies</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="三、APT支持"><a href="#三、APT支持" class="headerlink" title="三、APT支持"></a>三、APT支持</h2><p>在 Android 插件中，官方已经支持APT了。但是加入 Kotlin 后，由于Kotlin构建环节和Java 有些微妙的变化，因此需要重建这个流程的构建，因此Kotlin为我们提供了另外的插件支持。</p><h3 id="引入插件"><a href="#引入插件" class="headerlink" title="引入插件"></a>引入插件</h3><p>和Kotlin插件引入类似，可以通过引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;kotlin-kapt&#39;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.jetbrains.kotlin.kapt&quot; version &quot;1.2.61&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>在本来使用 <code>annotationProcessor</code>依赖方式的依赖上，改为 <code>kapt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    kapt &#39;groupId:artifactId:version&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>kapt 不仅仅是会处理 kotlin 的内容，同时也可以处理 java 代码中的内容。</p><h3 id="变量配置"><a href="#变量配置" class="headerlink" title="变量配置"></a>变量配置</h3><p>Kotlin 提供了另外一个配置变量，对APT插件进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kapt &#123;</span><br><span class="line">    &#x2F;&#x2F; apt变量注入</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(&quot;key&quot;, &quot;value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; javac 编译环境配置</span><br><span class="line">    javacOptions &#123;</span><br><span class="line">        &#x2F;&#x2F; Increase the max count of errors from annotation processors.</span><br><span class="line">        &#x2F;&#x2F; Default is 100.</span><br><span class="line">        option(&quot;-Xmaxerrs&quot;, 500)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>注意： kotlint apt 支持生成Kotlin源文件，生成的源文件默认在 <code>processingEnv.options[&quot;kapt.kotlin.generated&quot;]</code>路径下，在最终编译时，将会把这个目录下的源文件进行编译。</p><h2 id="四、增量编译支持"><a href="#四、增量编译支持" class="headerlink" title="四、增量编译支持"></a>四、增量编译支持</h2><p>Kotlin 支持增量编译，可以通过 <code>gradle.properties</code> 进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kotlin.incremental&#x3D;true &#x2F;&#x2F; 开启增量，否则 false</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>或者对 <code>local.properties</code> 进行命令行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Pkotlin.incremental&#x3D;true</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="五、协程支持"><a href="#五、协程支持" class="headerlink" title="五、协程支持"></a>五、协程支持</h2><p>协程是Kotlin实验性特性，如果需要使用该特性，对kotlin变量进行配置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    experimental &#123;</span><br><span class="line">        coroutines &#39;enable&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在最新的Android Studio 上已经提供了默认的Kotlin工程的模板，但是这些简单的配置远不能满足一个复杂项目的构建要求，因此这里重新做下整理，搬运下Kotlin官方的内容。&lt;/p&gt;
&lt;h2 id=&quot;一、基本Kotlin环境配置&quot;&gt;&lt;a href=&quot;#一、基本Ko
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Groovy与Java差异简记</title>
    <link href="http://yoursite.com/2018/05/20/Groovy%E4%B8%8EJava%E5%B7%AE%E5%BC%82%E7%AE%80%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/20/Groovy%E4%B8%8EJava%E5%B7%AE%E5%BC%82%E7%AE%80%E8%AE%B0/</id>
    <published>2018-05-20T13:48:47.000Z</published>
    <updated>2020-04-10T12:50:53.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>Groovy 支持运算符重载，和python 一样，重载对应的方法即可实现对应运算符功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Example&#123;</span><br><span class="line">    String msg &#x3D; &quot;default&quot;</span><br><span class="line"></span><br><span class="line">    Example(String msg)&#123;</span><br><span class="line">        this.msg &#x3D; msg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Example plus(Example example)&#123;</span><br><span class="line">        msg +&#x3D; example.msg</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void main(String[] args)&#123;</span><br><span class="line">        Example exampleA  &#x3D; new Example(&quot;A&quot;)</span><br><span class="line">        Example exampleB &#x3D; new Example(&quot;B&quot;)</span><br><span class="line"></span><br><span class="line">        println((exampleA + exampleB).getMsg())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure><p>以上例子中 <code>+</code>的功能实现方法对应于 <code>plus</code>，因此重写了该方法，等同于实现了<code>+</code>的功能实现</p><h2 id="安全操作"><a href="#安全操作" class="headerlink" title="?.安全操作"></a>?.安全操作</h2><p>这个和Kotlin一样，使用<code>?.</code>调用操作，会在对象调用前，检查该对象是否为null，如果为null，则不进行调用操作，如果有返回值，则返回null</p><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def getMessage()&#123;</span><br><span class="line">    return &quot;Hello!!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    println(&quot;getMessage 1 : $&#123;example?.getMessage()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    example &#x3D; null</span><br><span class="line"></span><br><span class="line">    println(&quot;getMessage 2 : $&#123;example?.getMessage()&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getMessage 1 : Hello!!</span><br><span class="line">getMessage 2 : null</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>方法默认参数相对于其他语言已经比较熟悉，Groovy同样也支持。 Groovy 默认参数不局限仅能在末尾参数或者连续到末尾参数才能作为默认参数，它可以将中间参数作为默认参数</p><h3 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h3><p>情况1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def getArray(String a, String b &#x3D; &quot;obj b&quot;, String c, String d) &#123;</span><br><span class="line">    return [a, b, c, d]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    String a</span><br><span class="line">    String b</span><br><span class="line">    String c</span><br><span class="line">    String d</span><br><span class="line"></span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    (a, b, c, d) &#x3D; example.getArray(&quot;obj a&quot;, &quot;obj c&quot;, &quot;obj d&quot;)</span><br><span class="line"></span><br><span class="line">    println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;, c -&gt; $&#123;c&#125;, d -&gt; $&#123;d&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; obj a, b -&gt; obj b, c -&gt; obj c, d -&gt; obj d</span><br></pre></td></tr></table></figure><p>以上方法中，仅有b参数存在默认参数，而调用<code>getArray</code>方法仅提供三个参数，Groovy对于不满足默认方法签名的函数调用，会优先匹配到没有提供默认参数的参数上，因此这里<code>obj a</code>、<code>obj c</code>、<code>obj d</code>分别对应于 a、c、d 参数，而 b 则使用默认的参数 <code>obj b</code></p><p>情况2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def getArray(String a, String b &#x3D; &quot;obj b&quot;, String c, String d &#x3D; &quot;obj d&quot;) &#123;</span><br><span class="line">    return [a, b, c, d]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    String a</span><br><span class="line">    String b</span><br><span class="line">    String c</span><br><span class="line">    String d</span><br><span class="line"></span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    (a, b, c, d) &#x3D; example.getArray(&quot;obj a&quot;, &quot;obj b&quot;, &quot;obj c&quot;)</span><br><span class="line"></span><br><span class="line">    println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;, c -&gt; $&#123;c&#125;, d -&gt; $&#123;d&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; obj a, b -&gt; obj b, c -&gt; obj c, d -&gt; obj d</span><br></pre></td></tr></table></figure><p>情况3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def getArray(String a, String b &#x3D; &quot;obj b&quot;, String c &#x3D; &quot;obj c&quot;, String d, String e &#x3D; &quot;obj e&quot;, String f &#x3D; &quot;obj f&quot;, String g)&#123;</span><br><span class="line">    return [a, b, c, d, e, f, g]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    String a</span><br><span class="line">    String b</span><br><span class="line">    String c</span><br><span class="line">    String d</span><br><span class="line">    String e</span><br><span class="line">    String f</span><br><span class="line">    String g</span><br><span class="line"></span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    (a, b, c, d, e, f, g) &#x3D; example.getArray(&quot;obj a&quot;, &quot;obj d&quot;, &quot;obj d&quot;, &quot;obj g&quot;)</span><br><span class="line"></span><br><span class="line">    println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;, c -&gt; $&#123;c&#125;, d -&gt; $&#123;d&#125;, e -&gt; $&#123;e&#125;, f -&gt; $&#123;f&#125;, g -&gt; $&#123;g&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; obj a, b -&gt; obj d, c -&gt; obj c, d -&gt; obj d, e -&gt; obj e, f -&gt; obj f, g -&gt; obj g</span><br></pre></td></tr></table></figure><p>以上三个用例可以知道，当方法提供的调用参数不能满足方法所有参数数量时，会优先补足必须参数的参数值，后再对多出来的调用参数，按照已提供默认参数的参数顺序，进行赋值，覆盖默认参数的参数值。</p><h2 id="多赋值"><a href="#多赋值" class="headerlink" title="多赋值"></a>多赋值</h2><p>多赋值是对数据的”拆包”行为，在接收者们上需要使用<code>()</code>小括号，对需要“拆包”分别赋值对象进“打包”</p><h3 id="多赋值使用举例"><a href="#多赋值使用举例" class="headerlink" title="多赋值使用举例"></a>多赋值使用举例</h3><p>交换变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void main(String[] args) &#123;</span><br><span class="line">     String a &#x3D; &quot;obj a&quot;</span><br><span class="line">     String b &#x3D; &quot;obj b&quot;</span><br><span class="line"></span><br><span class="line">     (a, b) &#x3D; [b, a]</span><br><span class="line"></span><br><span class="line">     println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; obj b, b -&gt; obj a</span><br></pre></td></tr></table></figure><p>方法返回多结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def getArray() &#123;</span><br><span class="line">    return [&#39;element a&#39;,&#39;element b&#39;,&#39;element c&#39;,&#39;element d&#39;,&#39;element e&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    def (a,b,c) &#x3D; example.getArray()</span><br><span class="line"></span><br><span class="line">    println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;, c -&gt; $&#123;c&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; element a, b -&gt; element b, c -&gt; element c</span><br></pre></td></tr></table></figure><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><ul><li>接受者可以与数组对象数量不一致，如果接受者 &gt; 数组对象，则多出的对象将为null，即使之前有对象，也会被重新置为 null；如果接受者 &lt; 数组对象，则只会接收数组前几个对应的对象内容。</li><li>被“拆包”对象，可以为数组、List</li></ul><h2 id="方法调用括号可选"><a href="#方法调用括号可选" class="headerlink" title="方法调用括号可选"></a>方法调用括号可选</h2><p>当方法调用时，存在至少一个参数，可以省略括号</p><h2 id="set与get"><a href="#set与get" class="headerlink" title="set与get"></a>set与get</h2><p>和 Kotlin 一样，Groovy会自动对下面public的属性进行get和set方法的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Example&#123;</span><br><span class="line">    String msg &#x3D; &quot;default&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static void main(String[] args)&#123;</span><br><span class="line">        Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">        println(example.msg)</span><br><span class="line"></span><br><span class="line">        example.setMsg(&quot;set msg&quot;)</span><br><span class="line"></span><br><span class="line">        println(example.msg)</span><br><span class="line"></span><br><span class="line">        println(example.getMsg())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">set msg</span><br><span class="line">set msg</span><br></pre></td></tr></table></figure><p>当然，set、get方法也可以被重写</p><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>特征有点类似于接口的扩张，特征可以进行方法实现，属性定义，并且类可以多继承特征。 特征用 trait 作为关键词，在使用它时，和接口一样使用<code>implements</code>进行实现，在其他的特征中继承扩展特征时，使用<code>extends</code>进行继承扩展（基本使用上和接口一样）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    C c &#x3D; new C()</span><br><span class="line"></span><br><span class="line">    println(c.getMsg())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface X&#123;</span><br><span class="line">    String getMsg();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait A implements X&#123;</span><br><span class="line">    String getMsg()&#123;</span><br><span class="line">        return &quot;A&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B implements X&#123;</span><br><span class="line">    String getMsg()&#123;</span><br><span class="line">        &quot;B&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class C implements B,A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><h3 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip"></a>Tip</h3><ul><li>如果在多继承中存在方法冲突，则后继承的内容会覆盖前面的（包括属性和方法）。</li></ul><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>Groovy允许在方法调用的时候，省略括号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;运算符重载&quot;&gt;&lt;a href=&quot;#运算符重载&quot; class=&quot;headerlink&quot; title=&quot;运算符重载&quot;&gt;&lt;/a&gt;运算符重载&lt;/h2&gt;&lt;p&gt;Groovy 支持运算符重载，和python 一样，重载对应的方法即可实现对应运算符功能。&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
      <category term="Groovy" scheme="http://yoursite.com/tags/Groovy/"/>
    
  </entry>
  
  <entry>
    <title>JVM了解</title>
    <link href="http://yoursite.com/2018/05/15/JVM%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/15/JVM%E4%BA%86%E8%A7%A3/</id>
    <published>2018-05-15T13:28:18.000Z</published>
    <updated>2020-04-10T13:34:01.388Z</updated>
    
    <content type="html"><![CDATA[<p>对于程序，我们不仅需要了解开发时所需要的内容，还需要了解程序运行时的环境状态，这样可以方便我们对整个运行环境的掌控和开发。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24858/8FE2DDF94CCF45268EEC5290A0690FF1"  alt="image"></p><p>当我们通过javac 对所需要的源码编译后，便可以通过java虚拟机启动我们所编译的程序。</p><p>而后静态的二级制代码开始进入机器运行时内存中，通过执行引擎执行我们所提供的二进制指令。</p><p>在这流程中，我们需了解：</p><ol><li>编译后二进制代码怎么加载进入虚拟机运行时环境中。</li><li>对于加载后的代码虚拟机是怎么进行维护</li><li>对于运行过程中所产生的垃圾内存（已经需要被销毁的过期对象）怎么进行跟踪处理。</li></ol><h1 id="一、类加载"><a href="#一、类加载" class="headerlink" title="一、类加载"></a>一、类加载</h1><p>当虚拟机开始运行，虚拟机需要将我们所编译后的代码信息，通过类加载器（ClassLoader）加载到虚拟机运行时环境中。</p><p>在这里我们不从虚拟机执行代码角度上看，先从JVM运行逻辑上理解。根据二进制代码数据来源，JVM提供了不同的加载器。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24802/3DC5E3E8310643D28893372D7B07B2E2"  alt="image"></p><ul><li>Bootstrap ClassLoader <code>启动类加载器，负责对JDK/jre/lib 标准的运行时库进行加载。</code></li><li>ExtClassLoader <code>扩展类加载器，负责对JDK/jre/lib/ext 下扩展库进行加载</code></li><li>AppClassLoader <code>应用类加载器 负责对用户指定的 ClassPath 路径下的类进行加载，可以通过环境变量进行配置，用于运行库的扩展</code></li><li>UserClassLoader <code>用户自定义加载器 用户通过继承ClassLoader对自己所需要加载的库进行最后的加载扩展</code></li></ul><h2 id="双亲委托"><a href="#双亲委托" class="headerlink" title="双亲委托"></a>双亲委托</h2><p>为了类加载的安全性和避免重复加载，Java 提供了双亲机制，每一个ClassLoader 都存在一个父类加载器的引用，当一个ClassLoader需要加载某个类时，它将在自己搜索前先去询问它的父类加载器索引进行查询加载，依次类推直至找到最顶层的ClassLoader，当父类没有加载到则交由下级类去加载，如果最终没加载到则会抛出 ClassNotFoundExceptin 异常。对于一个类的加载需要依次根据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap ClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader -&gt; UserClassLoader</span><br></pre></td></tr></table></figure><p>的解析顺序。</p><p>如果在加载链中被父加载器所加载，则该类的不会被其他类加载器加载，以防止重复加载或者恶意加载等问题。</p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同一个类也可以强制被不同的类加载器所加载，但是在JVM中并不会认为是同一个类。</span><br></pre></td></tr></table></figure><h2 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h2><p>以上流程是对整个大流程进行描述，但是对于二进制数据怎么映射为内存数据并未描述清楚。这里我们描述下理论上逻辑。</p><p>在主动使用加载过程中，主要经历几个流程：</p><ul><li>加载 <code>将外部Class文件二进制流加载到虚拟机方法区下，转化为运行时数据结构，并生成该类所引用的java.lang.Class对象，作为在方法区该类的数据访问入口。数组类由虚拟机直接创建，不通过类加载器创建</code></li><li>连接 <code>连接分为验证、准备、解析，对二进制数据进行内存结构化</code><ul><li>验证 <code>主要对class二进制文件规范进行校验，确保加载的正确性，主要包括 文件格式验证、元数据验证、字节码验证、符号引用验证</code> </li><li>准备 <code>为类静态变量信息进行内存分配，开辟空间并初始化内存为0值</code></li><li>解析 <code>解析类、接口、字段、类方法、接口方法（私有）、方法类型、方法句柄，符号引用转化为直接引用，直接执行指针地址</code></li></ul></li><li>初始化 <code>为所使用的类等信息进行构造、初始化等操作（static），生成类构造器&lt;clinit&gt;()方法，合并类static变量和语句块，执行&lt;clinit&gt;()方法</code></li></ul><p>对于类加载信息，在hotspot虚拟机中将放置于方法区中（JVM规范没有规定具体存放位置。</p><p>除了主动使用情况外，还存在被动使用情况，这不会触发<code>初始化</code>行为。</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public final  static String str &#x3D; &quot;A&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(A.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>A.str</code> 的调用仅触发加载和连接。由于所调用的字符串常量，在编译阶段以在常量池中，因此不需要对变量进行初始化。</p><h1 id="二、运行时内存结构"><a href="#二、运行时内存结构" class="headerlink" title="二、运行时内存结构"></a>二、运行时内存结构</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24835/47BC61AD09484979BCD5FC76A23A8509"  alt="image"></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要负责长期使用的一些信息：</p><ul><li>常量池</li><li>构造方法</li><li>全局变量</li><li>代码指令</li><li>类信息（类名、修饰符、字段描述、方法描述等）</li><li>JIT编译后的代码</li><li>反射动态生成的Class信息</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="/" class="lazyload" data-src="https://note.youdao.com/src/7D09DE78B3DB4A7AACD4E9C5BD2A8F04"  alt="image"></p><p>堆区域是Java虚拟机中所管理最大的区域，同时也是垃圾回收器主要回收的目标。</p><p>为了方便进行回收，在分代回收算法中，虚拟机对堆又进行了分配，主要包括：</p><ol><li>新生代（年轻代）中 from Survivor、to Survivor、eden 区域其中各比例 1 : 1 : 8。负责周期短的对象</li><li>老年代</li><li>以及在方法区中的永生代</li></ol><h2 id="虚拟机栈（线程私有）"><a href="#虚拟机栈（线程私有）" class="headerlink" title="虚拟机栈（线程私有）"></a>虚拟机栈（线程私有）</h2><p>栈内存是线程私有，生命周期和线程一致。</p><ol><li>栈帧（会有多个栈帧，每个方法将产生一个栈帧）</li><li>局部变量表</li><li>操作数栈</li><li>方法返回值<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2></li></ol><p>和虚拟机栈差不都，用于C/C++层执行</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>也是线程私有，用于保存当前线程执行的内存地址，方便在多线程间的切换，状态恢复</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>除此之外在JDK1.4后还存在<code>直接内存</code>区域，该区域独立于堆外，可以直接操作内核态（由于需要内核空间支持，因此分配成本也大），如果需要频繁访问IO，可以减少堆外内存复制到内存内容进行磁盘的操作，另外扩大了JVM内存，目前可以通过NIO中DirectByteBuffer直接进行分配 </p><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>在Java 中线程是虚拟机运行的基础执行单位，在同一时间允许运行多线程执行（不考虑时间片）。为了应对多线程共享数据行为，Java使用了<code>JMM</code>控制多线程通信。</p><p>基于此在原内存模式上，又可以分为主内存和工作内存。之前<code>堆</code>、<code>程序计数器</code>、<code>方法区</code>内存区域属于主内存，而在<code>栈</code>中的栈帧结构属于线程私有的工作内存。</p><p>。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24894/9D552B0BC4714C1A9B5FFE77C2A4A86D"  alt="image"></p><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>为了便于理解Java的多线程特点，我们需要从底层上去理解这种工作模式的起源。</p><p>在现代的多核CPU执行速度上，是远高于内存、存储等IO设备的处理速率，为了缓和这种速度差矛盾，CPU上引入高速缓存（仅对单CPU核可见），方便将数据结果放到缓存中，以被后续被该CPU核调用，这造成主内存和CPU缓存间隔。由于每个CPU都存在仅自身可见的缓存，这就极易造成当其中单个变量发生变化时，对于其他CPU的缓存无法得到及时的更新，造成脏数据。</p><p>因此为了解决这种矛盾，官方提出了 缓存一致性协议，对于这类协议有 MESI、MSI、MOSI等。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24925/560288F7626F428BAC6EB8D90F958699"  alt="image"></p><p>因此在之后CPU执行计算的流程：</p><ul><li>程序和数据加载到主内存</li><li>指令或数据被加载到CPU高速缓存</li><li>CPU执行指令并将结果写入高速缓存</li><li>高速缓存中的数据写回主内存</li></ul><p>在每次高速缓存和主内存的交互中，都需要借助缓存一致性操作进行更新读取（加载赋值写回）。</p><p>在以上的一致性的基础上，解决了数据对其他CPU可见性问题，但是多线程的处理还涉及到工作流程的问题，相同的执行流程下，不同的执行顺序会导致不同结果。</p><h3 id="JMM控制"><a href="#JMM控制" class="headerlink" title="JMM控制"></a>JMM控制</h3><p>基于Java 工作内存和主内存的CPU一样的结构。Java使用JMM控制两者之间的交互。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25218/WEBRESOURCEa083a188f4c3cfc6a69c09495c9fc466"  alt="image.png"></p><p>本例中，线程A和B共享变量X，当线程A和B进行通信时，线程A将变量X从工作内存刷新到主内存中X，通过JMM通知线程B刷新变量X，线程B到主内存中读取变量X更新到工作内存中。两者的通信实质是通过JMM控制主内存和每个线程工作内存之间的交互，保证内存可见性。</p><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><p>在JMM中提供了8个操作来实现同步细节，这里面涉及三个操作角色。</p><p><code>主内存 &lt;-&gt; 工作内存 &lt;-&gt; 执行引擎</code></p><table><thead><tr><th>操作名</th><th>作用</th><th>操作目标</th></tr></thead><tbody><tr><td>read</td><td>把变量值从主内存读取到工作内存中，便于后面工作内存进行load</td><td>主内存</td></tr><tr><td>load</td><td>把主内存读取到的变量加载到工作内存变量副本中</td><td>工作内存</td></tr><tr><td>use</td><td>把工作内存中的变量传递给执行引擎，该操作发生在每当虚拟机在执行字节码指令需要变量时触发</td><td>工作内存</td></tr><tr><td>assign</td><td>将执行引擎获得的值赋值给工作内存，当执行引擎触发对变量赋值的指令时，触发该动作</td><td>工作内存</td></tr><tr><td>store</td><td>将工作内存中的变量值传送给主内存，以便于后面write操作</td><td>工作内存</td></tr><tr><td>write</td><td>把store得到的结果传送给主内存变量中</td><td>主内存</td></tr><tr><td>lock</td><td>将主内存中的一个变量标识为一个线程独占状态</td><td>主内存</td></tr><tr><td>unlock</td><td>把一个处于lock状态的变量释放，以便于被其他线程锁定</td><td>主内存</td></tr></tbody></table><p>这里面其中存在使用规则：</p><ul><li>read和load、store和write必须一起使用</li><li>assign操作后必须同步到主内存中</li><li>不允许工作内存无理由同步到主内存中（发生assign才行）</li><li>变量只能从主内存中诞生，不允许在工作内存中直接产生且进行assign操作</li><li>一个变量只允许一个线程执行lock操作，并且lock和unlock需要成对出现</li><li>如果发生lock操作，会清空线程工作内存中该变量的值（直接过期），当该线程执行引擎需要使用该变量值，必须重新操进行load和assign操作。</li><li>当一个变量执行unlock时，必须将锁定线程的变量store、write同步到主内存中</li></ul><h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><p>Java 和 C 不同，对于内存对象提供了自己的回收机制，通过一代一代垃圾回收机的改进，慢慢完善。</p><h2 id="对象存活计算"><a href="#对象存活计算" class="headerlink" title="对象存活计算"></a>对象存活计算</h2><p>在垃圾回收器之前，我们需要了解虚拟机是怎么判断一个对象是否仍然存活，什么时候需要被回收。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>比较简单的计数方案，为每个对象的对象头添加一个引用计数器，当引用时计数 + 1, 引用失效则 - 1，直到计数器为0，则表示<br>该对象已经失效。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>引用计数执行快，对于不想被GC打断的程序比较有利</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法解决相互循环引用问题</li><li>JDK1.2后存在对多种引用形式（软、弱、虚等引用），引用计数无法区分这些情况。</li></ul><h3 id="可达性分析（GC-Root）"><a href="#可达性分析（GC-Root）" class="headerlink" title="可达性分析（GC Root）"></a>可达性分析（GC Root）</h3><p>通过一系列名为“GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（用图论术语描述就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。在主流的商用程序语言中（Java、C#）,都是使用根搜索算法判定对象是否存活的。</p><p>可作为GC Roots的对象包括下面几种：</p><ol><li><p>虚拟机栈（栈帧中的本地变量表）中的引用的对象。<br><code>比较好理解为方法中所引用的对象，这些对象在堆中分配了地址空间，在虚拟机栈执行过程中，引用这些对象的地址引用，当完成方法的执行，当运行结束并且该对象生命周期结束，不再需要这些对象时，可以释放。这些对象通常在本地变量表中被记录，可以作为GC Root</code></p></li><li><p>方法区中的类静态属性引用的对象。<br><code>对于类中存在 static 的静态属性对象，该引用是存储在方法区中，生命周期可以在整个运行周期中，只能单独作为GC Root。</code></p></li><li><p>方法区中的常量引用的对象。<br><code>static final 所修饰的对象，这些对象也是被分配在方法区，生命周期可以在整个运行周期，可以作为GC Root</code></p></li><li><p>本地方法栈中JNI（Native方法）的引用的对象。</p></li></ol><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><p>主要将收集分成两个步骤：</p><ul><li>标记所有需要回收的对象</li><li>对所标记的对象进行回收</li></ul><p>该方案有两个缺点：</p><ul><li>标记清除效率不高，需要进行便利。</li><li>清除后空间碎片化不连续，无法充分利用剩余的空间，如果剩余空间不能满足所需要分配的对象，不得不在进行垃圾回收。</li></ul><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>对于之前算法的改进。</p><ul><li>将内存空间分配为两块均等的区域。</li><li>当发生对象内存分配时，在第一块区域进行分配</li><li>当第一块内存不足以再次分配对象时，将存活对象复制到第二区域并第一区域进行清理</li></ul><p>优点：</p><ul><li>不需要考虑内存碎片化问题</li><li>运行效率高，按堆顶指针顺序分配内存</li></ul><p>缺点：</p><ul><li>内存区域缩小一半</li><li>如果存活对象多时，则复制操作将频繁进行。</li></ul><h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>标记-整理是对复制和标记-清除的改进，在之前的标记-清除的基础上，不对标记对象进行清除而是整理，移动存活的对象，更新所移动对象的指针。</p><p>对于不同的算法所进行的整理方式不同：</p><ul><li>滑动顺序 <code>将对象滑动到堆一端，并退出垃圾，保持对象在堆中的先后顺序</code></li><li>线性顺序 <code>将所有有关系的对象排列一起</code></li><li>任意顺序 <code>没有任何联系随意排序</code></li></ul><h4 id="整理算法"><a href="#整理算法" class="headerlink" title="整理算法"></a>整理算法</h4><ul><li>双指针回收算法：简单回收快，但是会打乱对象原布局</li><li>Lisp2算法（滑动回收算法）：通过在对象头用一个额外的记录槽保存迁移后的地址</li><li>引线整理算法：可以在不引入额外空间开销的情况下实现滑动整理，但需要2次遍历堆，且遍历成本较高</li><li>单次遍历算法：滑动回收，实时计算出对象的转发地址而不需要额外的开销</li></ul><h2 id="内存分代"><a href="#内存分代" class="headerlink" title="内存分代"></a>内存分代</h2><p>在了解分代收集算法前，需要对内存分代有点了解。</p><p>出现内存分代主原因是新老内存对象并存，极易造成整块内存频繁的回收，回收收集需要遍历范围大，影响效率。</p><p>那怎么做分代？根据对象的存活时间看，静态变量、类信息存活时间长，而对于方法变量这些活跃变量存活时间段，因此根据这些不同的生成周期看，内存被分为几个区域：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25274/WEBRESOURCEefcf8bc9f941b7542b13ca528c69f59c"  alt="image.png"></p><ul><li>新生代<ul><li>一般位于堆中，包括eden 区，两个Survivor区域，这些区域通常保持 8 ：1 ： 1 比例。</li></ul></li><li>伊甸园区（eden） <code>对象被创建时，首先进入该区域，当进行垃圾回收后，幸存的对象进入Survivor区</code></li><li>Survivor区 <code>保存eden区域存活下来的对象</code><ul><li>Survivor 存在两个区域S0、S1, 这和所选择的回收算法有关，这一般是 复制算法，需要通过两个空间来换取回收的高效率，避免内存碎片。</li><li>两个区域始终会保持其中一个区域为空，当eden第一次发生回收，会被放置到 To Survivor 区域，同时另外一个From Survivor区域里面的对象也放置到To区域中，并情况From区域里面的内存，保持空状态，该区域会在内存不够时发生回收，并轮流保持一个区域为空。</li></ul></li><li>老年代 <ul><li>一般位于堆中</li></ul></li><li>永生代<ul><li>一般指方法区，永生区并不代表不发生回收，当进行Full GC 会对类卸载以及一些常量进行回收。 </li><li>JDK 1.8 后方法区改为元数据区</li></ul></li></ul><h3 id="GC模型分类"><a href="#GC模型分类" class="headerlink" title="GC模型分类"></a>GC模型分类</h3><p>针对不同分代中内存对象的特点，HotSpot中将GC分为三种模型：</p><ul><li>Minor GC: 作用于新生代，回收新生代中的垃圾，并且速度快且频繁，作为回收的主力。</li><li>Major GC: 作用于老年代，回收速度慢，一般伴随 Minor GC进行</li><li>Full GC: 作用于全部区域，包括堆、方法区（永久区）、直接内存，速度慢，需要停止工作线程，且时间较长。</li></ul><p>对于大部分对象而言在 Minor GC 回收中已经会被回收，但是仍然会存活部分的对象下来，这些存活下来的对象会被分配到 Survivor （S0、S1）下，如果Survivor 不足，则会通过空间分配担保将这些老对象分配到老年代中。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul><li>当发生Minor GC 时，JVM会检查老年代最大的连续空间是否大于新生代对象总空间</li><li>如果这个条件成立，那么MinorGC可以确保是安全的</li><li>如果不成立则JVM会查看<code>HandlePromotionFailure</code>设置值查看是否允许担保失败。<ul><li>若允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。<ul><li>如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；</li><li>如果小于，或者HandlePromotionFailure设置不允许冒险，那这时要改为进行一次Full GC</li></ul></li></ul></li></ul><h3 id="老年代变迁"><a href="#老年代变迁" class="headerlink" title="老年代变迁"></a>老年代变迁</h3><h4 id="大对象进入老年代"><a href="#大对象进入老年代" class="headerlink" title="大对象进入老年代"></a>大对象进入老年代</h4><p>对于大量连续内存空间的对象，如果进入新生代容易触发GC，在虚拟机配置中<code>-XX:PretenureSizeThreshold</code>，如果对象大于该分配值，这会直接进入老年代，避免Eden、Survivor发生大量的内存复制。</p><h4 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h4><p>为了便于识别对象存活周期，虚拟机为对象定义了一个对象年年计数器。</p><p>所有在新生代产生的对象，年龄从0开始计数，当每经过一笔Minor GC后仍然存活下来，并且Survivor有足够的空间容纳，则这些对象会被转移到Survivor中，对象年龄开始进入计数 1，而在只收每次Survivor经历Minor GC 后，都会递增该年龄，当达到最大年龄（-XX:PretenureSizeThreshold），则会即将该对象分配老年代中，该计数器失效。</p><h4 id="同年龄对象过多进入老年代"><a href="#同年龄对象过多进入老年代" class="headerlink" title="同年龄对象过多进入老年代"></a>同年龄对象过多进入老年代</h4><p>进入老年代，不仅是到指定年龄后进入，当Surivivor中相同年龄N所有对象的大小总和大于Survivor的一般的时候，那些年龄大于等于该年龄N会直接进入老年代。</p><h2 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h2><p>通常虚拟机并不是仅用一种收集器，而是搭配使用，具体场景有最佳的收集方式</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25227/WEBRESOURCEc8a492bd9240a8b9f888d42ec7d4c1d3"  alt="image.png"><br>Serial收集器是一个串行收集器，在JDK1.3.1前用于HotSpot新生代的收集。</p><p>特点：</p><ul><li>针对新生代进行回收</li><li>使用复制算法回收</li><li>单线程收集，因此执行时是“Stop The World”，暂停所有工作线程</li></ul><p>该收集器一般配合 Serial Old 收集器使用，当执行完新生代回收后，进行老年代收集</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25229/WEBRESOURCEb82d8908367b954334dbf62b2762e77c"  alt="image.png"></p><p>ParNew 收集器是Serial收集器多线程版本，依然是针对新生代的</p><p>特点：</p><ul><li>基本和Serial收集器一致，但是属于多线程版本</li><li>该收集器在多核中表现好，但是单核下会有额外的线程切换开销，性能反而比Serial收集器差些</li></ul><h3 id="Parallel-Scavenge收集器（“吞吐量优先”收集器）（新生代）"><a href="#Parallel-Scavenge收集器（“吞吐量优先”收集器）（新生代）" class="headerlink" title="Parallel Scavenge收集器（“吞吐量优先”收集器）（新生代）"></a>Parallel Scavenge收集器（“吞吐量优先”收集器）（新生代）</h3><p>特点：</p><ul><li>新生代收集器，并行多线程收集</li><li>使用复制算法</li><li>该收集器提升关注点在于提升吞吐量（ 用户代码运行时间 / (用户代码允许时间 + 垃圾收集时间) ），主要适用于后台运算多而交互不多的情况。</li></ul><h3 id="Serial-Old收集器（老年代）"><a href="#Serial-Old收集器（老年代）" class="headerlink" title="Serial Old收集器（老年代）"></a>Serial Old收集器（老年代）</h3><p>JDK1.5 及其之前 和 Parallel Scavenge 收集器搭配使用。通常是CMS收集器的后背方案，当CMS发生 Concurrent Mode Failure时进行备用。</p><p>特点：</p><ul><li>针对老年代</li><li>使用标记-复制算法，并进行压缩处理</li><li>单线程收集</li></ul><h3 id="Parallel-Old收集器（老年代）"><a href="#Parallel-Old收集器（老年代）" class="headerlink" title="Parallel Old收集器（老年代）"></a>Parallel Old收集器（老年代）</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25257/WEBRESOURCE0d0f167cf64d87385e6961600e65b133"  alt="image.png"></p><p>在JDK1.6及之后提到Serail Old 收集器</p><p>特点：</p><ul><li>注重吞吐量和CPU敏感场景</li><li>针对老年代</li><li>采用标记-整理算法</li><li>多线程垃圾搜集</li></ul><h3 id="CMS收集器（Concurrent-Mark-Sweep）"><a href="#CMS收集器（Concurrent-Mark-Sweep）" class="headerlink" title="CMS收集器（Concurrent Mark Sweep）"></a>CMS收集器（Concurrent Mark Sweep）</h3><p>基于 标记-清除 算法。</p><p>CMS收集器主要目的是以最短回收停顿时间为目标，注重于响应时间，需要良好的用户体验，真正基本实现了垃圾收集线程和用户线程同时工作要求</p><p>特点：</p><ul><li>基于 标记-清除 算法</li><li>并发多线程标记</li><li>主要以减少停顿时间为目标</li><li>方法垃圾回收和用户线程同时进行</li></ul><p>缺点：</p><ul><li>产生内存碎片</li></ul><p>CMS收集器流程比较麻烦，主要分为4个步骤：</p><ul><li>初始化标记（CMS initial mark）<code>执行 “Stop The World”，标记GC Root所关联的对象</code></li><li>并发标记（CMS concrrent mark）<code>进行GC Roots Tracing过程，可以和用户线程并发进行</code></li><li>重新标记（CMS remark）<code>执行“Stop The World”，再次判断标记期间产生的对象存活，修正因用户程序继续运行而导致标记产生变动的那一并发对象的标记记录。执行时间相对并发标记短</code></li><li>并发清除（CMS concurrent sweep）<code>清除对象，处理时间较长，但是可以和用户线并发执行</code></li></ul><h3 id="G1收集器（Garbage-First）"><a href="#G1收集器（Garbage-First）" class="headerlink" title="G1收集器（Garbage First）"></a>G1收集器（Garbage First）</h3><p>相对于CMS收集器，基于 标记-整理 算法，并且可以精确控制停顿。</p><p>G1将堆分成多个Region，可以通过<code>G1HeapRegionSize</code>进行参数数值，该值必须为2的幂，分区完成后启动将不会发生变化。</p><p>对于Region的区域主要分为：</p><ul><li>Eden regions(年轻代-Eden区) </li><li>Survivor regions(年轻代-Survivor区)</li><li>Old regions（老年代）</li><li>Humongous regions（巨型对象区域）<code>对于占用了Region区域50%以上对象分配区域</code></li><li>Free resgions（未分配区域，也会叫做可用分区）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于程序，我们不仅需要了解开发时所需要的内容，还需要了解程序运行时的环境状态，这样可以方便我们对整个运行环境的掌控和开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; class=&quot;lazyload&quot; data-src=&quot;http://note.youdao.com/yws/r
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>集合类-LinkedList</title>
    <link href="http://yoursite.com/2018/04/12/%E9%9B%86%E5%90%88%E7%B1%BB-LinkedList/"/>
    <id>http://yoursite.com/2018/04/12/%E9%9B%86%E5%90%88%E7%B1%BB-LinkedList/</id>
    <published>2018-04-11T16:28:50.000Z</published>
    <updated>2020-04-12T01:48:55.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、LinkedList-继承关系"><a href="#一、LinkedList-继承关系" class="headerlink" title="一、LinkedList 继承关系"></a>一、LinkedList 继承关系</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25595/WEBRESOURCEfff6eb2592da0a616935650f7a99fec8"  alt="image.png"></p><p>LinkedList 相对于 ArrayList 增加了 <code>Queue（队列）</code> 和 <code>Deque（双端队列）</code> 支持。</p><p>因此可以使用这两个结构特点上的行为。</p><h1 id="二、存储实现"><a href="#二、存储实现" class="headerlink" title="二、存储实现"></a>二、存储实现</h1><p>LinkedList 内部使用双端链表实现存储，分别维护两个字段入口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 顶部节点</span><br><span class="line">transient Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尾部节点</span><br><span class="line">transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>Node 内部实现了对上下两个节点的连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 当前存储的元素</span><br><span class="line">    E item;</span><br><span class="line">    &#x2F;&#x2F; 指向下一个节点</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    &#x2F;&#x2F; 指向前一个节点</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item &#x3D; element;</span><br><span class="line">        this.next &#x3D; next;</span><br><span class="line">        this.prev &#x3D; prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、添加元素"><a href="#三、添加元素" class="headerlink" title="三、添加元素"></a>三、添加元素</h1><p>对于集成了链表、队列、双端队列特点的结构。它提供了比较多的元素添加入口。</p><ul><li>add、addLast <code>尾部添加节点</code></li><li>push、offerFirst、addFirst <code>头部添加节点</code><h2 id="尾部添加节点-add、addLast"><a href="#尾部添加节点-add、addLast" class="headerlink" title="尾部添加节点 add、addLast"></a>尾部添加节点 add、addLast</h2></li></ul><p>两者动作实质一致，都是向尾部添加节点，实质都是<code>lnkLast(E e)</code> 实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    &#x2F;&#x2F; 临时节点</span><br><span class="line">    final Node&lt;E&gt; l &#x3D; last;</span><br><span class="line">    &#x2F;&#x2F; 新节点</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);</span><br><span class="line">    &#x2F;&#x2F; 将尾部节点指向新添加的节点</span><br><span class="line">    last &#x3D; newNode;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果之前尾部节点为空，则表示还未初始化</span><br><span class="line">    &#x2F;&#x2F;顶部节点，一起初始化了，否则当前新增节</span><br><span class="line">    &#x2F;&#x2F;点为之前最后节点的下一个节点。</span><br><span class="line">    if (l &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    &#x2F;&#x2F; 修改校验器</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做几个事情：</p><ul><li>检查当前尾部节点，如果为空，则当前节点作为唯一节点，初始化为首尾节点指针上。</li><li>如果不为空，则之前链表表示不为空，将当前尾部节点指针和之前的尾部节点的下一个节点指针指向新节点。</li></ul><h2 id="顶部添加节点-push、offerFirst、addFirst"><a href="#顶部添加节点-push、offerFirst、addFirst" class="headerlink" title="顶部添加节点 push、offerFirst、addFirst"></a>顶部添加节点 push、offerFirst、addFirst</h2><p>实质由<code>linkFirst</code>实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void linkFirst(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(null, e, f);</span><br><span class="line">    first &#x3D; newNode;</span><br><span class="line">    &#x2F;&#x2F; 和之前添加到尾部节点一样的原理，首位节</span><br><span class="line">    &#x2F;&#x2F;点指针如果其中一个为空，则表示当前链表</span><br><span class="line">    &#x2F;&#x2F;为空，直接将尾部节点指针指向当前节点，</span><br><span class="line">    &#x2F;&#x2F;否则将之前的首部节点的前一个节点指向新</span><br><span class="line">    &#x2F;&#x2F;节点。</span><br><span class="line">    if (f &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; newNode;</span><br><span class="line">    else</span><br><span class="line">        f.prev &#x3D; newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现基本和添加尾部节点一样，只是这里添加到首部节点</p><h2 id="指定位置插入"><a href="#指定位置插入" class="headerlink" title="指定位置插入"></a>指定位置插入</h2><p>除了默认的前后节点插入，还提供了指定位置的插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> public void add(int index, E element) &#123;</span><br><span class="line">     checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 如果刚好在最后节点插入</span><br><span class="line">     if (index &#x3D;&#x3D; size)</span><br><span class="line">         linkLast(element);</span><br><span class="line">     else</span><br><span class="line">         linkBefore(element, node(index));</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">     </span><br><span class="line">     final Node&lt;E&gt; pred &#x3D; succ.prev;</span><br><span class="line">     final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">     succ.prev &#x3D; newNode;</span><br><span class="line">     if (pred &#x3D;&#x3D; null)</span><br><span class="line">         &#x2F;&#x2F; 插入的节点的前节点如果为null，则表示该节点是头部节点</span><br><span class="line">         first &#x3D; newNode;</span><br><span class="line">     else</span><br><span class="line">         &#x2F;&#x2F; 插入上个节点之后</span><br><span class="line">         pred.next &#x3D; newNode;</span><br><span class="line">     size++;</span><br><span class="line">     modCount++;</span><br><span class="line"> &#125;    </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">     checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">     Object[] a &#x3D; c.toArray();</span><br><span class="line">     int numNew &#x3D; a.length;</span><br><span class="line">     &#x2F;&#x2F; 插入元素为空退出</span><br><span class="line">     if (numNew &#x3D;&#x3D; 0)</span><br><span class="line">         return false;</span><br><span class="line"></span><br><span class="line">     Node&lt;E&gt; pred, succ;</span><br><span class="line">     </span><br><span class="line">     if (index &#x3D;&#x3D; size) &#123;</span><br><span class="line">         &#x2F;&#x2F; 插入的位置刚好为末尾</span><br><span class="line">         succ &#x3D; null;</span><br><span class="line">         pred &#x3D; last;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 查询指定位置的节点</span><br><span class="line">         succ &#x3D; node(index);</span><br><span class="line">         pred &#x3D; succ.prev;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 将所有元素转化为链表，并添加到之前 </span><br><span class="line">     &#x2F;&#x2F;succ 链表节点的前一个节点</span><br><span class="line">     for (Object o : a) &#123;</span><br><span class="line">         E e &#x3D; (E) o;</span><br><span class="line">         Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);</span><br><span class="line">         if (pred &#x3D;&#x3D; null)</span><br><span class="line">             first &#x3D; newNode;</span><br><span class="line">         else</span><br><span class="line">             pred.next &#x3D; newNode;</span><br><span class="line">         pred &#x3D; newNode;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; succ &#x3D;&#x3D; null </span><br><span class="line">     &#x2F;&#x2F;表示之前插入的位置在最后一个节点后插入</span><br><span class="line">     &#x2F;&#x2F;，因此，新的末尾节点为所添加元素链表节</span><br><span class="line">     &#x2F;&#x2F;点最后一个即可，否则将index之前所获得</span><br><span class="line">     &#x2F;&#x2F;的元素添加到新增链表节点最后一个节点的</span><br><span class="line">     &#x2F;&#x2F;上一个节点，而最后一个节点的下一个节点</span><br><span class="line">     &#x2F;&#x2F;为之前index指向的节点</span><br><span class="line">     if (succ &#x3D;&#x3D; null) &#123;</span><br><span class="line">         last &#x3D; pred;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         pred.next &#x3D; succ;</span><br><span class="line">         succ.prev &#x3D; pred;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     size +&#x3D; numNew;</span><br><span class="line">     modCount++;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="四、修改元素"><a href="#四、修改元素" class="headerlink" title="四、修改元素"></a>四、修改元素</h1><p>节点设置目前只有 set 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> public E set(int index, E element) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查设置点是否在当前0~size范围内</span><br><span class="line">     checkElementIndex(index);</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 获取指定位置的元素节点，具体实现可以看获取元</span><br><span class="line">     &#x2F;&#x2F; 素。</span><br><span class="line">     Node&lt;E&gt; x &#x3D; node(index);</span><br><span class="line">     E oldVal &#x3D; x.item;</span><br><span class="line">     x.item &#x3D; element;</span><br><span class="line">     return oldVal;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">     &#x2F;&#x2F; 只执行一次二分查询</span><br><span class="line">     if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">         &#x2F;&#x2F; 如果所查询的位置index &lt; size &#x2F; 2，则从头部节点开始遍历到指定位置</span><br><span class="line">         Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">         for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">             x &#x3D; x.next;</span><br><span class="line">         return x;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       &#x2F;&#x2F; 如果所查询的位置index &gt; size &#x2F; 2，则从尾部节点开始遍历到指定位置</span><br><span class="line">         Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">         for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">             x &#x3D; x.prev;</span><br><span class="line">         return x;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>检查下标index是否溢出范围</li><li>查询指定位置的节点<ul><li>查询前将链表查询范围二分 0 - size /2 和 size / 2 -size 两段范围</li><li>如果所查询index &lt; 0 - size/2 范围内，则使用尾部节点开始进行遍历</li></ul></li><li>对所查询到的节点元素进行替换，并返回旧元素 </li></ul><h1 id="五、获取元素"><a href="#五、获取元素" class="headerlink" title="五、获取元素"></a>五、获取元素</h1><p>由于 LinkedList 结合了多种结构，因此也提供了多种获取节点的形式。</p><ul><li>get  <code>仅获取指定位置的元素，为空则返回null</code></li><li>poll、pollFirst <code>获取首部节点的元素，并将该元素从列表中移除，为空则返回null</code></li><li>pop、remove、removeFirst <code>获取首部节点的元素，并从列表中移除节点，如果元素为null则抛出 NoSuchElementException 异常</code></li><li>removeLast <code>相对于 removeFirst ，获取尾部节点的元素，并从列表中移除节点，如果元素为null则抛出 NoSuchElementException 异常</code></li><li>peek <code>仅获取首部节点，为空则返回null</code></li><li>element、getFirst <code>获取首部节点的元素，当获取的元素为null时，则会抛出 NoSuchElementException 异常。</code></li><li>getLast <code>相对于getFirst，获取尾部元素，为null则抛出 NoSuchElementException 异常</code></li></ul><p>相对于添加元素动作，获取元素入口较为多。这里提取一些重要的实现部分。</p><h2 id="指定位置获取"><a href="#指定位置获取" class="headerlink" title="指定位置获取"></a>指定位置获取</h2><p>不少方法在执行过程中，都需临时获取指定位置的元素节点，这里解析下 <code>Node&lt;E&gt; node(Int index)</code> 流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    &#x2F;&#x2F; 只执行一次二分查询</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果所查询的位置index &lt; size &#x2F; 2，则从头部节点开始遍历到指定位置</span><br><span class="line">        Node&lt;E&gt; x &#x3D; first;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; index; i++)</span><br><span class="line">            x &#x3D; x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果所查询的位置index &gt; size &#x2F; 2，则从尾部节点开始遍历到指定位置</span><br><span class="line">        Node&lt;E&gt; x &#x3D; last;</span><br><span class="line">        for (int i &#x3D; size - 1; i &gt; index; i--)</span><br><span class="line">            x &#x3D; x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了减少链表的遍历范围，因为LinkedList为双端链表结构，因此当 index &lt; size / 2 时，则从头部节点开始遍历，如果 index &gt;= size /2 则从尾部节点开始遍历。</p><h2 id="首部或者尾部获取"><a href="#首部或者尾部获取" class="headerlink" title="首部或者尾部获取"></a>首部或者尾部获取</h2><p>由于LinkedList 是双端链表，因此通过维护好的 <code>first</code> 和 <code>last</code> 可以分别获取头部和尾部的节点。不需要额外处理。</p><p>比如 poll、pollFirst 等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public E poll() &#123;</span><br><span class="line">    final Node&lt;E&gt; f &#x3D; first;</span><br><span class="line">    return (f &#x3D;&#x3D; null) ? null : unlinkFirst(f);</span><br><span class="line">&#125;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="六、删除元素"><a href="#六、删除元素" class="headerlink" title="六、删除元素"></a>六、删除元素</h1><p>删除元素涉及到堆元素的 <code>unlink</code> 动作，这同时也用于添加元素的 <code>pop</code>、<code>poll</code>等动作的处理。</p><p>unlink 用于对所有可能位置的节点进行剥离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">E unlink(Node&lt;E&gt; x) &#123;</span><br><span class="line">    </span><br><span class="line">    final E element &#x3D; x.item;</span><br><span class="line">    &#x2F;&#x2F; 获取当前元素的上下两个连接节点，便于后面将两个进行连接</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; x.next;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; x.prev;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果当前节点前一个节点不存在，则说明当前节点</span><br><span class="line">    &#x2F;&#x2F; 为头节点，因此将下一个节点作为头节点，否则将</span><br><span class="line">    &#x2F;&#x2F; 前一个节点的下一个节点指向x节点的下一个节点</span><br><span class="line">    if (prev &#x3D;&#x3D; null) &#123;</span><br><span class="line">        first &#x3D; next;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        prev.next &#x3D; next;</span><br><span class="line">        x.prev &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果下一个节点为空说明当前x节点为尾节点，否则将连接x下一个节点的前一个节点为x的上一个节点</span><br><span class="line">    if (next &#x3D;&#x3D; null) &#123;</span><br><span class="line">        last &#x3D; prev;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next.prev &#x3D; prev;</span><br><span class="line">        x.next &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private E unlinkFirst(Node&lt;E&gt; f) &#123;</span><br><span class="line">    &#x2F;&#x2F; 因为默认删除节点是头部节点，因此只要考虑下一个节点的上一个节点改为null即可，考虑first、last情况，如果为空，则表示该节点又为尾部节点。</span><br><span class="line">    final E element &#x3D; f.item;</span><br><span class="line">    final Node&lt;E&gt; next &#x3D; f.next;</span><br><span class="line">    f.item &#x3D; null;</span><br><span class="line">    f.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    first &#x3D; next;</span><br><span class="line">    if (next &#x3D;&#x3D; null)</span><br><span class="line">        last &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        next.prev &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private E unlinkLast(Node&lt;E&gt; l) &#123;</span><br><span class="line">    </span><br><span class="line">    final E element &#x3D; l.item;</span><br><span class="line">    final Node&lt;E&gt; prev &#x3D; l.prev;</span><br><span class="line">    l.item &#x3D; null;</span><br><span class="line">    l.prev &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">    last &#x3D; prev;</span><br><span class="line">    if (prev &#x3D;&#x3D; null)</span><br><span class="line">        first &#x3D; null;</span><br><span class="line">    else</span><br><span class="line">        prev.next &#x3D; null;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    return element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、没有扩容机制"><a href="#七、没有扩容机制" class="headerlink" title="七、没有扩容机制"></a>七、没有扩容机制</h1><p>因为LinkedList为链表结构，因此不需要进行扩展，当产生新的元素，即产生一个新的链表节点加入到链表中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、LinkedList-继承关系&quot;&gt;&lt;a href=&quot;#一、LinkedList-继承关系&quot; class=&quot;headerlink&quot; title=&quot;一、LinkedList 继承关系&quot;&gt;&lt;/a&gt;一、LinkedList 继承关系&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>集合类-ArrayList</title>
    <link href="http://yoursite.com/2018/04/11/%E9%9B%86%E5%90%88%E7%B1%BB-ArrayList/"/>
    <id>http://yoursite.com/2018/04/11/%E9%9B%86%E5%90%88%E7%B1%BB-ArrayList/</id>
    <published>2018-04-10T16:45:28.000Z</published>
    <updated>2020-04-11T16:29:57.322Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList 应该是我们最常用的一种列表工具。但是对于内部实现一直没做很深的了解，今天开始对集合类进行整理。</p><h1 id="一、ArrayList的继承关系"><a href="#一、ArrayList的继承关系" class="headerlink" title="一、ArrayList的继承关系"></a>一、ArrayList的继承关系</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25440/WEBRESOURCE092cdc46fd6b04854cf6351d94600d56"  alt="image.png"></p><p>Collection的基础容器，负责根据元素的增、删、查、迭代能力描述。</p><p>List容器在Collection容器能力基础上，扩展出列表元素下标方面功能，通过下标可以对元素进行增、删、查能力</p><p>ArrayList 基于 List 和 Collection 实现了相关内容。 </p><h1 id="二、ArrayList的基本情况"><a href="#二、ArrayList的基本情况" class="headerlink" title="二、ArrayList的基本情况"></a>二、ArrayList的基本情况</h1><ul><li>ArrayList 内部实质是通过一个数组进行存储，因此拥有数组的基本特点。对于查询、读取有先天的高效优势。</li><li>ArrayList 具有有序性、可元素重复、可添加空元素特点。</li><li>ArrayList 数组非线程安全</li><li>ArrayList 的扩容基于创建新容量数组，并进行迁移，扩容成本高，因此不适合用于频繁增删操作的场景。</li></ul><h1 id="三、容器初始化"><a href="#三、容器初始化" class="headerlink" title="三、容器初始化"></a>三、容器初始化</h1><p>ArrayList 提供了三种初始化构造，应对三种不同的构造情况。</p><h2 id="指定容量初始化"><a href="#指定容量初始化" class="headerlink" title="指定容量初始化"></a>指定容量初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">transient Object[] elementData</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">     if (initialCapacity &gt; 0) &#123;</span><br><span class="line">         this.elementData &#x3D; new Object[initialCapacity];</span><br><span class="line">     &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当对构造进行了指定容量的构造：</p><ul><li>当容量值 &gt; 0 则直接初始化内部的存储数组 elementData</li><li>如果指定为0，则使用默认的空数组常量 EMPTYO_ELEMENTDATA（默认长度为0）</li><li>如果 &lt; 0 则抛出异常</li></ul><h2 id="传输初始化容器对象"><a href="#传输初始化容器对象" class="headerlink" title="传输初始化容器对象"></a>传输初始化容器对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData &#x3D; c.toArray();</span><br><span class="line">    if ((size &#x3D; elementData.length) !&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() !&#x3D; Object[].class)</span><br><span class="line">            elementData &#x3D; Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; replace with empty array.</span><br><span class="line">        this.elementData &#x3D; EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>直接将容器对象转化为数组</li><li>如果传入容器中存在元素，则直接初始化该容器数量的数组长度，和所传入的元素数量保持一致，并且将该容器中的数据存入。</li><li>如果传入容器中数量为空，则使用默认空数组 EMPTY_ELEMENTDATA 初始化（默认长度为0）</li></ul><h2 id="无构造参数初始化"><a href="#无构造参数初始化" class="headerlink" title="无构造参数初始化"></a>无构造参数初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">      this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>使用默认空数组（0长度）初始化数组</p><h1 id="四、容器的扩容"><a href="#四、容器的扩容" class="headerlink" title="四、容器的扩容"></a>四、容器的扩容</h1><p>扩容现象，一般会发生在对容器进行元素添加时，我们从add入手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">     &#x2F;&#x2F; 执行容量确认，size 为当前 elementData 存储数据长度，这里因为只添加一个元素，因此只增加一个元素（size + 1)</span><br><span class="line">     ensureCapacityInternal(size + 1); </span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 将元素添加到数组中</span><br><span class="line">     elementData[size++] &#x3D; e;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果之前是通过无参构造产生的空数据数组，则进行新的数组容器的初始化，minCapactity 为当前实际所需要的数组长度，这里 DEFAULT_CAPACITY 为 10， 因此最少初次初始化为10个容量长度。</span><br><span class="line">     if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">         minCapacity &#x3D; Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 执行数组扩容</span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">     &#x2F;&#x2F; 当数组容器发生扩容，内部元素发生变化时都将进行变化。当执行ArrayList 增删改查事务过程中，不允许对改值进行变更（也就是再此过程中不允许其他人对容器进行这些动作），否则将抛出 ConcurrentModificationException 异常</span><br><span class="line">     modCount++;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 确保每次申请容量要大于当前容量，否则不进行扩充</span><br><span class="line">     if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">         grow(minCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">     int oldCapacity &#x3D; elementData.length;</span><br><span class="line">     &#x2F;&#x2F; 新增容量为 原来容量 + (原来容量 &#x2F; 2)，为原来的 1.5 倍</span><br><span class="line">     int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 确保最少扩充容量为当前所要求的刚好的容量，最少为10</span><br><span class="line">     if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">         newCapacity &#x3D; minCapacity;</span><br><span class="line">         </span><br><span class="line">     &#x2F;&#x2F; 处理最大容量的边界情况。  </span><br><span class="line">     if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">         newCapacity &#x3D; hugeCapacity(minCapacity);</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 扩容数组</span><br><span class="line">     elementData &#x3D; Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"> &#125;    </span><br><span class="line"> </span><br><span class="line"> private static int hugeCapacity(int minCapacity) &#123;</span><br><span class="line">     if (minCapacity &lt; 0) &#x2F;&#x2F; overflow</span><br><span class="line">         throw new OutOfMemoryError();</span><br><span class="line">     return (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">         Integer.MAX_VALUE :</span><br><span class="line">         MAX_ARRAY_SIZE;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过以上扩容流程可以得知：</p><ul><li>当初次初始化为空构造（未指定容量或指定传入容器）时，则在下次触发扩容时（添加元素），默认最少扩容的长度为10，采用了懒初始化。</li><li>如果已经指定了初始化容量（包括初始化一个默认容器）时，则每次增长容量为原来的1.5倍</li><li>只有所申请的容量超过当前数组容器长度时，才会触发下次扩容。</li></ul><h1 id="四、关于ConcurrentModificationException异常"><a href="#四、关于ConcurrentModificationException异常" class="headerlink" title="四、关于ConcurrentModificationException异常"></a>四、关于ConcurrentModificationException异常</h1><p>在之前的扩容中，我们发现在每次对容器的增删改等操作上，只要对容器内容或者长度有变化的操作，都会出现 <code>modCount</code>，如果再次过程中，我们同时又对这个列表进行其他的操作（比如在其他异步中执行迭代器遍历），则会发生关于ConcurrentModificationException异常。这里我们通过一个例子来复线这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       List&lt;Integer&gt; arrayList &#x3D; new ArrayList&lt;&gt;(Arrays.asList(0,1,2,3,4));</span><br><span class="line">       for(Iterator&lt;Integer&gt; iterator &#x3D; arrayList.iterator(); iterator.hasNext();) &#123;</span><br><span class="line">           if(iterator.next() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">               arrayList.remove(3);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当进行迭代过程中，执行到1时，将3已经从列表中移除。这时候由于列表的变化会导致整个遍历的目标列表的不稳定，如果继续执行则会导致和我们预期的结果不一致。</p><p>因此为了防止这个情况出现，我们在每次对容器列表发生变化时维护一个状态值，当且我们在迭代时，每次都需要对该状态版本进行比对，是否和之前一致，否则执行快速失败，抛出异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ArrayList 应该是我们最常用的一种列表工具。但是对于内部实现一直没做很深的了解，今天开始对集合类进行整理。&lt;/p&gt;
&lt;h1 id=&quot;一、ArrayList的继承关系&quot;&gt;&lt;a href=&quot;#一、ArrayList的继承关系&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Repo操作</title>
    <link href="http://yoursite.com/2018/03/03/Repo%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/03/03/Repo%E6%93%8D%E4%BD%9C/</id>
    <published>2018-03-02T18:42:18.000Z</published>
    <updated>2020-04-12T18:45:22.060Z</updated>
    
    <content type="html"><![CDATA[<p>最近在阅读一些Android代码的时候，发现不怎么利索，有些代码在SDK中没有，缺胳膊少腿的不好前后理解，因此不得不将整个项目弄下来以备后需。</p><p>因为Android本身项目比较庞大，Google将项目分成多个Git项目，为了方便对整体项目进行管理，Google 整出了一个 repo 工具进行辅助。</p><p>今天对这工具做下记录，也方便后面对多项目的管理，文章上也不可能覆盖全部配置，这里仅简单记录下我自己常用的，具体想要详细的，可以参考：</p><p><a href="https://gerrit.googlesource.com/git-repo/" target="_blank" rel="noopener">https://gerrit.googlesource.com/git-repo/</a></p><h1 id="一、配置文件-manifest"><a href="#一、配置文件-manifest" class="headerlink" title="一、配置文件 manifest"></a>一、配置文件 manifest</h1><p>manifest 是repo比较核心的一个内容，repo是根据manifest所提供的配置和执行参数进行执行的，因此从manifest的配置开始。</p><p>repo 在init后会在工作目录下产生一个<code>.repo</code>隐藏文件夹，manifest的配置文件尽在这文件夹下（如果没有在引入<code>&lt;include /&gt;</code>外部文件的话）。</p><p>偷懒个，这里以Google Android 源码的repo配置文件为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">    &lt;remote </span><br><span class="line">        name&#x3D;&quot;asop&quot;</span><br><span class="line">        fetch&#x3D;&quot;https:&#x2F;&#x2F;android.googlesource.com&quot;</span><br><span class="line">        review&#x3D;&quot;android-review.googlesource.com&quot;</span><br><span class="line">        revision&#x3D;&quot;refs&#x2F;tags&#x2F;android-7.1.1_r6&quot; &#x2F;&gt;</span><br><span class="line">    &lt;default </span><br><span class="line">        revision&#x3D;&quot;refs&#x2F;tags&#x2F;android-8.1.0_r18&quot;</span><br><span class="line">        remote&#x3D;&quot;asop&quot;</span><br><span class="line">        sync-j&#x3D;&quot;4&quot; &#x2F;&gt;</span><br><span class="line">    &lt;project path&#x3D;&quot;build&#x2F;make&quot; name&#x3D;&quot;platform&#x2F;build&quot; groups&#x3D;&quot;pdk&quot; &gt;</span><br><span class="line">        &lt;copyfile src&#x3D;&quot;core&#x2F;root.mk&quot; dest&#x3D;&quot;Makefile&quot; &#x2F;&gt;</span><br><span class="line">        &lt;linkfile src&#x3D;&quot;CleanSpec.mk&quot; dest&#x3D;&quot;build&#x2F;CleanSpec.mk&quot; &#x2F;&gt;</span><br><span class="line">        &lt;linkfile src&#x3D;&quot;buildspec.mk.default&quot; dest&#x3D;&quot;build&#x2F;buildspec.mk.default&quot; &#x2F;&gt;</span><br><span class="line">        &lt;linkfile src&#x3D;&quot;core&quot; dest&#x3D;&quot;build&#x2F;core&quot; &#x2F;&gt;</span><br><span class="line">        &lt;linkfile src&#x3D;&quot;envsetup.sh&quot; dest&#x3D;&quot;build&#x2F;envsetup.sh&quot; &#x2F;&gt;</span><br><span class="line">        &lt;linkfile src&#x3D;&quot;target&quot; dest&#x3D;&quot;build&#x2F;target&quot; &#x2F;&gt;</span><br><span class="line">        &lt;linkfile src&#x3D;&quot;tools&quot; dest&#x3D;&quot;build&#x2F;tools&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;project&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure><h2 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h2><p>用于配置项目下载索引，如果项目存在于多个服务器下，可以配置多个 remote 。</p><ul><li>name <code>远程服务器名字</code></li><li>fetch <code>项目地址前缀地址部分（包括https:\\、http:\\ 描述），后面配合&lt;project&gt; name 属性使用，默认组成 ${remote_fetch}/${project_name}.git 地址</code><ul><li>fetch 可以设置为 “..”，表示使用 repo -u 地址 下所设置的地址 </li></ul></li><li>review <code>用于配置Gerrit代码审核服务器地址，执行 repo upload 时需要上传该地址，如果没有用到 upload 命令，可以忽略</code></li><li>alias <code>远程服务器的别名，和name区别是，name在配置中是唯一的，alias可以重名</code></li></ul><h2 id="default"><a href="#default" class="headerlink" title="default"></a>default</h2><p>设置项目默认属性值，用于在没有指定属性值时的缺省。</p><ul><li>remote <code>从之前配置的 remote 配置项中选取一个 name 填写，指定默认执行的一个git服务器</code></li><li>revision <code>指定默认git分支名字，比如 master、ref/heads/master</code></li><li>sync_j <code>设置一个数字，表示在 repo sync 中默认可以并行执行的数量</code></li><li>sync_c <code>设置一个boolean，true 则表示只同步指定的分支，不拉取其他分支内容</code></li><li>sync_s <code>设置一个boolean，true 则表示会同步其他项目下的关联子项目</code></li></ul><h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>设置需要 clone 的 git 项目</p><ul><li><p>name <code>项目唯一标识</code></p><ul><li>名字需要用于标识项目URL  <code>${remote_fetch}/${project_name}.git</code></li></ul></li><li><p>path <code>配置 sync 代码存放的本地目录（路径），如果没指定，则以在当前目录下使用name创建一个子目录存储</code></p></li><li><p>remote <code>指定拉取的服务器，从之前配置的 remte 中选取一个填写（填写name）</code></p></li><li><p>groups <code>配置项目所属project的group，可以进行多个配置，用“,”进行分隔</code></p><ul><li>默认保留 <code>all</code>、<code>notdefault</code> 两个组，所有项目默认属于 <code>all</code> 组，而配置 <code>-notdefault</code> 的 project 项目则默认不被 repo sync 执行，除非执行时显示指定分组 <code>repo sync -g all,-notdefault</code></li><li>默认属于以 <code>name</code>、<code>path</code> 为命名的分组，分组的命名格式分别为 <code>name:${name}</code>、<code>path:${path}</code> </li><li>该分组可以用于 <code>repo</code> 参数 <code>-g group名</code> 配置，用逗号隔开多个分组。（<code>repo init -g xxx</code>、<code>repo sync -g xxx</code>）</li></ul></li><li><p>sync_c <code>设置一个boolean，true 则表示只同步指定的分支，不拉取其他分支内容</code></p></li><li><p>sync_s <code>设置一个boolean，true 则表示会同步其他项目下的关联子项目</code></p></li><li><p>upstream <code>在哪个git分支可以找到一个SHA1。用于同步revision锁定的manifest(-c 模式)。该模式可以避免同步整个ref空间。</code></p></li><li><p>annotation <code>可以配置多个，格式为 name-value 格式，在 repo forall 会作为环境变量导入</code></p></li></ul><h3 id="额外的一些子配置"><a href="#额外的一些子配置" class="headerlink" title="额外的一些子配置"></a>额外的一些子配置</h3><p>为了方便对项目拉取后的管理，上面额外做了些管理配置。</p><ul><li>copyfile  <code>对文件进行复制操作，src为原文件，dest 为目的文件</code></li><li>linkfile  <code>对文件进行软连接，src为原文件，dest为目的文件</code></li></ul><p>更多配置可以看<a href="https://gerrit.googlesource.com/git-repo/+/HEAD/docs/manifest-format.md" target="_blank" rel="noopener">这里</a></p><h2 id="include"><a href="#include" class="headerlink" title="include"></a>include</h2><p>include 用于引入外部文件配置，默认读取的相对读取路径为 <code>.repo/manifests</code> 文件夹下的文件。</p><h2 id="remove-project"><a href="#remove-project" class="headerlink" title="remove-project"></a>remove-project</h2><p>remove-project 这个标签用于声明对所配置的 project 废除声明，使用比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;remove-project </span><br><span class="line">    name&#x3D;&quot;a&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>这个标签常用于<code>local_manifest</code> 配置下，关于这个机制下面说。</p><h2 id="manifest-的加载优先级"><a href="#manifest-的加载优先级" class="headerlink" title="manifest 的加载优先级"></a>manifest 的加载优先级</h2><p>对于 manifest 配置加载，repo 有一套优先级机制。</p><ul><li>如果<code>.repo</code>下存在<code>local_manifest.xml</code>（该方案已经过期，目前推荐直接在<code>.repo/local_manifests/</code>下声明本地配置文件），则会执行该配置文件，<code>local_manifest</code>所配置的内容不能喝<code>manifest</code>的配置重复否则将产生 <code>fatal: duplicate path xxx in xxx.xml</code> 异常，如果需要修改配置，则参照先调用<code>&lt;remove-project&gt;</code> 移除相关<code>project</code>配置 。</li><li>如果存在<code>.repo/local_manifests/</code>文件夹，并且该文件夹下存在相关配置文件，会按照字母排序顺序，一一执行<code>local_manifests</code>文件夹下的配置。</li></ul><p>该套机制是便于本地调试，避免改动需要上传的远程配置文件。这里直接通过对本地配置文件的调整，达成调试的配置要求。</p><h1 id="二、repo指令"><a href="#二、repo指令" class="headerlink" title="二、repo指令"></a>二、repo指令</h1><h2 id="h"><a href="#h" class="headerlink" title="-h"></a>-h</h2><p>这是个help 参数，对于有任何不明白的地方只要在指令后加上该参数，就会列出对应的帮助目录。</p><p>以下的指令帮助信息也多是来自于此，因此这里也只是罗列下常用到的参数。</p><h2 id="repo-init"><a href="#repo-init" class="headerlink" title="repo init"></a>repo init</h2><p>repo 项目必须要通过 <code>repo init -u 配置文件地址</code> 进行项目初始化。（<code>-u</code> 是必须要携带的参数）</p><p>这里所说的配置文件指的是一个manifest配置仓库地址（git 仓库），在该项目下需要存在一个命名为 <code>default.xml</code> 的配置文件（默认名字，可以通过 -m 指定其他拉取配置文件明），该文件遵守 <code>manifest</code> 配置形式。</p><p>具体配置例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">    &lt;remote</span><br><span class="line">        name&#x3D;&quot;rx&quot;</span><br><span class="line">        fetch&#x3D;&quot;https:&#x2F;&#x2F;github.com&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;default</span><br><span class="line">        remote&#x3D;&quot;rx&quot;</span><br><span class="line">        revision&#x3D;&quot;master&quot;</span><br><span class="line">        sync-j&#x3D;&quot;1&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;project</span><br><span class="line">        name&#x3D;&quot;ReactiveX&#x2F;RxJava&quot;</span><br><span class="line">        group&#x3D;&quot;android,rx&quot;</span><br><span class="line">        path&#x3D;&quot;lib&#x2F;RxJava&quot; </span><br><span class="line">        revision&#x3D;&quot;3.x&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;project</span><br><span class="line">        name&#x3D;&quot;ReactiveX&#x2F;RxAndroid&quot;</span><br><span class="line">        group&#x3D;&quot;android,rx&quot;</span><br><span class="line">        path&#x3D;&quot;lib&#x2F;RxAndroid&quot;</span><br><span class="line">        revision&#x3D;&quot;3.x&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;manifest&gt;</span><br></pre></td></tr></table></figure><p>其他<code>init</code> 配置参数有：</p><ul><li>-b <code>指定manifest配置文件仓库分支，不指定默认为master</code></li><li>-m <code>指定需要拉取的manifest配置文件明，不指定默认为 default.xml</code></li><li>–depth <code>指定拉取项目传递依赖的深度，如果只是查看当前项目指定为1，避免拉取时间过长，格式为 --depth=1</code></li><li>–repo-url <code>指定repo 工具的下载地址，在初始化项目过程中，需要相关下载repo工具相关依赖文件，如果没有梯子，可以换下国内镜像地址，格式为 --repo-url=URL</code></li><li>–no-repo-verify <code>不需要验证所下载 repo 工具代码，如果使用了 --repo-url 最好加上这个参数</code></li></ul><h2 id="repo-sync"><a href="#repo-sync" class="headerlink" title="repo sync"></a>repo sync</h2><p>根据 manifest 配置文件开始初始化项目（触发项目clone）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo sync #正常使用不需要器参数即可执行</span><br></pre></td></tr></table></figure><p>提供的参数配置有：</p><ul><li>-d <code>项目回退到manifest指定分支</code></li><li>-m <code>指定sync时所根据的manifest文件</code></li><li>-t <code>指定使用tag下的manifest配置文件</code></li><li>-f <code>忽略执行中某个项目的异常，强制进行下一个项目</code></li><li>–force-sync <code>会强制更新覆盖已存在的子项目</code></li></ul><h2 id="repo-start"><a href="#repo-start" class="headerlink" title="repo start"></a>repo start</h2><p>创建一个新开发的分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 创建新分支用于修改所有子项目</span><br><span class="line">repo start new_branch_name --all </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 创建一个包含 project1、project2 新分支 </span><br><span class="line">repo start new_branch_name [project1 project2]</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26658/WEBRESOURCEf22cfcfd735c6086b708802c8f5c8916"  alt="image.png"></p><h2 id="repo-upload"><a href="#repo-upload" class="headerlink" title="repo upload"></a>repo upload</h2><p>将代码提交到 <code>manifest</code> 指定的 review 的 Gerrit 服务器。</p><h2 id="repo-forall"><a href="#repo-forall" class="headerlink" title="repo forall"></a>repo forall</h2><p>这个命令比较有意思，是用于对所有子项目进行命令遍历执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo forall -c git pull</span><br></pre></td></tr></table></figure><p>以上是对所有子项目执行<code>git pull</code>命令</p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul><li>repo status <code>展示修改状态</code></li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26660/WEBRESOURCE3be5a56dbef660afd637aee125232c70"  alt="image.png"></p><ul><li>repo braches <code>展示当前分支情况</code></li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26656/WEBRESOURCE0daebbc139f12a5e1e818566a0f0237d"  alt="image.png"></p><ul><li>repo diff <code>展示内容修改上的差异</code></li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26665/WEBRESOURCE4b9ee93e1414dafa201e39c5187cdfde"  alt="image.png"></p><ul><li>repo prune <code>移除过时分支</code></li></ul><h1 id="三、工作流程"><a href="#三、工作流程" class="headerlink" title="三、工作流程"></a>三、工作流程</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26678/WEBRESOURCE7ffcabfe12407b835e63d8486515bc39"  alt="image"></p><p>对于 repo 项目而言，repo 只负责对多个项目间 拉取、更新、分支创建和上传负责，对于在单个项目间git的行为，比如合并、本地提交、冲突解决等，都是还要依赖 git 单独命令的操作。</p><p>可以说如果影响到多个项目的操作，才是使用repo的时候，如果是对单个子项目的操作还是git，repo是对git多项目的封装。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在阅读一些Android代码的时候，发现不怎么利索，有些代码在SDK中没有，缺胳膊少腿的不好前后理解，因此不得不将整个项目弄下来以备后需。&lt;/p&gt;
&lt;p&gt;因为Android本身项目比较庞大，Google将项目分成多个Git项目，为了方便对整体项目进行管理，Google 
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Android 未捕获异常处理</title>
    <link href="http://yoursite.com/2016/05/15/Android%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2016/05/15/Android%E6%9C%AA%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2016-05-15T12:41:43.000Z</published>
    <updated>2020-04-10T12:43:47.076Z</updated>
    
    <content type="html"><![CDATA[<p>Java 在默认在线程中发生不可捕获异常时，如果不对异常进行处理，则会抛出异常，但是不会导致整个进程奔溃，这得益于异常退出JVM仅在一个线程栈中有效。而对于其他线程栈的执行来说是没有影响的。</p><p>但是在Java执行程序中，当异常发生在不同线程时，对于整个进程的返回值是不同的结果。</p><h1 id="Java-的异常表现"><a href="#Java-的异常表现" class="headerlink" title="Java 的异常表现"></a>Java 的异常表现</h1><p>当未捕获异常发生在<code>main</code>入口时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;throw main thread exception&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>控制台输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: throw main thread exception</span><br><span class="line">at com.bevis.java.example.ThrowableTest.main(ThrowableTest.java:24)</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>当异常发生在异步线程时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">     new Thread(() -&gt; &#123;</span><br><span class="line">         throw new RuntimeException(&quot;throw asynchronous thread exception&quot;);</span><br><span class="line">     &#125;).start();</span><br><span class="line">     try &#123;</span><br><span class="line">         Thread.sleep(4000);</span><br><span class="line">     &#125; catch (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     System.out.println(&quot;exit process&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>控制台输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.RuntimeException: throw asynchronous thread exception</span><br><span class="line">at com.bevis.java.example.ThrowableTest.lambda$main$0(ThrowableTest.java:7)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">exit process</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>对比以上结果，当由main入口进入的线程发生异常时，则进程退出状态码为1（异常状态），而异步线程则返回 0 （正常状态）。</p><h1 id="Android-的异常表现"><a href="#Android-的异常表现" class="headerlink" title="Android 的异常表现"></a>Android 的异常表现</h1><p>Android 中并不是终端程序，因此不能对比状态码，但是无论是在主线程或者异步线程下，都会发生App崩溃，并抛出异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2020-04-08 20:45:45.618 5200-5247&#x2F;com.bevis.test E&#x2F;AndroidRuntime: FATAL EXCEPTION: Thread-2</span><br><span class="line">    Process: com.bevis.test, PID: 5200</span><br><span class="line">    java.lang.RuntimeException: throw asynchronism thread exception</span><br><span class="line">        at com.bevis.test.MainActivity$onCreate$1$1.run(MainActivity.kt:25)</span><br></pre></td></tr></table></figure><h1 id="UncaughtExceptionHandler-捕获"><a href="#UncaughtExceptionHandler-捕获" class="headerlink" title="UncaughtExceptionHandler 捕获"></a>UncaughtExceptionHandler 捕获</h1><p><code>UncaughtExceptionHandler</code> 是Java平台提供的一套对未捕获异常的处理机制，对于在线程中所发生的未捕获异常，最终都将在这里面进行处理。如果未设置则通过对应线程的 <code>ThreadGroup</code> 进行处理。</p><p>对应 Android 和 Java 平台的不同表现，猜测是通过该拦截进行处理。</p><h2 id="ThreadGroup-的处理"><a href="#ThreadGroup-的处理" class="headerlink" title="ThreadGroup 的处理"></a>ThreadGroup 的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public</span><br><span class="line">class ThreadGroup implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">    ...</span><br><span class="line">    public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果 ThreadGroup 存在 parent ThreadGroup 则交由 parent 处理。否则由Thread.getDefaultUncaughtExceptionHandler 进行处理。在没有复写ThreadGroup方法的情况下，root ThreadGroup 最终还是由 getDefaultUncaughtExceptionHandler 进行处理</span><br><span class="line">        if (parent !&#x3D; null) &#123;</span><br><span class="line">            parent.uncaughtException(t, e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Thread.UncaughtExceptionHandler ueh &#x3D;</span><br><span class="line">                Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">            if (ueh !&#x3D; null) &#123;</span><br><span class="line">                ueh.uncaughtException(t, e);</span><br><span class="line">            &#125; else if (!(e instanceof ThreadDeath)) &#123;</span><br><span class="line">                System.err.print(&quot;Exception in thread \&quot;&quot;</span><br><span class="line">                                 + t.getName() + &quot;\&quot; &quot;);</span><br><span class="line">                e.printStackTrace(System.err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上可以得到，对应 root ThreadGroup最终处理该异常的还是 <code>Thread.getDefaultUncaughtExceptionHandler</code>。</p><p>通过Java程序获得，该对象为null  而 Android 则为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.internal.os.RuntimeInit$KillApplicationHandler@804b454</span><br></pre></td></tr></table></figure><h2 id="KillApplicationHandler"><a href="#KillApplicationHandler" class="headerlink" title="KillApplicationHandler"></a>KillApplicationHandler</h2><p><code>KillApplicationHandler</code> 主要处理三个工作：</p><ul><li>处理日志输出</li><li>通知AMS进行Applicatin Crash 处理</li><li>杀死App发生Crash的进程（多进程下其他进程不影响）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">   private static class LoggingHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">        public volatile boolean mTriggered &#x3D; false;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">            mTriggered &#x3D; true;</span><br><span class="line"></span><br><span class="line">            if (mCrashing) return;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 区分系统异常和普通异常，组装异常信息并抛出</span><br><span class="line">            if (mApplicationObject &#x3D;&#x3D; null &amp;&amp; (Process.SYSTEM_UID &#x3D;&#x3D; Process.myUid())) &#123;</span><br><span class="line">                Clog_e(TAG, &quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot; + t.getName(), e);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                StringBuilder message &#x3D; new StringBuilder();</span><br><span class="line">                message.append(&quot;FATAL EXCEPTION: &quot;).append(t.getName()).append(&quot;\n&quot;);</span><br><span class="line">                final String processName &#x3D; ActivityThread.currentProcessName();</span><br><span class="line">                if (processName !&#x3D; null) &#123;</span><br><span class="line">                    message.append(&quot;Process: &quot;).append(processName).append(&quot;, &quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                message.append(&quot;PID: &quot;).append(Process.myPid());</span><br><span class="line">                Clog_e(TAG, message.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static class KillApplicationHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line">        &#x2F;&#x2F; 作为异常日志输出</span><br><span class="line">        private final LoggingHandler mLoggingHandler;</span><br><span class="line"></span><br><span class="line">        public KillApplicationHandler(LoggingHandler loggingHandler) &#123;</span><br><span class="line">            this.mLoggingHandler &#x3D; Objects.requireNonNull(loggingHandler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void uncaughtException(Thread t, Throwable e) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                &#x2F;&#x2F; 调用 LoggingHandler 输出异常信息</span><br><span class="line">                ensureLogging(t, e);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 防止重复进入异常处理</span><br><span class="line">                if (mCrashing) return;</span><br><span class="line">                mCrashing &#x3D; true;</span><br><span class="line"></span><br><span class="line">                if (ActivityThread.currentActivityThread() !&#x3D; null) &#123;</span><br><span class="line">                    ActivityThread.currentActivityThread().stopProfiling();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 通知AMS Application崩溃处理</span><br><span class="line">                ActivityManager.getService().handleApplicationCrash(</span><br><span class="line">                        mApplicationObject, new ApplicationErrorReport.ParcelableCrashInfo(e));</span><br><span class="line">            &#125; catch (Throwable t2) &#123;</span><br><span class="line">                if (t2 instanceof DeadObjectException) &#123;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Clog_e(TAG, &quot;Error reporting crash&quot;, t2);</span><br><span class="line">                    &#125; catch (Throwable t3) &#123;</span><br><span class="line">                        &#x2F;&#x2F; Even Clog_e() fails!  Oh well.</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                &#x2F;&#x2F; 杀死进程（APP退出）</span><br><span class="line">                Process.killProcess(Process.myPid());</span><br><span class="line">                System.exit(10);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void ensureLogging(Thread t, Throwable e) &#123;</span><br><span class="line">            &#x2F;&#x2F; 避免重复触发 mLoggingHandler</span><br><span class="line">            if (!mLoggingHandler.mTriggered) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mLoggingHandler.uncaughtException(t, e);</span><br><span class="line">                &#125; catch (Throwable loggingThrowable) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Ignored.</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于Android在Crash的处理差异，是由于Android系统对默认未捕获进行了额外的处理，如果不希望这么处理，则可以重新对 <code>Thread.setDefaultUncaughtExceptionHandler</code> 进行设置，改变Android系统对未捕获异常的默认行为。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java 在默认在线程中发生不可捕获异常时，如果不对异常进行处理，则会抛出异常，但是不会导致整个进程奔溃，这得益于异常退出JVM仅在一个线程栈中有效。而对于其他线程栈的执行来说是没有影响的。&lt;/p&gt;
&lt;p&gt;但是在Java执行程序中，当异常发生在不同线程时，对于整个进程的返回
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Handler学习小记</title>
    <link href="http://yoursite.com/2016/05/10/Handler%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/05/10/Handler%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</id>
    <published>2016-05-10T12:34:24.000Z</published>
    <updated>2020-04-10T12:36:39.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Handler handler &#x3D; new Handler();</span><br><span class="line"></span><br><span class="line">Message message &#x3D; handler.obtainMessage(); &#x2F;&#x2F; 或者 Message message &#x3D; Message.obtain() </span><br><span class="line"></span><br><span class="line">handler.send(message); &#x2F;&#x2F; 基本</span><br><span class="line"></span><br><span class="line">handler.post(new Runable() &#123;</span><br><span class="line">  @Overriable</span><br><span class="line">  public void run() &#123;</span><br><span class="line">      &#x2F;&#x2F; do ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="源码流程"><a href="#源码流程" class="headerlink" title="源码流程"></a>源码流程</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23519/8778843DBE0146018DDBAF2B4733A5B8"  alt="image"></p><p>Handler 机制主要涉及四个主要部分：</p><ul><li>Handler 负责消息收发处理代理，或者处理代理设置</li><li>Message 消息结构内容，如果为Runnable，最终也将转化为 Message.callback，另外Message提供了资源池，提供于反复利用。</li><li>Looper 负责便利消息队列（MessageQueue.next())进行便利，并且根据对应的Handler进行分发（Message.target）</li><li>MessageQueue</li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23532/8D946CCBAE4042B69F2DEEAE879FC0F7"  alt="image"></p><p>通常我们通过 Handler 就可以实现大部分功能的使用，在Handler 中，同时封装了 <code>mLooper</code>和 <code>mQueue</code> ，而 <code>mQueue</code>来源于 <code>mLooper</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Handler(@Nullable Callback callback, boolean async) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 从当前线程中获得 Looper, 注意如果当前线程非主线程，则需要在当前线程提前使用 Looper.prepare() 以产生 Looper 对象，否则将报错 Only one Looper may be created per thread</span><br><span class="line">    mLooper &#x3D; Looper.myLooper();</span><br><span class="line">    if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new RuntimeException(</span><br><span class="line">            &quot;Can&#39;t create handler inside thread &quot; + Thread.currentThread()</span><br><span class="line">                    + &quot; that has not called Looper.prepare()&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取 MessageQueue</span><br><span class="line">    mQueue &#x3D; mLooper.mQueue;</span><br><span class="line">    mCallback &#x3D; callback;</span><br><span class="line">    mAsynchronous &#x3D; async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p>分析代码通常会从使用上入手，这里我们从简单的<code>Handler.post(Runnable r)</code>开始分析。</p><h3 id="Handler-post-Runnable-r"><a href="#Handler-post-Runnable-r" class="headerlink" title="Handler.post(Runnable r)"></a>Handler.post(Runnable r)</h3><p>post 主要是对sendMessage 的参数包装方法。<br>通过<code>getPostMessage</code> 对 <code>Runnable</code> 参数进行的包装，将<code>Runnable</code> 参数作为<code>Message.callback</code>参数,转化为<code>Message</code>对象，最终又调用<code>enqueueMessage</code> 方法，将<code>Message</code>作为参数传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">     Message m &#x3D; Message.obtain();</span><br><span class="line">     m.callback &#x3D; r;</span><br><span class="line">     return m;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>包装有 Runnable 参数的 Message，最终进入该方法，并且将<code>Message</code>添加到 <code>MessageQueue</code> 中（<code>MessageQueue.enqueueMessage(Message, time)</code>)，至此<code>Message</code>进入<code>MessageQueue</code> 队列中，等待被调用执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 比较简单，只是为了整合一些内容</span><br><span class="line">    public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123;</span><br><span class="line">        MessageQueue queue &#x3D; mQueue;</span><br><span class="line">        if (queue &#x3D;&#x3D; null) &#123;</span><br><span class="line">            RuntimeException e &#x3D; new RuntimeException(</span><br><span class="line">                    this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">            Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="enqueueMessage-MessageQueue-queue-Message-msg-long-uptimeMillis"><a href="#enqueueMessage-MessageQueue-queue-Message-msg-long-uptimeMillis" class="headerlink" title="enqueueMessage(MessageQueue queue, Message msg,long uptimeMillis)"></a>enqueueMessage(MessageQueue queue, Message msg,long uptimeMillis)</h3><p>该方法是将消息添加到 MessageQueue 的链表 mMessages 中，并决定是否激活Looper</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">       if (msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       if (msg.isInUse()) &#123;</span><br><span class="line">           throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           if (mQuitting) &#123;</span><br><span class="line">               IllegalStateException e &#x3D; new IllegalStateException(</span><br><span class="line">                       msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">               Log.w(TAG, e.getMessage(), e);</span><br><span class="line">               msg.recycle();</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.markInUse();</span><br><span class="line">           msg.when &#x3D; when;</span><br><span class="line">           Message p &#x3D; mMessages; &#x2F;&#x2F; mMessages 消息链表头部， 最近需要处理的消息（链表头部）</span><br><span class="line">           boolean needWake;</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 当还没有消息时（无消息头）或者当前消息需要立即执行（未设置定时）或者所需要执行时间先于当前消息链头部消息，则插入消息链头</span><br><span class="line">           if (p &#x3D;&#x3D; null || when &#x3D;&#x3D; 0 || when &lt; p.when) &#123;</span><br><span class="line">               &#x2F;&#x2F; New head, wake up the event queue if blocked.</span><br><span class="line">               msg.next &#x3D; p;</span><br><span class="line">               mMessages &#x3D; msg;</span><br><span class="line">               needWake &#x3D; mBlocked;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               &#x2F;&#x2F; 主要是为了将消息根据when插入到 消息链合适的位置</span><br><span class="line">               &#x2F;&#x2F; 如果已经被阻塞并且队头是阻塞消息，当前消息是异步的情况 则重新唤醒looper</span><br><span class="line">               needWake &#x3D; mBlocked &amp;&amp; p.target &#x3D;&#x3D; null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">               Message prev;</span><br><span class="line">               for (;;) &#123;</span><br><span class="line">                   prev &#x3D; p;</span><br><span class="line">                   p &#x3D; p.next;</span><br><span class="line">                   if (p &#x3D;&#x3D; null || when &lt; p.when) &#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                       needWake &#x3D; false;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               msg.next &#x3D; p; </span><br><span class="line">               prev.next &#x3D; msg;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           if (needWake) &#123;</span><br><span class="line">               &#x2F;&#x2F; 根据情况去激活Looper</span><br><span class="line">               nativeWake(mPtr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="nativeWake-long-ptr"><a href="#nativeWake-long-ptr" class="headerlink" title="nativeWake(long ptr)"></a>nativeWake(long ptr)</h3><p>以下借用下别人的图，对于JNI这块还不太熟悉，简单记录下JNI下发生的内容。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23575/95A1BCF6BD72417CAB6BC0177A70D7FD"  alt="image"></p><p>nativeWake 是一个native 方法，映射于 android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将Java层传递下来的mPtr转换为nativeMessageQueue</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue &#x3D; reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    &#x2F;&#x2F;调用wake函数</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要也是负责执行 wake() </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 Looper::wake()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void Looper::wake() &#123;</span><br><span class="line">#if DEBUG_POLL_AND_WAKE</span><br><span class="line">    ALOGD(&quot;%p ~ wake&quot;, this);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    uint64_t inc &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; 向管道mWakeEventFd写入字符1</span><br><span class="line">    &#x2F;&#x2F; TEMP_FAILURE_RETRY 是一个宏定义，当执行write失败后，会不断重复执行，直到执行成功为止。</span><br><span class="line">    ssize_t nWrite &#x3D; TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t)));</span><br><span class="line">    if (nWrite !&#x3D; sizeof(uint64_t)) &#123;</span><br><span class="line">        if (errno !&#x3D; EAGAIN) &#123;</span><br><span class="line">            ALOGW(&quot;Could not write wake signal, errno&#x3D;%d&quot;, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里为止 Post 的流程结束，而Send流程其实和 Post差不多。</p><h1 id="Main-Handler"><a href="#Main-Handler" class="headerlink" title="Main Handler"></a>Main Handler</h1><p>在之前中，我们提到一个Looper是需要在当前线程总调用 Looper.perpare 去产生的。但是在为什么主线程中，不需要调用也能执行。</p><p>这涉及到App的启动流程，在一个App启动后，会经过AMS到最后的ActivityThread，在这过程中，会调用ActivityThread.main() 去启动创建一个 ActivityThread 同时创建了Main线程的Looper。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ActivityThread thread &#x3D; new ActivityThread();</span><br><span class="line">    thread.attach(false, startSeq);</span><br><span class="line"></span><br><span class="line">    if (sMainThreadHandler &#x3D;&#x3D; null) &#123;</span><br><span class="line">        sMainThreadHandler &#x3D; thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    Looper.loop();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">     prepare(false);</span><br><span class="line">     synchronized (Looper.class) &#123;</span><br><span class="line">         if (sMainLooper !&#x3D; null) &#123;</span><br><span class="line">             throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">         sMainLooper &#x3D; myLooper();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line">  private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">     if (sThreadLocal.get() !&#x3D; null) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23559/283B4AAA92C743F6BC42C01EB02F21F5"  alt="image"></p><h2 id="为什么不会发生ANR"><a href="#为什么不会发生ANR" class="headerlink" title="为什么不会发生ANR"></a>为什么不会发生ANR</h2><p>前面解析到如果在一个MessageQueue 中没有消息的话，那么Looper将进入阻塞，那么为什么不会产生ANR呢。</p><p>在Android主线程中，MainLooper 承担着UI绘制、触摸事件、键盘事件等一切可以想得到的主线程工作内容，都是通过MainLooper去处理。</p><p>在这里面光一个UI刷新则已经让MainLooper每一秒都停不下来（60ms标准），更何况很难再6s内阻塞，并且及时发生了，那么UI一定也卡住了，这已经是明显的ANR了。</p><h1 id="Asynchronous-和-SyncBarrier"><a href="#Asynchronous-和-SyncBarrier" class="headerlink" title="Asynchronous 和 SyncBarrier"></a>Asynchronous 和 SyncBarrier</h1><p>在我们分析中，应该已经发现了，在Message和Looper 等中会不断出现 Asynchronous 这一属性或者判断。</p><p>这里需要结合 SyncBarrier 一起说明，在Handler中消息分为异步消息、同步消息和阻塞消息（普通用户没办法直接创建），一般情况下，我们创建的消息都是同步消息，这里SyncBarrier 的作用主要体现在对同步消息和异步消息的处理态度。</p><p>SyncBarrier 也是Message的一种，只是该Message的 target=null（Message的target通常是发送它的Handler），对于该种消息的作用，体现在 MessageQueue 的 next() 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">        final long ptr &#x3D; mPtr;</span><br><span class="line">        if (ptr &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                final long now &#x3D; SystemClock.uptimeMillis();</span><br><span class="line">                Message prevMsg &#x3D; null;</span><br><span class="line">                Message msg &#x3D; mMessages;</span><br><span class="line">                &#x2F;&#x2F; msg.target &#x3D;&#x3D; null 说明当前队头消息被设置了SyncBarrier</span><br><span class="line">                if (msg !&#x3D; null &amp;&amp; msg.target &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 找到该消息后面的异步消息(msg.isAsynchronous()方法)</span><br><span class="line">                    do &#123;</span><br><span class="line">                    &#x2F;&#x2F; 标识前一个消息</span><br><span class="line">                        prevMsg &#x3D; msg;</span><br><span class="line">                        msg &#x3D; msg.next;</span><br><span class="line">                    &#125; while (msg !&#x3D; null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 这时候得到的msg 或者是异步消息，或者是队头消息(非SyncBarrier消息) 或者是最后一个null消息</span><br><span class="line">                if (msg !&#x3D; null) &#123;</span><br><span class="line">                    if (now &lt; msg.when) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 还未到消息执行时间，则阻塞这段时间</span><br><span class="line">                        nextPollTimeoutMillis &#x3D; (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBlocked &#x3D; false;</span><br><span class="line">                        &#x2F;&#x2F; prevMsg不为空，从队列中删除即将执行的msg，但是队头保持不变，即在下一个循环中，队头还是个空消息</span><br><span class="line">                        &#x2F;&#x2F; 从这里可以看出，如果被设置了SyncBarrier，只有当SyncBarrier被移除的时候，才会执行队列后面的非异步消息</span><br><span class="line">                        if (prevMsg !&#x3D; null) &#123;</span><br><span class="line">                            prevMsg.next &#x3D; msg.next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                        &#x2F;&#x2F; 替换队头</span><br><span class="line">                            mMessages &#x3D; msg.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        msg.next &#x3D; null;</span><br><span class="line">                        msg.markInUse();</span><br><span class="line">                        return msg;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 队列中没有可用消息</span><br><span class="line">                    nextPollTimeoutMillis &#x3D; -1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因此可以理解为，如果在消息列表读取中发现有同步阻塞消息，则阻塞下面的在它之后的消息执行（被读取到），除非该消息设置了 Asynchronous。</p><h2 id="SyncBarrier的应用"><a href="#SyncBarrier的应用" class="headerlink" title="SyncBarrier的应用"></a>SyncBarrier的应用</h2><p>同步阻塞通常用在垂直同步的UI刷新中，在ViewRootImpl.scheduleTraversale()中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            doTraversal();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">        if (!mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 设置同步阻塞</span><br><span class="line">            mTraversalBarrier &#x3D; mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">            &#x2F;&#x2F; 等待下一个vsync信号会回调mTraversalRunnable</span><br><span class="line">            mChoreographer.postCallback(</span><br><span class="line">                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">            if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">                scheduleConsumeBatchedInput();</span><br><span class="line">            &#125;</span><br><span class="line">            notifyRendererOfFramePending();</span><br><span class="line">            pokeDrawLockIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 该方法在接收到vsync信号时调用，执行view的measure、layout和draw</span><br><span class="line">void doTraversal() &#123;</span><br><span class="line">        if (mTraversalScheduled) &#123;</span><br><span class="line">            mTraversalScheduled &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F; 移除同步阻塞</span><br><span class="line">            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">            performTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样子的处理是为了在执行UI同步时，将UI刷新优先置为最高优先级，延后其他消息的处理，提高流畅度。</p><h1 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h1><p>IdleHandler 用于在 Handler 线程空闲的时候（未接受到需要处理的Message时）进行的额外处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static interface IdleHandler &#123;</span><br><span class="line">    &#x2F;&#x2F; 当消息内队列所有的Message都被执行完或者还有消息但是暂时还不需要执行（定时消息）时，该方法会被调用，当返回true，则IdleHandler会保留在消息队列中，否则执行完后将从队列中移除了</span><br><span class="line">    boolean queueIdle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue messageQueue &#x3D; Looper.myQueue();</span><br><span class="line">   messageQueue.addIdleHandler(new MessageQueue.IdleHandler() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public boolean queueIdle() &#123;</span><br><span class="line">           ...</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建</title>
    <link href="http://yoursite.com/2016/05/01/Hexo%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2016/05/01/Hexo%E6%90%AD%E5%BB%BA/</id>
    <published>2016-05-01T15:41:21.000Z</published>
    <updated>2020-04-14T15:46:04.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h1><h2 id="确认-npm-已经安装"><a href="#确认-npm-已经安装" class="headerlink" title="确认 npm 已经安装"></a>确认 npm 已经安装</h2><p>可以通过 mac brew 直接进行安装</p><p>如果brew过慢可以，切换git remote 切换到清华镜像上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;brew.git</span><br><span class="line">git checkout master</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">cd &quot;$(brew --repo)&#x2F;Library&#x2F;Taps&#x2F;homebrew&#x2F;homebrew-core&quot;</span><br><span class="line">git remote set-url origin https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;homebrew&#x2F;homebrew-core.git</span><br><span class="line">git checkout master</span><br><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install npm</span><br></pre></td></tr></table></figure><p>完成安装</p><h2 id="执行-hexo-安装"><a href="#执行-hexo-安装" class="headerlink" title="执行 hexo 安装"></a>执行 hexo 安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>如果npm下载比较慢，同样可以替换镜像源为淘宝的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h1 id="Github-部署"><a href="#Github-部署" class="headerlink" title="Github 部署"></a>Github 部署</h1><ul><li>添加 &lt;用户名&gt;.github.io 项目，产生对应的项目地址（直接用&lt;用户名&gt;.github.io 访问）</li><li>github项目下创建名为CNAME文件（不需要后缀），填写需要重定向的域名</li><li>执行<code>npm install hexo-deployer-git --save</code>安装git插件</li><li><code>_config.yml</code>配置<code>deploy</code>配置项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com:&lt;用户名&gt;&#x2F;&lt;用户名&gt;.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>当执行 <code>hexo d</code> 会将hexo所生成的静态内容发布到该项目下</li></ul><p><code>每次发布hexo都会讲public文件夹内容重新生成并发布，因此如果有需要保留的文件，例如CNAME、README，需要在每次发布前手动复制这些文件到该项目下</code></p><h1 id="Hexo-操作"><a href="#Hexo-操作" class="headerlink" title="Hexo 操作"></a>Hexo 操作</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>初始化项目 <code>hexo init</code>，生成目录结构</li><li>执行<code>hexo g</code>可以将source在public文件中生成相关 html静态文件，这些文件会被提交到github 上去（所以原文要记得自己保存）</li><li>执行<code>hexo s</code>可以开启本地预览功能</li></ul><h2 id="命令表"><a href="#命令表" class="headerlink" title="命令表"></a>命令表</h2><table><thead><tr><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>hexo new ‘postName’</td><td>新建文章</td><td>hexo n</td></tr><tr><td>hexo new page ‘pageName’</td><td>新建页面</td><td>hexo n page</td></tr><tr><td>hexo generate</td><td>生成静态文件</td><td>hexo g</td></tr><tr><td>hexo server</td><td>启动预览服务器</td><td>hexo s<br>hexo s -g #生成并本地预览</td></tr><tr><td>hexo deploy</td><td>发布</td><td>hexo d<br>hexo d -g #生成并上传</td></tr><tr><td>hexo help</td><td>帮助</td><td></td></tr><tr><td>hexo version</td><td>hexo版本</td><td></td></tr></tbody></table><h1 id="替换主题"><a href="#替换主题" class="headerlink" title="替换主题"></a>替换主题</h1><p> hexo 是根据 <code>themes</code> 文件夹提供主题选择，可以将主题下载到该文件夹中。<br> 修改<code>_config.yml</code> 中 <code>theme:</code> 配置项改为<code>themes</code>对应主题目录名，并执行<code>hexo g</code>重新生成静态文件，生效该主题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装-hexo&quot;&gt;&lt;a href=&quot;#安装-hexo&quot; class=&quot;headerlink&quot; title=&quot;安装 hexo&quot;&gt;&lt;/a&gt;安装 hexo&lt;/h1&gt;&lt;h2 id=&quot;确认-npm-已经安装&quot;&gt;&lt;a href=&quot;#确认-npm-已经安装&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>HTTP学习小记</title>
    <link href="http://yoursite.com/2015/08/10/HTTP%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2015/08/10/HTTP%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</id>
    <published>2015-08-10T12:31:18.000Z</published>
    <updated>2020-04-10T12:53:21.761Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP特点：</p><ul><li>无连接<ul><li>限制每次连接（tcp）只处理一个请求</li><li>服务器处理完客户的请求，并收到客户的应答后，即断开连接(tcp)（原避免服务器端口资源浪费，后面适应发展需要在一个页面下多个请求，因此后面改善 keep-live)</li></ul></li><li>无状态<ul><li>提高响应速度 </li><li>协议对于事务处理没有记忆能力。当次事务如果要利用前面请求传递的信息，则需要重传。（后面通过 cookie、session 改善，当次请求如果信息量过大，则会导致请求量太大，请求时间长） </li></ul></li></ul><h1 id="一、TCP-IP-协议族"><a href="#一、TCP-IP-协议族" class="headerlink" title="一、TCP/IP 协议族"></a>一、TCP/IP 协议族</h1><p>HTTP协议是构建在 TPC/IP 协议之上的协议，是TCP/IP协议的子集</p><p>特征：</p><ul><li>分层管理 （四层）<ul><li>应用层<ul><li>定义：一般为我们编写的应用程序，决定了向用户提供的应用服务。可以通过系统调用与传输层进行通信。</li><li>例子：FTP、DNS、HTTP、SMTP等协议</li></ul></li><li>传输层<ul><li>定义：通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能</li><li>例子：TCP（面向连接，三次握手四次挥手，比较可靠，效率低）、UDP（无连接，可靠性低，效率高）等协议</li></ul></li><li>网络层<ul><li>定义：用来处理在网络上流动的数据包，<code>数据包</code>是网络传输的最小数据单元。该层规定了通过怎样的路径（传输路线）到达对方计算机，并把数据包传输给对方。</li><li>例子：IP、ARP等协议</li></ul></li><li>数据链路层（网络接口层）<ul><li>定义：用来处理连接网络的硬件部分，包括控制操作系统、硬件设备驱动、NIC(Network Interface Card，网络适配器）以及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。</li></ul></li></ul></li></ul><h1 id="二、数据包"><a href="#二、数据包" class="headerlink" title="二、数据包"></a>二、数据包</h1><h2 id="1-数据包封装过程"><a href="#1-数据包封装过程" class="headerlink" title="1.数据包封装过程"></a>1.数据包封装过程</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/21835/7FBE686FAE9D4C02A022AF8768501774"  alt="image"></p><h2 id="2-HTTP数据传输过程"><a href="#2-HTTP数据传输过程" class="headerlink" title="2.HTTP数据传输过程"></a>2.HTTP数据传输过程</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/21841/A650EAA0FE6B4D7CB8D947D30F704092"  alt="image"></p><p>数据发送以及接收。会经过上层传输到下层，这过程经过数据包封装，打上每一层的头部信息。在到达对方计算机后由下层到达上层，都将逆向一级一级将头部信息进行解析删除。</p><h1 id="三、一些重要的支持协议"><a href="#三、一些重要的支持协议" class="headerlink" title="三、一些重要的支持协议"></a>三、一些重要的支持协议</h1><h2 id="DNS（应用层）"><a href="#DNS（应用层）" class="headerlink" title="DNS（应用层）"></a>DNS（应用层）</h2><p>用于解决域名到IP地址之间的解析服务（IP地址不容理解记住）  </p><h3 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h3><ul><li>浏览器会检查本地缓存中有没有解析过该域名，如果缓存有则直接使用，没有则继续</li><li>解析本地 host 文件时有对应的域名ip映射，如果有则返回，没有继续</li><li>向本地解析服务器（LDNS Local DNS Server）发起域名解析请求。（本地配置中所配置的DNS服务器地址），如果服务器缓存中存在对应的解析结果则返回，否则继续。</li><li>向根域名解析器（RDNS Root DNS Server) 发起请求，根域名服务器返回通用顶级域名解析服务器（gTDL）地址</li><li>本地域名服务器（LDNS）向gTDL发起解析域名请求，gTLD服务器返回请求地址所注册的域名服务器（Name Server服务器）</li><li>本地域名服务器（LDNS）向 Name Server服务器发起域名解析请求，Name Server 服务器解析映射表，返回该域名对应的ip和TTL（LDNS进行缓存这个域名和ip的对应关系表，缓存时间由TTL决定）</li><li>LDNS返回ip给浏览器，客户端进行缓存，缓存时间由TTL决定</li></ul><h2 id="DNS的记录类型"><a href="#DNS的记录类型" class="headerlink" title="DNS的记录类型"></a>DNS的记录类型</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>A记录</td><td>A代表的是Address，用来指定域名对应的IP地址，A记录允许将多个域名解析到一个IP地址，但不允许将一个域名解析到多个IP上。</td></tr><tr><td>MX记录</td><td>MX代表的是Mail Exchage，就是可以将某个域名下的邮箱服务器指向自己的Mail Server</td></tr><tr><td>CNAME记录</td><td>CNAME指的是Canonical Name，也就是别名解析，可以将指定的域名解析到其他域名上，而其他域名就是指定域名的别名，整个解析过程称为别名解析。</td></tr><tr><td>NS记录</td><td>就是为了某个域名指定了特定的DNS服务器去解析。</td></tr><tr><td>TXT记录</td><td>为某个主机名或者域名设置特定的说明。</td></tr></tbody></table><h2 id="TCP-传输层"><a href="#TCP-传输层" class="headerlink" title="TCP (传输层)"></a>TCP (传输层)</h2><h3 id="TCP-三次握手（确保双方收发能力的最少步骤）"><a href="#TCP-三次握手（确保双方收发能力的最少步骤）" class="headerlink" title="TCP 三次握手（确保双方收发能力的最少步骤）"></a>TCP 三次握手（确保双方收发能力的最少步骤）</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/21855/E82E8A02C7CB4547A14825F403D26C75"  alt="image"></p><ul><li><p>客户端发送SYN标记的连接请求报文段，进入SYN_SEND状态，等待服务器确认</p><ul><li>服务器确认客户端发送能力和服务器接收能力</li></ul></li><li><p>服务器接收SYN报文段，发送ACK信息对客户端SYN报文段确认，发送服务器SYN请求信息，将之前的ACK信息打包一起（SYN+ACK报文段），一起发送给客户端，服务器进入SYN_RECV状态。</p><ul><li>客户端确认服务器接收能力、服务器发送能力、客户端发送能力和客户端接收能力</li></ul></li><li><p>客户端接收到服务器的SYN+ACK报文段后，向服务器发送ACK确认报文段，客户端进入ESTABLISHED状态，服务器接收后进入ESTABLISHED状态，完成TCP三次握手过程。</p><ul><li>服务器确认客户端接收能力和服务器发送能力</li></ul></li><li><p>两端进入数据传送。</p></li></ul><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23480/7532149551844A34BCA8AA094B8845F8"  alt="image"></p><ul><li>第一次挥手：TCP发送一个FIN(结束)，用来关闭客户端到服务器端的连接。</li><li>第二次挥手：服务器端收到这个FIN后发回一个ACK确认标示，确认收到。</li><li>第三次挥手：服务器端发送一个FIN到客户端，服务器端关闭客户端的连接。</li><li>第四次挥手：客户端发送ACK报文确认，这样关闭完成。</li></ul><h2 id="IP-网络层"><a href="#IP-网络层" class="headerlink" title="IP (网络层)"></a>IP (网络层)</h2><h1 id="四、HTTP事务流程"><a href="#四、HTTP事务流程" class="headerlink" title="四、HTTP事务流程"></a>四、HTTP事务流程</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/21910/164049DB94FA4002993FB01857DE22C6"  alt="image"></p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/21916/64D874EA7E6040F5BCB553192351C857"  alt="image"></p><ul><li>客户端发起请求，通过DNS服务器查询域名对应的IP地址</li><li>浏览器发起HTTP请求，通过TCP/IP协议发送给服务器</li><li>服务器根据请求返回响应内容，通过TCP/IP协议返回给客户端</li></ul><h1 id="五、请求方法"><a href="#五、请求方法" class="headerlink" title="五、请求方法"></a>五、请求方法</h1><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>简单的通过URI进行资源访问<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22001/A8922981594B47D2A46AF88F0526A534"  alt="image"></p><ul><li>注意？长度，URI 长度可能会超限（各种浏览器限制不同）</li></ul><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>POST用于提交主体内容（表单）<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22008/9CD217BBE94648359D7F593ED8CF26E9"  alt="image"></p><ul><li>相对于GET，POST主体内容在后面进行换行后天就主体内容</li></ul><h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><ul><li>从客户端向服务器传送的数据取代指定的文档的内容</li><li>与POST的最大不同是，PUT是幂等（无论做多少次操作都是实现相同的结果），POST不是</li><li>PUT更适合作为传输资源，更新操作（无验证机制）</li></ul><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><ul><li>类似于GET，不过返回的响应中不存在内容，只获取头部</li><li>经常用于测速连接有效性</li></ul><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><ul><li>与PUT相反，指定用于删除操作（无验证机制）</li></ul><h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><ul><li>用来查询针对请求URI指定的资源支持的方法</li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22025/DFA745EC5E7643D88D3374942801291E"  alt="image"></p><h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><ul><li>回显服务器收到的请求，主要用于测速或诊断（跨站追踪攻击）</li></ul><h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><ul><li>开启一个客户端与请求资源之间的双向沟通的通道，可以用来创建隧道</li><li>例子：代理，通过与代理创建的隧道，代理只负责转发数据，但是不对数据进行读取</li></ul><h1 id="六、状态码"><a href="#六、状态码" class="headerlink" title="六、状态码"></a>六、状态码</h1><p>用来表示网页超文本传输协议响应状态的3位数字状态码</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22039/7A8643760627466396741E75B9862327"  alt="image"></p><h2 id="分类与含义"><a href="#分类与含义" class="headerlink" title="分类与含义"></a>分类与含义</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22042/85BE1CBFC34C4F96A5385E0182C991E8"  alt="image"></p><h3 id="2XX"><a href="#2XX" class="headerlink" title="2XX"></a>2XX</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22049/EC80F6B73279406ABE9A8770157DA0F2"  alt="image"></p><h3 id="3XX"><a href="#3XX" class="headerlink" title="3XX"></a>3XX</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22047/FBB02F246959488DA4C488F8C6B0B5D0"  alt="image"></p><h3 id="4XX"><a href="#4XX" class="headerlink" title="4XX"></a>4XX</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22045/E78853ADFAAD406B9E041615AEB0114F"  alt="image"></p><h3 id="5XX"><a href="#5XX" class="headerlink" title="5XX"></a>5XX</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22051/D8F817202BAB4A33B00BDB57486DE405"  alt="image"></p><h1 id="七、字符集与编码"><a href="#七、字符集与编码" class="headerlink" title="七、字符集与编码"></a>七、字符集与编码</h1><p>关键字：编码规范、 编码方式、字符集、字库表</p><ul><li>一个二进制数通过一种编码方式，转化成编码字符集中对应的地址，然后在字库表里面找到一个对应的字符显示给用户</li><li>一种编码规范可以存着多种编码方式，多种编码方式存着性能空间上的差异，比如Unicode规范可以有 UTF-8(变长) 和 UTF-16（固容） 不同的实现方式<ul><li>UTF-16 拥有两个字节，对应复杂字符，比如中文可以很方便的存着，如果为英文则只需要一个字节即可实现，但是对应UTF-16来说还是需要两个字符来存储，因此存着空间浪费。但是在解析上，对二级制数据只需要按照2个字节的读取拆分，既可快速解码。</li><li>UTF-8 是根据情况进行一个字节、两个字节或三个字节的变长容量。存储上并不能将整个字段8位用于表示字符，还需要额外提供变长标记、大端小端标记等。一个字节只有2的7次方可表示的容量，两个字节则为2的11次方，三个则为2的16次方。</li></ul></li></ul><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><ul><li>ASCII码</li><li>GBK（主要面向中文）</li><li>ISO-8859-1（主要面向西方文字）</li><li>Unicode（面向全世界兼容）</li></ul><h2 id="URL的编码与解码"><a href="#URL的编码与解码" class="headerlink" title="URL的编码与解码"></a>URL的编码与解码</h2><h3 id="需要编码内容"><a href="#需要编码内容" class="headerlink" title="需要编码内容"></a>需要编码内容</h3><ul><li>URL 所使用的是ASCII字符集编码，如果URL中存在非该编码字符，则需要对其进行编码</li><li>URL 中的保留字符也需要进行编码，比如 &amp;、？</li></ul><h3 id="编码规范-1"><a href="#编码规范-1" class="headerlink" title="编码规范"></a>编码规范</h3><ul><li>“%编码”规范</li><li>对URL中属于ASCII字符集的非保留字不做编码；对URL中的保留字需要取其ASCII内码，然后加上 % 前缀将该字符进行编码；对于URL中的非ASCII字符需要取其Unicode内码，然后加上 % 前缀将该字符进行编码</li></ul><h1 id="八、Cookie-与-Session"><a href="#八、Cookie-与-Session" class="headerlink" title="八、Cookie 与 Session"></a>八、Cookie 与 Session</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>实际上为一段小文本信息。当客户端请求服务器时，如果服务器需要记录该用户状态，则向客户端浏览器颁发一个Cookie，客户端（浏览器）将把Cookie保存起来。当浏览器再请求该网站时，浏览器吧请求的网址连同Cookie一并发送给服务器，服务器检查该Cookie，以此来辨认用户状态。</p><ul><li>不同浏览器对Cookie 保存实现不同，Cookie仅是规范</li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22068/WEBRESOURCE74ef66b5c6e61d1cd68eec6483340269"  alt="image.png"></p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>是另外一种记录客户状态的机制，保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。（服务器技术），客户端再次访问时，只需要从Session中找到该用户的状态即可。<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22078/WEBRESOURCE72d9040dbb0ffd464be9ae700515ca83"  alt="image.png"></p><h3 id="保存Session-ID的方式"><a href="#保存Session-ID的方式" class="headerlink" title="保存Session ID的方式"></a>保存Session ID的方式</h3><ul><li>Cookie<ul><li>一般保存形式通过 cookie 保存 </li></ul></li><li>URL重写 <ul><li>可以通过URL主动传递</li><li>例子：http://…/xxx;Sessionid=dfjlsjfioewjjflXXsflkjdsfl(路径形式) 或 http://…/xxx?Sessionid=fioewjffjdsflkjdkfjasdlfjdl(参数形式)</li><li>隐藏表单</li></ul></li></ul><h3 id="Session有效期"><a href="#Session有效期" class="headerlink" title="Session有效期"></a>Session有效期</h3><ul><li>Session 超时失效（有效时间）</li><li>程序主动注销 HttpSession.invalidate() 等</li><li>程序进程终止</li></ul><h2 id="Cookie-与-Session-不同"><a href="#Cookie-与-Session-不同" class="headerlink" title="Cookie 与 Session 不同"></a>Cookie 与 Session 不同</h2><ul><li>存放位置不同（客户端、服务端）</li><li>安全性不同（Cookie 较松、服务器较为严格）</li><li>有效期不同（Cookie 可以很长甚至永久、服务器较短）</li><li>对服务器压力不同（Cookie保存在客户端很少压力、Session保存服务器占用资源）</li></ul><h1 id="九、身份认证"><a href="#九、身份认证" class="headerlink" title="九、身份认证"></a>九、身份认证</h1><h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><ul><li>BASIC认证（基本认证）</li><li>DIGEST认证（摘要认证）</li><li>SSL客户端认证</li><li>FormBase认证（基于表单认证）</li></ul><h3 id="BASIC-认证（安全性差）"><a href="#BASIC-认证（安全性差）" class="headerlink" title="BASIC 认证（安全性差）"></a>BASIC 认证（安全性差）</h3><p>使用质询/响应的方式，并且直接发送明文密码</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22111/WEBRESOURCE74f2fec5b3c8af171b821703d08960e7"  alt="image.png"></p><h3 id="DIGEST认证"><a href="#DIGEST认证" class="headerlink" title="DIGEST认证"></a>DIGEST认证</h3><p>相对BASIC 来说，不在直接发送明文密码，解决防止密码被直接窃听，用户欺骗还是不行</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22117/WEBRESOURCE4c9b86f591da225cc041a04d089a4c56"  alt="image.png"></p><h3 id="SSL-客户端认证"><a href="#SSL-客户端认证" class="headerlink" title="SSL 客户端认证"></a>SSL 客户端认证</h3><p>借助HTTPS客户度证书完成认证，但是维护成本高。</p><h3 id="基于表单认证"><a href="#基于表单认证" class="headerlink" title="基于表单认证"></a>基于表单认证</h3><p>并不是在HTTP协议中定义而是在Web应用中实现，借助于Cookie 和 Session 来保持用户状态。</p><h1 id="十、长连接和短连接"><a href="#十、长连接和短连接" class="headerlink" title="十、长连接和短连接"></a>十、长连接和短连接</h1><p>HTTP的长短连接本质是TCP的长短连接。HTTP 1.0 默认使用短连接，一次请求一次连接后就中断，从1.1开始默认使用长连接，保持连接性</p><ul><li>使用 Connect:keep-live </li></ul><h1 id="十一、代理（拦截服务器）"><a href="#十一、代理（拦截服务器）" class="headerlink" title="十一、代理（拦截服务器）"></a>十一、代理（拦截服务器）</h1><p>代理服务器作为一种既是服务器又是客户机的中间程序，主要用于转发客户系统的网络访问请求。但是，代理服务器不只是简单地向真正的因特网服务器转发请求，它还可以控制用户的行为，对接收到的客户请求进行决策，并根据过滤规则对用户请求进行过滤。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22141/WEBRESOURCEa556244c7114fc037197342e75e8bf52"  alt="image.png"></p><p>主要作用：</p><ul><li>抓包</li><li>翻墙</li><li>匿名访问</li><li>过滤器</li></ul><p>通过代理服务器，网络管理员可以实现比用包过滤路由器更严格的安全策略。不同于使用通用的包过滤路由器来管理通过防火墙的因特网服务流向，代理服务器通过在网关上为每项需要的应用安装专用的代码（代理服务）来工作。如果网络管理员没有为某一特殊服务安装代理服务代码，该服务就不会被支持，也不会通过防火墙转发相应的客户请求。并且，这种代理服务器码能被配置成仅支持某项服务的网络管理员认为可以接受的那部分特征，而不支持其他的特征。</p><h1 id="十二、网关"><a href="#十二、网关" class="headerlink" title="十二、网关"></a>十二、网关</h1><p>作为某种翻译器使用（协议转换器 的角色），它抽象出一种能够到达资源的方法。网关是资源和应用程序之间的粘合剂</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22153/WEBRESOURCE75a8c3b5dd25883f8916499d05da8937"  alt="image.png"></p><p>Web 网关在一侧使用HTTP协议，在另一侧使用另一种协议。<br>&lt;客户端协议&gt;/&lt;服务端协议&gt;</p><h2 id="常见的网关类型"><a href="#常见的网关类型" class="headerlink" title="常见的网关类型"></a>常见的网关类型</h2><ul><li>（HTTP/*）服务器Web网关 ： 客户端使用HTTP协议通过网关转换成服务要求的不同协议</li><li>（HTTP/HTTPS）服务器安全网关：将客户端使用的HTTP转换为HTTPS协议</li><li>（HTTPS/HTTP）客户端安全加速网关：将客户端HTTPS转换为HTTP协议</li><li>资源网关：使用不同协议转换为对应需要的资源，HTTP转RPC</li></ul><h1 id="十三、HTTP缓存"><a href="#十三、HTTP缓存" class="headerlink" title="十三、HTTP缓存"></a>十三、HTTP缓存</h1><h2 id="相关头字段"><a href="#相关头字段" class="headerlink" title="相关头字段"></a>相关头字段</h2><ul><li>Cache-Control<ul><li>no-store: 所有内容都不缓存</li><li>no-cache: 缓存，但是浏览器使用缓存前，都会请求服务器判断资源是否是最新。</li><li>max-age=x(秒)：请求缓存后的X秒不在发起请求（1.0 的EXPIRES 头部字段响应，但是优先该字段）</li><li>s-maxage=x(秒)：代理服务器请求源站缓存后的X秒不在发起请求，只对CDN缓存有效</li><li>public：客户端和代理服务器（CDN）都可缓存</li><li>private：只有客户端可以缓存<ul><li>Expires (代表资源过期时间，由服务器返回提供，与max-age共存时，优先级低)</li><li>Last-Modified (资源最新修改时间，由服务器告知客户端，用于刷新资源时间)</li><li>if-Modified-Since (资源最新修改时间，由客户端告诉服务器，会与Last-Modified进行对比)</li><li>Etag (资源标识，由服务器告诉客户端)</li><li>if-None-Match (缓存资源标识，由客户端告诉服务器，与Etag为一对，会进行对比)</li></ul></li></ul></li></ul><h3 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h3><ul><li>客户端向服务器发起请求，如果发现请求资源 Expires 过期，则会向服务器进行更新请求，如果发送修改则服务器返回新文件和新Expires时间，否则返回304（频繁请求、并且服务器的更新无法感知）</li><li>在Expires基础增加，Last-Modified(服务器响应带) 和 if-Modified-Since(客户端请求带)，当客户端向服务器发起请求时，发现文件过期，则带上 if-Modified-Since 最近文件更新时间向服务器请求新文件，服务器通过对比文件更新时间，如果发送修改则返回新的 Last-Modified 修改时间以及新文件，否则返回304（但是如果文件频繁修改，修改记录在1s以内则无法触发）<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22212/WEBRESOURCE84bb8b86e922a5fce21cd92f8e8b789d"  alt="image.png"></li><li>在之前的基础上增加 Etag与If-None-Match 以及 max-age 字段，Etag、If-None-Match 用来标记资源唯一标识，如果设置在发送时设置了该资源标识，则服务器仅对该资源标识进行匹配，忽略其他有效期（更新时间）等验证。（针对资源标识频繁变更，但是该方案仅在发生过期时，在服务器匹配方案上的调整）</li></ul><h3 id="缓存改进"><a href="#缓存改进" class="headerlink" title="缓存改进"></a>缓存改进</h3><ul><li>MD5缓存： 为了解决在未发生过期的情况下，更新缓存资源，将资源名进行MD5命名，保证在每次请求时资源名都和上次不一样，这将导致缓存策略失败，从而实现每次资源拉取时都拉取最新资源</li><li>CDN缓存：构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负责均衡、内容分发、调度等功能模块，使用户就近获取需要的内容，降低网络拥塞，提高用户访问响应速度和命中率</li></ul><h1 id="十四、内容协商机制"><a href="#十四、内容协商机制" class="headerlink" title="十四、内容协商机制"></a>十四、内容协商机制</h1><p>客户端与服务器就响应的资源内容进行交涉，然后提供给客户端最为适合的资源，内容协商会以响应资源的语言，字符集，编码方式等作为判断的标准。</p><h2 id="协商方式"><a href="#协商方式" class="headerlink" title="协商方式"></a>协商方式</h2><ul><li>客户端驱动，由客户端发起，服务器发送回可选项类别，客户端选择后发起第二次请求。（迟延、多次请求问题）</li><li>服务器驱动，服务器检查客户端请求头来决定提供的版本（）</li><li>透明协商，某个中间社保（通常是缓存代理）代表客户端进行协商</li></ul><h3 id="服务器驱动"><a href="#服务器驱动" class="headerlink" title="服务器驱动"></a>服务器驱动</h3><h4 id="相关头部信息"><a href="#相关头部信息" class="headerlink" title="相关头部信息"></a>相关头部信息</h4><table><thead><tr><th>客户端请求头部名</th><th>说明</th><th>对应服务器返回头部名</th></tr></thead><tbody><tr><td>Accept</td><td>告知服务器发送何种媒体类型</td><td>Content-Type</td></tr><tr><td>Accept-Language</td><td>告知服务器发送何种语言</td><td>Content-Language</td></tr><tr><td>Accept-Charset</td><td>告知服务器发送何种字符集</td><td>Content-Type</td></tr><tr><td>Accept-Encoding</td><td>告知服务器采用何种编码</td><td>Content-Encoding</td></tr></tbody></table><h4 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h4><p><code>Accept-Language:en;q=0.5,fr;q=0.0,nl;q=1.0,tr;q=0.0</code></p><p>该语言表示，如果有荷兰语（nl）则优先返回，如果没有则优先英语（en），不接受 法语（fr）和土耳其语（tr），q为权重值，如果没有则返回服务默认语言</p><h1 id="十五、断点续传和多线程下载"><a href="#十五、断点续传和多线程下载" class="headerlink" title="十五、断点续传和多线程下载"></a>十五、断点续传和多线程下载</h1><h2 id="相关头部名"><a href="#相关头部名" class="headerlink" title="相关头部名"></a>相关头部名</h2><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>客户端发起时携带Range，用于请求头中，指定第一个字节的位置和最后一个字节的位置，一般格式为：</p><p><code>Range:(unit=first byte pos)-[last byte pos]</code></p><p>例如：</p><p>Range:bytes=0-499</p><p>Range:bytes=500-</p><p>Range:bytes=-500</p><p>Range:bytes=500-600,601-999</p><h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><p>服务器根据Range返回的响应头，服务器会在Content-Range头部返回当前接受的范围和文件总大小，返回格式为：</p><p><code>Content-Range:bytes(unit first byte pos)-[last byte pos]/[entity length]</code></p><p>例如：</p><p><code>Content-Range:bytes 512000-/1024000</code></p><p>根据不同的下载方式会返回不同的响应状态</p><ul><li>使用断点续传方式：<br><code>HTTP/1.1 206 Partial Content</code></li><li>不适用断点续传方式：<br><code>HTTP/1.1 200 OK</code></li></ul><h1 id="十六、HTTPS"><a href="#十六、HTTPS" class="headerlink" title="十六、HTTPS"></a>十六、HTTPS</h1><p> 关键词： 证书颁发机构、服务器网址、机构私钥加密（服务端公钥）、机构私钥加密（证书签名）、操作系统证书列表、浏览器证书列表</p><p>HTTP+TLS(传输层加密协议，前身是SSL协议)</p><h2 id="相对于HTTP提升"><a href="#相对于HTTP提升" class="headerlink" title="相对于HTTP提升"></a>相对于HTTP提升</h2><ul><li>内容加密（非对称密钥交换、对称内容加密）（HTTP为明文传输）</li><li>身份认证（数字证书）（HTTP并不对发送方进行验证，直接信任）</li><li>数据完整性（HTTP不会对接收内容进行是否篡改的验证）</li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul><li>服务器将公钥交给第三方证书机构，机构通过自身私钥对公钥进行加密产生证书给服务器。（签名证书）</li><li>客户端与服务器建立连接，服务器将证书发送给客户端。（服务器-&gt;证书-&gt;客户端）</li><li>客户端通过机构公钥解密证书获得服务器公钥。（使用合法第三方机构公钥解密证书，验证该证书是合法的服务器提供，非中间人伪造） </li><li>使用获得的公钥对客户端公钥进行加密，将加密后的客户端公钥发送给服务器，服务器通过自身的私钥解开加密后的客户端公钥，获得客户端公钥。（客户端-&gt;加密后的客户端公钥-&gt;服务器，两者都获得双方公钥后可以进行通信）</li></ul><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>在HTTPS中同时采用了对称加密和非对称加密，在交换密钥环节使用了非对称加密（以RSA为代表），在建立通信后交换报文采用对称加密方式（以DES为代表）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### 数字证书认证（CA）</span><br><span class="line">在非对称加密中，最大的问题是对于密钥的生成、保管以及对于公钥的合法性（是否来源于合法机构）。</span><br><span class="line"></span><br><span class="line">为了解决公钥真实性问题，HTTPS使用了数字证书认证机构以及它公开的密钥证书。</span><br><span class="line"></span><br><span class="line">![image](http:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;res&#x2F;23117&#x2F;8EF39073B3BB444F8BE256DDCA1BF5B5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CA使用具体的流程如下：</span><br><span class="line"></span><br><span class="line">1. 服务器的运营人员向数字证书认证机构(CA)提出公开密钥的申请;</span><br><span class="line">2. CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；</span><br><span class="line">3. 如果信息审核通过，CA会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。</span><br></pre></td></tr></table></figure><p>证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；<br>签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用CA的私钥对信息摘要进行加密，密文即签名；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">1. 客户端在HTTPS握手阶段向服务器发出请求，要求服务器返回证书文件；</span><br><span class="line">2. 客户端读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；</span><br><span class="line">客户端然后验证证书相关的域名信息、有效时间等信息；</span><br><span class="line">3. 客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应CA的证书，证书也会被判定非法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 成本</span><br><span class="line"></span><br><span class="line">* 证书费用以及更新维护</span><br><span class="line">* HTTPS降低用户访问速度</span><br><span class="line">* CPU资源</span><br><span class="line"></span><br><span class="line">## 性能影响</span><br><span class="line">*  协议交互所增加的网络RTT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![image.png](http:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;res&#x2F;22333&#x2F;WEBRESOURCE085edf662db343a2e9f019484e08cbbc)</span><br><span class="line"></span><br><span class="line">![image.png](http:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;res&#x2F;22336&#x2F;WEBRESOURCEe39d4f77e7be5a2065680a8d53e702b9)</span><br><span class="line"></span><br><span class="line">    * HTTPS 如果在用户执行HTTP需要进行302重定向为HTTPS链接，并且由于发送了端口变更，需要重新进行握手，在进行 TLS握手，进行加密套件协商和证书验证</span><br><span class="line">    * Ocsp 在线证书状态协议，返回证书状态（过期、无效等）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*  加解密耗时</span><br><span class="line">*  计算耗时</span><br><span class="line">    * 客户端耗时（计算证书，加解密）</span><br><span class="line">    * 服务器耗时（加解密等）</span><br><span class="line">    </span><br><span class="line">## Android 中对TLS 版本的支持</span><br><span class="line"></span><br><span class="line">Client Socket支持</span><br><span class="line">| protocol | 支持API（需要配置） | 默认支持API |</span><br><span class="line">| -------- | ------------------- | ----------- |</span><br><span class="line">| SSLv3    | 1-25                | 1-22        |</span><br><span class="line">| TLSv1    | 1+                  | 1+          |</span><br><span class="line">| TLSv1.1  | 16+                 | 20+         |</span><br><span class="line">| TLSv1.2  | 16+                 | 20+         |</span><br><span class="line">| TLSv1.3  | 29+                 | 29+         |</span><br><span class="line"></span><br><span class="line">Server Socket 支持</span><br><span class="line">| protocol | 支持API（需要配置） | 默认支持API |</span><br><span class="line">| -------- | ------------------- | ----------- |</span><br><span class="line">| SSLv3    | 1-25                | 1-22        |</span><br><span class="line">| TLSv1    | 1+                  | 1+          |</span><br><span class="line">| TLSv1.1  | 16+                 | 16+         |</span><br><span class="line">| TLSv1.2  | 16+                 | 16+         |</span><br><span class="line">| TLSv1.3  | 29+                 | 29+         |</span><br><span class="line"></span><br><span class="line">注意默认情况下，服务器和客户端通信需要</span><br><span class="line"></span><br><span class="line"># 十七、HTTP的瓶颈</span><br><span class="line">* 带宽</span><br><span class="line">* 延迟</span><br><span class="line">* 一条连接上只可能进行一个请求</span><br><span class="line">* 请求只能从客户端发起，不可接受响应之外的指令</span><br><span class="line">* 请求&#x2F;响应投不经压缩就发送</span><br><span class="line">* 每次互相发送相同的头部造成浪费</span><br><span class="line">* 非强制压缩发送</span><br><span class="line"></span><br><span class="line"># 十八、WebSocket</span><br><span class="line">WebSocket 是HTTP一种解决不足上的新协议，遵守HTTP的握手规范，所谓的基于HTTP，是对HTTP的兼容，但是和HTTP协议基本没有关系</span><br><span class="line"></span><br><span class="line">* 真正的全双工方式</span><br><span class="line">* 减少通信量</span><br><span class="line"></span><br><span class="line">## 头部信息</span><br><span class="line"></span><br><span class="line">* Upgrade:WebSocket 固定字段，用于通知服务器需要WebSocket服务</span><br><span class="line">* Connection:Upgrade 固定字段</span><br><span class="line">* Sec-WebSocket-Key Base64 encode值，由浏览器自动生成用于验证是否为WebScoket服务器</span><br><span class="line">* Sec-WebSocket-Protocol 用户自定义字段，用来区分同URL下，不同的服务需要的协议，通知服务器，客户端所需要的服务类型</span><br><span class="line">* Sec-WebSocket-Version  通知服务器WebSocket Draft 协议版本</span><br><span class="line"></span><br><span class="line">![image](http:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;res&#x2F;22367&#x2F;C2D741AC1E7143CC93282103BB58729E)</span><br><span class="line"></span><br><span class="line">## 其他技术</span><br><span class="line"></span><br><span class="line">* Ajax 采用不断请求返回Response的轮询 形式</span><br><span class="line">* long poll 采用轮询，在没有结果前则一直阻塞，直到达成某个条件才返回Response</span><br><span class="line"></span><br><span class="line">以上两种都需要客户端主动发起Request，并且ajax 需要比较好的响应速度，而 long poll 会产生比较高的并发</span><br><span class="line"></span><br><span class="line">## 解决的问题</span><br><span class="line"></span><br><span class="line">* 建立链接后，可以互相发送（推送），不需要由客户端发起才能返回Response，解决高并发，延迟问题</span><br><span class="line">* 加快响应速度，减少重复的HTTP验证握手，WebSocket只需要一HTTP握手，在一次状态中。</span><br><span class="line">* 整个通讯过程可以维持状态(HTTP是无状态，每次请求都需要携带)</span><br><span class="line">* WebSocket 是新协议，必须客户端和服务器同时支持才能执行</span><br><span class="line"></span><br><span class="line">![image](http:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;res&#x2F;22404&#x2F;B8A6B1367CA74E239821C5155A21CBAB)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 十九、SPDY协议（会话层）</span><br><span class="line"></span><br><span class="line">用于加强HTTP协议</span><br><span class="line"></span><br><span class="line">![image](http:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;res&#x2F;22413&#x2F;6CB8B7784EDD402B8F68F31882B83E0E)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## HTTP 缺陷</span><br><span class="line"></span><br><span class="line">* 单路链接 请求效率低</span><br><span class="line">* 只允许客户端发起请求</span><br><span class="line">* 头部冗余</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## SPAY 改进</span><br><span class="line"></span><br><span class="line">* 允许多路复用，请求优化（建立一个TCP连接，可以多次发起请求，并且可以设置优先级，HTTPS先进先出）</span><br><span class="line">![image](http:&#x2F;&#x2F;note.youdao.com&#x2F;yws&#x2F;res&#x2F;22424&#x2F;272333098EE14421B967B31CBA2BBE4E)</span><br><span class="line">* 支持服务器推送技术</span><br><span class="line">* 压缩了HTTP头</span><br><span class="line">* 强制使用SSL传输协议（HTTPS)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;HTTP2.0已解决以上问题，google 已放弃</span><br></pre></td></tr></table></figure><h1 id="二十、HTTP2-0"><a href="#二十、HTTP2-0" class="headerlink" title="二十、HTTP2.0"></a>二十、HTTP2.0</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22433/761EED29292E4519B1B8161B3170E83A"  alt="image"></p><h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22437/7D25714510AB4BB2970156BFF2511E03"  alt="image"></p><ul><li>对于以前的 Header 部分信息被封装进2.0的HEADERS frame 帧</li><li>数据部分被封装到 DATA frame 帧</li><li>以上数据被进行二进制处理，这些帧在传输时可以乱序发送，在获取后再进行重新组装，用于提升传输效率（重试效率）</li></ul><h1 id="二十一、WebDAV协议"><a href="#二十一、WebDAV协议" class="headerlink" title="二十一、WebDAV协议"></a>二十一、WebDAV协议</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22448/B5B88D4A37F04D438EB4A02FFEE58442"  alt="image"></p><h2 id="所增加的请求方法和状态码"><a href="#所增加的请求方法和状态码" class="headerlink" title="所增加的请求方法和状态码"></a>所增加的请求方法和状态码</h2><p>为了方便对文件进行操作，WebDAV 增加了几种新的方法和状态码</p><table><thead><tr><th>方法</th><th>用途</th></tr></thead><tbody><tr><td>PROPFIND</td><td>获取属性</td></tr><tr><td>PROPPATCH</td><td>修改属性</td></tr><tr><td>MKCOL</td><td>创建集合</td></tr><tr><td>COPY</td><td>复制资源及其属性</td></tr><tr><td>MOVE</td><td>移动资源</td></tr><tr><td>LOCK</td><td>资源加锁</td></tr><tr><td>UNLOCK</td><td>资源解锁</td></tr></tbody></table><table><thead><tr><th>状态码</th><th>说明</th></tr></thead><tbody><tr><td>102 Processing</td><td>可以正常处理请求，但目前是处理中状态</td></tr><tr><td>207 Multi-Status</td><td>存在多种状态</td></tr><tr><td>422 UnprocessibleEntity</td><td>格式正确，内容有误</td></tr><tr><td>424 FailedDependency</td><td>处理与某请求关联的请求失败，因此不再维持依赖关系</td></tr><tr><td>507 InsufficientStorage</td><td>保存空间不足</td></tr></tbody></table><p>请求：<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22462/7589C0B8D56B40ECBFFCD0347D5CD5B4"  alt="image"></p><p>响应：<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22465/6119010A071E42E3889189B0A8DF9E97"  alt="image"></p><h1 id="二十二、HTTP3-0-amp-QUIC"><a href="#二十二、HTTP3-0-amp-QUIC" class="headerlink" title="二十二、HTTP3.0&amp;QUIC"></a>二十二、HTTP3.0&amp;QUIC</h1><ul><li>使用UDP为底层协议</li><li>0 RTT<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22476/01C835BDD95B4AA294D190E231B42F46"  alt="image"></li><li>没有队头阻塞的多路复用（因为使用UDP协议，不会阻塞重传，从而避免后面数据的被应用层无法读取问题）</li></ul><p>改进前：<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22479/FAFB288A65D24375877C8BE29CC574B9"  alt="image"></p><p>改进后<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22482/F4329EECE7A04E2C83E64D3CD0F1E682"  alt="image"></p><ul><li>前向纠错<br>对于发送的数据包，如果在一组数据里面发送某一个包（仅限于丢失一个包），则可以通过校验包（通过其他完整的数据包计算出的一个前置包）恢复丢失包的数据。</li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22470/C4615DD1D3DA45E597274859DD3826D6"  alt="image"></p><h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><ul><li>2.0 队头阻塞</li><li>建立连接的握手延迟大</li></ul><h1 id="二十三、各个版本的改进汇总"><a href="#二十三、各个版本的改进汇总" class="headerlink" title="二十三、各个版本的改进汇总"></a>二十三、各个版本的改进汇总</h1><table><thead><tr><th>协议版本</th><th>HTTP1.0</th><th>HTTP1.1</th><th>HTTP2.0</th></tr></thead><tbody><tr><td>HTTP1.0</td><td></td><td></td><td></td></tr><tr><td>HTTP1.1</td><td>1. 缓存处理，HTTP1.0使用if-Modified-Since、Expires做缓存标准，HTTP1.1增加Entity Tag(eTag)、If-Unmodified-Since、If-Match、If-None-Match等更多缓存头部来控制。<br><br>2. 带宽、网络连接优化。HTTP1.0 不支持断点续传，当客户端需要服务器资源部分内容时，服务器只能返回整个资源内容。HTTP1.1加入range头，支持断点，增加返回码状态206（Partial Content）。<br><br>3. 增加新状态码。<br><br>4. 增加Host头域，并且在请求服务器时需要强制携带，否则返回400。<br><br>5. 增加长连接。支持长连接（PersistentConnection）和请求流水线（Pipelining）处理，支持一个TCP连接发起多个HTTP请求响应，HTTP1.1默认开启长连接 keep-alive</td><td></td><td></td></tr><tr><td>HTTP2.0</td><td></td><td>1. 数据压缩，使用二进制格式传输数据（Binary Format）。HTTP1.X是基于文本，需要适应不同的编码。<br><br>2. 多路复用（MultiPlexing），每个请求都有一个id，这样一个连接上存着多个请求，接收方根据id将请求归属于不同于不同的服务端。<br><br>3. HEADE 压缩，HTTP1.X 每次请求都重复发送Header，HTTP2.0使用encoder减少Header大小，通讯双方各自缓存一份header fields表，只对前一次所不同的地方进行增量传输，避免重复传输header。<br><br>4. 服务端推送，具备主动推送到客户端能力</td><td></td></tr></tbody></table><h1 id="二十四、关于其他的问题"><a href="#二十四、关于其他的问题" class="headerlink" title="二十四、关于其他的问题"></a>二十四、关于其他的问题</h1><ul><li><p>提升访问速度<br>直接使用IP访问，不经过域名DNS</p></li><li><p>双向通信方案</p><ul><li>建立自身的TCP长连接，基于TCP Socket编程，定制自己的协议</li><li>long-poling 长轮询方案，由客户端发起请求，等待服务器有新信息才返回给客户端，当完成请求后，客户端需要离开在发起请求，保持持续的连接中。</li><li>http streaming, 通过Server Response头部增加“Transfer Encoding:chunked”童子客户端还有后续数据，保持不断开response</li><li>websocket，但是需要双方都支持。</li></ul></li><li><p>头部拥塞解决</p><ul><li>Pipelining 病不能完全解决该问题，Pipelining 是在上一个请求响应时，在同一个TCP连接中，发送下一个请求，但是客户端还是需要按照请求顺序来接收响应，如果前面一个还未响应，则还是会导致头部拥塞。</li></ul></li><li><p>keep-alive 和 多路复用 效率<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22688/24EA935988AE4C708C872DCC50C78414"  alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先http1.1同域请求限制6个tcp连接建立，但是，每个http1.1的TCP都是线头阻塞的</span><br><span class="line">而http2是基于流进行数据请求的，几百个请求都是可以基于一个tcp连接传递，然后通过流id进行拼接返回到每个请求上，不存在线头阻塞并且只会用到一个tcp，对于服务器的并发量提高了6倍</span><br><span class="line">并且http2还有头压缩对状态行和头信息进行哈弗曼编码压缩，还有静态字典动态字典相关等技术处理节省头信息优化传输浪费流量</span><br></pre></td></tr></table></figure></li><li><p>HTTP 和 HTTPS 区别</p><ul><li>HTTP下加入SSL层，HTTPS的安全基础是SSL。</li><li>接收端口不一样</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTTP特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无连接&lt;ul&gt;
&lt;li&gt;限制每次连接（tcp）只处理一个请求&lt;/li&gt;
&lt;li&gt;服务器处理完客户的请求，并收到客户的应答后，即断开连接(tcp)（原避免服务器端口资源浪费，后面适应发展需要在一个页面下多个请求，因此后面改善 keep
      
    
    </summary>
    
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
