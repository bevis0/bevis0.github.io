<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bevis技术小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-26T12:25:48.916Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Bevis</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxJava-操作符自定义理解</title>
    <link href="http://yoursite.com/2019/07/01/RxJava-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/07/01/RxJava-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%90%86%E8%A7%A3/</id>
    <published>2019-07-01T12:24:46.000Z</published>
    <updated>2020-04-26T12:25:48.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h1><p>以<code>just</code>最简单的调用链作为例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3).subscribe &#123; </span><br><span class="line">          Log.i(&quot;Logger&quot;, &quot;next output &gt;&gt;  $it&quot;)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>该例子只参与创建和订阅流程，具体时序图：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/30735/WEBRESOURCEc995b74fb0b97d3981241c7315d18d68"  alt="image"></p><p>流程中主要处理以下几个事情：</p><ol><li>执行 <code>just</code> 操作符对发送数据进行被观察者对象包装<code>ObservableFromArray</code></li><li>执行 <code>subscribe</code> 对订阅者的订阅事件（onNext）进行订阅者包装，产生<code>LambdaObserver</code></li><li>执行 <code>ObservableFromArray</code> 被观察者实现的 <code>subscribeActual</code> 方法</li><li>创建 观察者所需要的参数<code>Disposable</code>，<code>FromArrayDisposable</code> 对象</li><li>调用观察者<code>LambdaObserver</code>的<code>onSubscribe</code>开始触发<code>onNext</code>、<code>onComplete</code>、<code>onError</code>响应</li></ol><p>这里面涉及几个主要对象：</p><ul><li>ObservableSource <code>被观察者数据源，负责观察者数据源的接收和处理</code></li><li>Obsrvable <code>ObservableSource 实现抽象类，启动入口，提供了大量操作符</code></li><li>Observer <code>观察者，负责处理</code></li><li>Disposable <code>作为信号器，用于对执行过程进行中断监控</code></li></ul><p>大致如图关系：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/30802/4D90E7BA835C40948788AB64B7A1C566"  alt="image"></p><h1 id="简单自定义操作"><a href="#简单自定义操作" class="headerlink" title="简单自定义操作"></a>简单自定义操作</h1><p>通过以上流程可以大概了解 RxJava 的运行流程和原理，因此后面我们需要做的是从里面找到我们合适的hook处理时机，以实现我们的要求。</p><h2 id="以Map为例子"><a href="#以Map为例子" class="headerlink" title="以Map为例子"></a>以Map为例子</h2><p>Map 操作是将一个输入源 转为另一种类型的数据并下发。</p><p>因此我们需要考虑在获得上一个输入类型的处理数据后，通过转化函数，再次进行转化类型的订阅者发送。<br>明白需求我们可以选择在<code>onNext</code>每次获得结果数据后进行依次转化并发送给新的 <code>Observer</code>，具体实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; source 为上一个数据源，map为转化函数，由于结果目的并不是要获取原始数据 S，因此只需要提供 T类型观察者就行</span><br><span class="line">class MapObservable&lt;S,T&gt;(private val source: ObservableSource&lt;S&gt;, val map: Function&lt;S, T&gt;) : Observable&lt;T&gt;() &#123;</span><br><span class="line">    override fun subscribeActual(observer: Observer&lt;in T&gt;?) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 对原始被观察者进行观察，当发生新数据产生，则将数据通过指定的转化函数&#96;map&#96;进行转化后</span><br><span class="line">        &#x2F;&#x2F; 转发给目标类型T的观察者对象。</span><br><span class="line">        source.subscribe(object: Observer&lt;S&gt; &#123;</span><br><span class="line">            override fun onComplete() &#123;</span><br><span class="line">                observer?.onComplete()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onSubscribe(d: Disposable?) &#123;</span><br><span class="line">                observer?.onSubscribe(d)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onNext(t: S) &#123;</span><br><span class="line">                val t &#x3D; map.apply(t)</span><br><span class="line">                observer?.onNext(t)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onError(e: Throwable?) &#123;</span><br><span class="line">                observer?.onError(e)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自定义协程操作"><a href="#自定义协程操作" class="headerlink" title="自定义协程操作"></a>自定义协程操作</h2><p>RxJava 中 <code>subscribeOn</code> 和 <code>observeOn</code> 也是一个异步操作符，分别对于为<code>ObservableSubscribeOn</code>、<code>ObservableObserveOn</code>，以它们为参考，可以先看下它们的实现。</p><h3 id="sbscribeOn"><a href="#sbscribeOn" class="headerlink" title="sbscribeOn"></a>sbscribeOn</h3><p><code>ObservableSubscribeOn</code> 在<code>subscribeActual</code>中只主要做一件事件，将<code>Observable.subscribe</code>订阅操作延迟到线程中执行，这样对于所有之前的包装的被观察者<code>Observable.subscribe</code> 和向下传递的<code>Observer</code> 行为都会在线程中该线程中执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    public void subscribeActual(final Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        final SubscribeOnObserver&lt;T&gt; parent &#x3D; new SubscribeOnObserver&lt;&gt;(observer);</span><br><span class="line"></span><br><span class="line">        observer.onSubscribe(parent);</span><br><span class="line">        &#x2F;&#x2F; 设置目标 Disposable</span><br><span class="line">        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    static final class SubscribeOnObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements Observer&lt;T&gt;, Disposable &#123;</span><br><span class="line"></span><br><span class="line">        private static final long serialVersionUID &#x3D; 8094547886072529208L;</span><br><span class="line">        final Observer&lt;? super T&gt; downstream;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 上游终止标记</span><br><span class="line">        final AtomicReference&lt;Disposable&gt; upstream;</span><br><span class="line"></span><br><span class="line">        SubscribeOnObserver(Observer&lt;? super T&gt; downstream) &#123;</span><br><span class="line">            this.downstream &#x3D; downstream;</span><br><span class="line">            this.upstream &#x3D; new AtomicReference&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onSubscribe(Disposable d) &#123;</span><br><span class="line">            &#x2F;&#x2F; 校验是需要执行 disposable 操作</span><br><span class="line">            DisposableHelper.setOnce(this.upstream, d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 终止标记</span><br><span class="line">        @Override</span><br><span class="line">        public void dispose() &#123;</span><br><span class="line">            &#x2F;&#x2F; 标记上游终止</span><br><span class="line">            DisposableHelper.dispose(upstream);</span><br><span class="line">            &#x2F;&#x2F; 标记自身终止</span><br><span class="line">            DisposableHelper.dispose(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean isDisposed() &#123;</span><br><span class="line">            &#x2F;&#x2F; 返回当前是否被设置终止标记</span><br><span class="line">            return DisposableHelper.isDisposed(get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void setDisposable(Disposable d) &#123;</span><br><span class="line">            DisposableHelper.setOnce(this, d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Runable包装需要执行是 source.subscribe ，将订阅操作指定到线程中执行。</span><br><span class="line">    final class SubscribeTask implements Runnable &#123;</span><br><span class="line">        private final SubscribeOnObserver&lt;T&gt; parent;</span><br><span class="line"></span><br><span class="line">        SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</span><br><span class="line">            this.parent &#x3D; parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            source.subscribe(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步操作符需要注意：</p><ol><li>Disposable 的处理</li><li>明确异步的执行操作及其其他动作线程所属的影响</li></ol><p>下面自定义一个 Looper 操作符，用于指定设定前的线程执行环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class LooperOnObservable&lt;T&gt;(private val source: ObservableSource&lt;T&gt;, private val looper: Looper) : Observable&lt;T&gt;() &#123;</span><br><span class="line">    override fun subscribeActual(observer: Observer&lt;in T&gt;?) &#123;</span><br><span class="line">        Handler(looper).post(LooperObserver(observer))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建这个任务只是为了做为 Runnable 载体，并且在等待执行阶段，提供能被取消的能力</span><br><span class="line">    private inner class LooperObserver(val observer: Observer&lt;in T&gt;?): AtomicReference&lt;Disposable&gt;(), Observer&lt;T&gt; , Disposable, Runnable&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 上游中断标识</span><br><span class="line">        private val upstream &#x3D; AtomicReference&lt;Disposable&gt;()</span><br><span class="line">        override fun onComplete() &#123;</span><br><span class="line">            observer?.onComplete()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onSubscribe(d: Disposable?) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果当前已经被Disposable 所终止，那么通知上游终止</span><br><span class="line">            DisposableHelper.setOnce(this.upstream, d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onNext(t: T) &#123;</span><br><span class="line">            observer?.onNext(t)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun onError(e: Throwable?) &#123;</span><br><span class="line">           observer?.onError(e)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun isDisposed(): Boolean &#123;</span><br><span class="line">            return DisposableHelper.isDisposed(get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun dispose() &#123;</span><br><span class="line">            &#x2F;&#x2F; 标记上游中断</span><br><span class="line">            DisposableHelper.dispose(upstream);</span><br><span class="line">            &#x2F;&#x2F; 标记自身中断</span><br><span class="line">            DisposableHelper.dispose(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        override fun run() &#123;</span><br><span class="line">            source.subscribe(observer)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; ObservableSource&lt;T&gt;.looperOn(looper: Looper): Observable&lt;T&gt; &#123;</span><br><span class="line">    return LooperOnObservable&lt;T&gt;(this, looper)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">val thread &#x3D; HandlerThread(&quot;Handler Thread &quot;)</span><br><span class="line">thread.start()</span><br><span class="line">Observable.just(1,2,3).map &#123;</span><br><span class="line">    Log.i(&quot;Log&quot;, &quot; Map 1 index[ $it ] in $&#123;Thread.currentThread()&#125; &quot;)</span><br><span class="line">    return@map it</span><br><span class="line">&#125;</span><br><span class="line">    .map &#123;</span><br><span class="line">        Log.i(&quot;Log&quot;, &quot;Map 2 index[ $it ] in $&#123;Thread.currentThread()&#125; &quot;)</span><br><span class="line">        return@map it</span><br><span class="line">    &#125;</span><br><span class="line">    .looperOn(thread.looper)</span><br><span class="line">    .subscribe &#123;</span><br><span class="line">        Log.i(&quot;Log&quot;, &quot;Next index[ $it ] in $&#123;Thread.currentThread()&#125; &quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map 1 index[ 1 ] in Thread[Handler Thread ,5,main] </span><br><span class="line">Map 2 index[ 1 ] in Thread[Handler Thread ,5,main] </span><br><span class="line">Next index[ 1 ] in Thread[Handler Thread ,5,main] </span><br><span class="line">Map 1 index[ 2 ] in Thread[Handler Thread ,5,main] </span><br><span class="line">Map 2 index[ 2 ] in Thread[Handler Thread ,5,main] </span><br><span class="line">Next index[ 2 ] in Thread[Handler Thread ,5,main] </span><br><span class="line">Map 1 index[ 3 ] in Thread[Handler Thread ,5,main] </span><br><span class="line">Map 2 index[ 3 ] in Thread[Handler Thread ,5,main] </span><br><span class="line">Next index[ 3 ] in Thread[Handler Thread ,5,main]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原理分析&quot;&gt;&lt;a href=&quot;#原理分析&quot; class=&quot;headerlink&quot; title=&quot;原理分析&quot;&gt;&lt;/a&gt;原理分析&lt;/h1&gt;&lt;p&gt;以&lt;code&gt;just&lt;/code&gt;最简单的调用链作为例子：&lt;/p&gt;
&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Glide-缓存机制</title>
    <link href="http://yoursite.com/2019/06/24/Glide-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/06/24/Glide-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2019-06-24T12:47:07.000Z</published>
    <updated>2020-04-23T13:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>Glide 对资源加载分为三级：</p><ul><li>通过 ActiveResource 工作缓存中进行尝试加载，如果查询到则返回该资源，否则继续</li><li>如果 ActiveResource 找不到，则通过 MemoryCache 进行查找加载，如果查询到则返回，并将该资源从 MemoryCache 中移除，转移到 ActiveResource 中</li><li>如果两者都找不到，则启动资源加载和解码任务。</li><li></li></ul><p>流程参照：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/30366/WEBRESOURCE2907d71943afcf90232443660029f7fe"  alt="image"></p><h1 id="Engin-load-加载入口"><a href="#Engin-load-加载入口" class="headerlink" title="Engin.load 加载入口"></a>Engin.load 加载入口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public &lt;R&gt; LoadStatus load(</span><br><span class="line">    GlideContext glideContext,</span><br><span class="line">    Object model,</span><br><span class="line">    Key signature,</span><br><span class="line">    int width,</span><br><span class="line">    int height,</span><br><span class="line">    Class&lt;?&gt; resourceClass,</span><br><span class="line">    Class&lt;R&gt; transcodeClass,</span><br><span class="line">    Priority priority,</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">    boolean isTransformationRequired,</span><br><span class="line">    boolean isScaleOnlyOrNoTransform,</span><br><span class="line">    Options options,</span><br><span class="line">    boolean isMemoryCacheable,</span><br><span class="line">    boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">    boolean useAnimationPool,</span><br><span class="line">    boolean onlyRetrieveFromCache,</span><br><span class="line">    ResourceCallback cb,</span><br><span class="line">    Executor callbackExecutor) &#123;</span><br><span class="line">  long startTime &#x3D; VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 根据资源的属性进行 Key 的构造，必须保持资源Key的唯一性</span><br><span class="line">  EngineKey key &#x3D;</span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 从内存缓存中获取资源    </span><br><span class="line">    memoryResource &#x3D; loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有获得</span><br><span class="line">    if (memoryResource &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return waitForExistingOrStartNewJob(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          options,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          cb,</span><br><span class="line">          callbackExecutor,</span><br><span class="line">          key,</span><br><span class="line">          startTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Avoid calling back while holding the engine lock, doing so makes it easier for callers to</span><br><span class="line">  &#x2F;&#x2F; deadlock.</span><br><span class="line">  cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存资源获取"><a href="#缓存资源获取" class="headerlink" title="缓存资源获取"></a>缓存资源获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private EngineResource&lt;?&gt; loadFromMemory(</span><br><span class="line">    EngineKey key, boolean isMemoryCacheable, long startTime) &#123;</span><br><span class="line">   </span><br><span class="line">  &#x2F;&#x2F; 如果设置 skipMemoryCache 则忽略从缓存进行加载  </span><br><span class="line">  if (!isMemoryCacheable) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 从工作缓存 ActiveResources 进行尝试加载</span><br><span class="line">  EngineResource&lt;?&gt; active &#x3D; loadFromActiveResources(key);</span><br><span class="line">  if (active !&#x3D; null) &#123;</span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return active;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 从资源缓存中获取资源</span><br><span class="line">  EngineResource&lt;?&gt; cached &#x3D; loadFromCache(key);</span><br><span class="line">  if (cached !&#x3D; null) &#123;</span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return cached;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ActiveResources"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</h3><p><code>ActiveResource</code> 是内存缓存的获取的第一次层缓存，通过<code>ActiveResource.get</code>进行资源获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private EngineResource&lt;?&gt; loadFromActiveResources(Key key) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取资源</span><br><span class="line">  EngineResource&lt;?&gt; active &#x3D; activeResources.get(key);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 如果能得到资源，则对资源进行引用计数</span><br><span class="line">  if (active !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 引用计数增加，如果 EngineResource.acquired 不为 0 ，则表示资源未被释放引用，无法执行 </span><br><span class="line">    &#x2F;&#x2F; EngineResource.recycle、EngineResource.release 资源释放动作</span><br><span class="line">    active.acquire();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解析前，对 <code>ActiveResource</code> 先进行初步了解</p><h4 id="ActiveResources-基础"><a href="#ActiveResources-基础" class="headerlink" title="ActiveResources 基础"></a>ActiveResources 基础</h4><p><code>ActiveResources</code> 内部提供 <code>HashMap</code> 对所引用的资源进行存储</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Map&lt;Key, ResourceWeakReference&gt; activeEngineResources &#x3D; new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p><code>ActiveResources</code> 通过 <code>activate(Key key, EngineResource&lt;?&gt; resource)</code>对资源进行加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">synchronized void activate(Key key, EngineResource&lt;?&gt; resource) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ResourceWeakReference 继承自 WeakReference ，通过弱引用包装，并构造时</span><br><span class="line">  &#x2F;&#x2F; 设置 ReferenceQueue resouceReferenceQueue，产生资源引用</span><br><span class="line">  ResourceWeakReference toPut &#x3D;</span><br><span class="line">      new ResourceWeakReference(</span><br><span class="line">          key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 添加到工作缓存 Map 中，如果之前已经存在，则回收之前旧资源引用</span><br><span class="line">  ResourceWeakReference removed &#x3D; activeEngineResources.put(key, toPut);</span><br><span class="line">  if (removed !&#x3D; null) &#123;</span><br><span class="line">    removed.reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static final class ResourceWeakReference extends WeakReference&lt;EngineResource&lt;?&gt;&gt; &#123;</span><br><span class="line">  final Key key;</span><br><span class="line">  final boolean isCacheable;</span><br><span class="line">  Resource&lt;?&gt; resource;</span><br><span class="line">  </span><br><span class="line">  ResourceWeakReference(Key key, EngineResource&lt;?&gt; referent, </span><br><span class="line">      ReferenceQueue&lt;? super EngineResource&lt;?&gt;&gt; queue, boolean isActiveResourceRetentionAllowed) &#123;</span><br><span class="line">    super(referent, queue);</span><br><span class="line">    this.key &#x3D; Preconditions.checkNotNull(key);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; isActiveResourceRetentionAllowed 通过 GlideBuilder.setIsActiveResourceRetentionAllowed </span><br><span class="line">    &#x2F;&#x2F; 进行设置，默认为 false</span><br><span class="line">    this.resource &#x3D;</span><br><span class="line">        referent.isMemoryCacheable() &amp;&amp; isActiveResourceRetentionAllowed</span><br><span class="line">            ? Preconditions.checkNotNull(referent.getResource())</span><br><span class="line">            : null;</span><br><span class="line">    isCacheable &#x3D; referent.isMemoryCacheable();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void reset() &#123;</span><br><span class="line">    resource &#x3D; null;</span><br><span class="line">    clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ActiveResource</code> 通过对资源弱引用包装（ResourceWeakReference） 和 ReferenceQueue 回收监控达到对工作缓存进行内存控制，以防止造成内存泄露，另一方面对于工作中的资源引用达到快速索引的要求。</p><h4 id="ActiveResources-get-Key"><a href="#ActiveResources-get-Key" class="headerlink" title="ActiveResources.get(Key)"></a>ActiveResources.get(Key)</h4><p>回到内存缓存获取的入口，对工作缓存进行查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> synchronized EngineResource&lt;?&gt; get(Key key) &#123;</span><br><span class="line">   ResourceWeakReference activeRef &#x3D; activeEngineResources.get(key);</span><br><span class="line">   if (activeRef &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   EngineResource&lt;?&gt; active &#x3D; activeRef.get();</span><br><span class="line">   if (active &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 资源清理    </span><br><span class="line">     cleanupActiveReference(activeRef);</span><br><span class="line">   &#125;</span><br><span class="line">   return active;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">void cleanupActiveReference(@NonNull ResourceWeakReference ref) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从缓存Map中移除</span><br><span class="line">     activeEngineResources.remove(ref.key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果资源已经主动被释放则退出 </span><br><span class="line">     if (!ref.isCacheable || ref.resource &#x3D;&#x3D; null) &#123;</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 回调</span><br><span class="line">   EngineResource&lt;?&gt; newResource &#x3D;</span><br><span class="line">       new EngineResource&lt;&gt;(</span><br><span class="line">           ref.resource, &#x2F;*isMemoryCacheable&#x3D;*&#x2F; true, &#x2F;*isRecyclable&#x3D;*&#x2F; false, ref.key, listener);</span><br><span class="line">   listener.onResourceReleased(ref.key, newResource);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在该方法中，主要还是对 <code>HashMap</code> 的缓存中获取对应的资源弱引用，如果不再缓存中则返回null，当 资源弱引用<code>ResourceWeakReference</code>中资源已经被释放，则对<code>ResourceWeakReference</code>进行回收处理，将缓存从缓存Map中移除。</p><h4 id="ActiveResource-的资源释放"><a href="#ActiveResource-的资源释放" class="headerlink" title="ActiveResource 的资源释放"></a>ActiveResource 的资源释放</h4><p>虽然<code>ActiveResource</code> 使用 <code>ReferenceQueue</code> 进行资源回收监控，不过仅在创建时进行回收。</p><p>另外比较常用的回收资源手段是通过 <code>ActiveResource.deactivate</code> 的调用。</p><p>该方法仅在 <code>EngineResource.ResourceListener.onResourceReleased</code> 发生的回调中执行资源回收。</p><p><code>EngineResource.ResourceListener.onResourceReleased</code>接口被<code>Engine</code>所实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Engine</span><br><span class="line">    implements EngineJobListener,</span><br><span class="line">        MemoryCache.ResourceRemovedListener,</span><br><span class="line">        EngineResource.ResourceListener &#123;</span><br><span class="line">    ...    </span><br><span class="line">   public void onResourceReleased(Key cacheKey, EngineResource&lt;?&gt; resource) &#123;</span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    if (resource.isMemoryCacheable()) &#123;</span><br><span class="line">      cache.put(cacheKey, resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resourceRecycler.recycle(resource, &#x2F;*forceNextFrame&#x3D;*&#x2F; false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>onResourceReleased</code> 被两个地方所调用。</p><ul><li>ActiveResources.cleanupActiveReference(ResourceWeakReference)</li><li>EngineResource.release()</li></ul><p>这里主要关注于 <code>EngineResource.release</code>，在之前 ActiveResource 的处理中，我们知道<code>EngineResource</code> 是资源的代理对象。</p><p>当追踪到代码的根源，我们会发现<code>EngineResource.release</code> 被 <code>SingleRequest.clear</code>所调用，而<code>SingleRequest.clear</code>最终被多个地方所调用，其中不免有 <code>RequestManager</code>。</p><p>Glide 对资源生命周期的管理中，<code>RequestMananger</code>会对<code>Fragment</code>、<code>Activity</code>等生命周期进行回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class RequestManager</span><br><span class="line">    implements ComponentCallbacks2, LifecycleListener, ModelTypes&lt;RequestBuilder&lt;Drawable&gt;&gt; &#123;</span><br><span class="line">  ...    </span><br><span class="line">  public void clear(@Nullable final Target&lt;?&gt; target) &#123;</span><br><span class="line">    if (target &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    untrackOrDelegate(target);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  private void untrackOrDelegate(@NonNull Target&lt;?&gt; target) &#123;</span><br><span class="line">    boolean isOwnedByUs &#x3D; untrack(target);</span><br><span class="line">    Request request &#x3D; target.getRequest();</span><br><span class="line">    if (!isOwnedByUs &amp;&amp; !glide.removeFromManagers(target) &amp;&amp; request !&#x3D; null) &#123;</span><br><span class="line">      target.setRequest(null);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 对 Request 进行clear处理</span><br><span class="line">      request.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  public synchronized void onDestroy() &#123;</span><br><span class="line">    targetTracker.onDestroy();</span><br><span class="line">    &#x2F;&#x2F; 释放该周期对象中所有 Request 的资源</span><br><span class="line">    for (Target&lt;?&gt; target : targetTracker.getAll()) &#123;</span><br><span class="line">      clear(target);</span><br><span class="line">    &#125;</span><br><span class="line">    targetTracker.clear();</span><br><span class="line">    requestTracker.clearRequests();</span><br><span class="line">    lifecycle.removeListener(this);</span><br><span class="line">    lifecycle.removeListener(connectivityMonitor);</span><br><span class="line">    mainHandler.removeCallbacks(addSelfToLifecycle);</span><br><span class="line">    glide.unregisterRequestManager(this);</span><br><span class="line">  &#125;  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们明显可以知道当发生<code>onDestroy</code>发生时，则会也会触发资源的销毁动作</p><h3 id="MemoryCache-缓存获取"><a href="#MemoryCache-缓存获取" class="headerlink" title="MemoryCache 缓存获取"></a>MemoryCache 缓存获取</h3><p>如果 <code>ActiveResource</code> 获取不到所需要的资源，则尝试从 <code>loadFromCache</code> 进行加载。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final MemoryCache cache;</span><br><span class="line"></span><br><span class="line">private EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">  &#x2F;&#x2F; 从 MemoryCache 内存缓存中获取资源，如果能得到，从内存缓存中剔除，并转移到工作缓存中</span><br><span class="line">  EngineResource&lt;?&gt; cached &#x3D; getEngineResourceFromCache(key);</span><br><span class="line">  if (cached !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 进行资源使用计数    </span><br><span class="line">    cached.acquire();</span><br><span class="line">    activeResources.activate(key, cached);</span><br><span class="line">  &#125;</span><br><span class="line">  return cached;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line"> </span><br><span class="line">  Resource&lt;?&gt; cached &#x3D; cache.remove(key);</span><br><span class="line"></span><br><span class="line">  final EngineResource&lt;?&gt; result;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 如果能获取到资源对象 ，则确保通过 EngineResource 进行包装</span><br><span class="line">  if (cached &#x3D;&#x3D; null) &#123;</span><br><span class="line">    result &#x3D; null;</span><br><span class="line">  &#125; else if (cached instanceof EngineResource) &#123;</span><br><span class="line">    &#x2F;&#x2F; Save an object allocation if we&#39;ve cached an EngineResource (the typical case).</span><br><span class="line">    result &#x3D; (EngineResource&lt;?&gt;) cached;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result &#x3D;</span><br><span class="line">        new EngineResource&lt;&gt;(</span><br><span class="line">            cached, &#x2F;*isMemoryCacheable&#x3D;*&#x2F; true, &#x2F;*isRecyclable&#x3D;*&#x2F; true, key, &#x2F;*listener&#x3D;*&#x2F; this);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在二次的内存获取中，是从 <code>MemoryCache</code>进行获取，以下还是先对 <code>MemoryCache</code> 初步了解</p><h5 id="LruResourceCache-实现-MemoryCache"><a href="#LruResourceCache-实现-MemoryCache" class="headerlink" title="LruResourceCache 实现 MemoryCache"></a>LruResourceCache 实现 MemoryCache</h5><p><code>MemoryCache</code> 是一个缓存接口，该缓存可以通过<code>GlideBuilder.setMemoryCache</code> 进行创建，默认情况下所构造的实现类是<code>LruResourceCache</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final class GlideBuilder &#123;</span><br><span class="line">  ...    </span><br><span class="line">  Glide build(@NonNull Context context) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (memorySizeCalculator &#x3D;&#x3D; null) &#123;</span><br><span class="line">      memorySizeCalculator &#x3D; new MemorySizeCalculator.Builder(context).build();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (memoryCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">      memoryCache &#x3D; new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (diskCacheFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      diskCacheFactory &#x3D; new InternalCacheDiskCacheFactory(context);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return new Glide(</span><br><span class="line">        context,</span><br><span class="line">        engine,</span><br><span class="line">        memoryCache,</span><br><span class="line">        bitmapPool,</span><br><span class="line">        arrayPool,</span><br><span class="line">        requestManagerRetriever,</span><br><span class="line">        connectivityMonitorFactory,</span><br><span class="line">        logLevel,</span><br><span class="line">        defaultRequestOptionsFactory,</span><br><span class="line">        defaultTransitionOptions,</span><br><span class="line">        defaultRequestListeners,</span><br><span class="line">        isLoggingRequestOriginsEnabled,</span><br><span class="line">        isImageDecoderEnabledForBitmaps);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>LruResourceCache</code> 默认继承自 <code>LruCache</code>实现了Lru的能力，而<code>MemoryCache</code>接口方法 默被<code>LruCache</code>所实现。<br>因此可以说 <code>LruResouceCache</code> 即为一个资源的 Lru 缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class LruResourceCache extends LruCache&lt;Key, Resource&lt;?&gt;&gt; implements MemoryCache &#123;</span><br><span class="line">  private ResourceRemovedListener listener;</span><br><span class="line"></span><br><span class="line">  public LruResourceCache(long size) &#123;</span><br><span class="line">    super(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 默认被 Engine 注册    </span><br><span class="line">  @Override</span><br><span class="line">  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) &#123;</span><br><span class="line">    this.listener &#x3D; listener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onItemEvicted(@NonNull Key key, @Nullable Resource&lt;?&gt; item) &#123;</span><br><span class="line">    if (listener !&#x3D; null &amp;&amp; item !&#x3D; null) &#123;</span><br><span class="line">      listener.onResourceRemoved(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 重写 LruCache.getSize 方法，LruCache 的 maxSize 以资源自身自己的实际 size 为计算标准    </span><br><span class="line">  @Override</span><br><span class="line">  protected int getSize(@Nullable Resource&lt;?&gt; item) &#123;</span><br><span class="line">    if (item &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return super.getSize(null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return item.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressLint(&quot;InlinedApi&quot;)</span><br><span class="line">  @Override</span><br><span class="line">  public void trimMemory(int level) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据系统回调的缓存回收等级，进行该缓存对应的缓存释放或者缩容</span><br><span class="line">    if (level &gt;&#x3D; android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) &#123;</span><br><span class="line">      &#x2F;&#x2F; 清空该缓存所有资源    </span><br><span class="line">      clearMemory();</span><br><span class="line">    &#125; else if (level &gt;&#x3D; android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN</span><br><span class="line">        || level &#x3D;&#x3D; android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) &#123;</span><br><span class="line">      &#x2F;&#x2F; 缩容为最大容量的一半        </span><br><span class="line">      trimToSize(getMaxSize() &#x2F; 2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="根据屏幕像素对LruResourceCache初始容量设定"><a href="#根据屏幕像素对LruResourceCache初始容量设定" class="headerlink" title="根据屏幕像素对LruResourceCache初始容量设定"></a>根据屏幕像素对LruResourceCache初始容量设定</h5><p><code>LruResourceCache</code> 对应容量的设定是根据 <code>MemorySizeCalculator.getMemoryCacheSize()</code>进行设定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public final class MemorySizeCalculator &#123;</span><br><span class="line"> static final int BYTES_PER_ARGB_8888_PIXEL &#x3D; 4</span><br><span class="line"> ...    </span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认为 2 </span><br><span class="line">    @Synthetic float memoryCacheScreens &#x3D; MEMORY_CACHE_TARGET_SCREENS; </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据版本  Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O ? 4 : 1</span><br><span class="line">    @Synthetic float bitmapPoolScreens &#x3D; BITMAP_POOL_TARGET_SCREENS; </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 默认为 0.4f</span><br><span class="line">    @Synthetic float maxSizeMultiplier &#x3D; MAX_SIZE_MULTIPLIER;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 默认为 0.33f</span><br><span class="line">    @Synthetic float lowMemoryMaxSizeMultiplier &#x3D; LOW_MEMORY_MAX_SIZE_MULTIPLIER</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 默认为 4 * 1024 * 1024   4MB</span><br><span class="line">    @Synthetic int arrayPoolSizeBytes &#x3D; ARRAY_POOL_SIZE_BYTES;    </span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">    </span><br><span class="line"> MemorySizeCalculator(MemorySizeCalculator.Builder builder) &#123;</span><br><span class="line">    this.context &#x3D; builder.context;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 低设备为正常设备一半的内存数量，默认为 2MB，正常设备为 4MB，该内存用于设置 LruArrayPool 初始化容量</span><br><span class="line">    arrayPoolSize &#x3D;</span><br><span class="line">        isLowMemoryDevice(builder.activityManager)</span><br><span class="line">            ? builder.arrayPoolSizeBytes &#x2F; LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR</span><br><span class="line">            : builder.arrayPoolSizeBytes;</span><br><span class="line">            </span><br><span class="line">    int maxSize &#x3D;</span><br><span class="line">        getMaxSize(</span><br><span class="line">            builder.activityManager, builder.maxSizeMultiplier, builder.lowMemoryMaxSizeMultiplier);</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    int widthPixels &#x3D; builder.screenDimensions.getWidthPixels();</span><br><span class="line">    int heightPixels &#x3D; builder.screenDimensions.getHeightPixels();</span><br><span class="line">     &#x2F;&#x2F; 计算一屏幕像素的字节数</span><br><span class="line">    int screenSize &#x3D; widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 图片缓存池，在 Android O 之下提供 4 屏像素字节数内存，否则 1 屏</span><br><span class="line">    int targetBitmapPoolSize &#x3D; Math.round(screenSize * builder.bitmapPoolScreens);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 内存缓存的大小提供 2 屏像素字节大小</span><br><span class="line">    int targetMemoryCacheSize &#x3D; Math.round(screenSize * builder.memoryCacheScreens);</span><br><span class="line">    int availableSize &#x3D; maxSize - arrayPoolSize;</span><br><span class="line"></span><br><span class="line">    if (targetMemoryCacheSize + targetBitmapPoolSize &lt;&#x3D; availableSize) &#123;</span><br><span class="line">      memoryCacheSize &#x3D; targetMemoryCacheSize;</span><br><span class="line">      bitmapPoolSize &#x3D; targetBitmapPoolSize;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      float part &#x3D; availableSize &#x2F; (builder.bitmapPoolScreens + builder.memoryCacheScreens);</span><br><span class="line">      memoryCacheSize &#x3D; Math.round(part * builder.memoryCacheScreens);</span><br><span class="line">      bitmapPoolSize &#x3D; Math.round(part * builder.bitmapPoolScreens);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  public int getMemoryCacheSize() &#123;</span><br><span class="line">    return memoryCacheSize;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  private static int getMaxSize(</span><br><span class="line">      ActivityManager activityManager, </span><br><span class="line">      float maxSizeMultiplier, </span><br><span class="line">      float lowMemoryMaxSizeMultiplier</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#x2F;&#x2F; activityManager.getMemoryClass() 是系统所提供的API，用于返回当前进程所分配的最大物理内存</span><br><span class="line">    &#x2F;&#x2F; 包含 native heap 和 java heap ，返回单位为 M，memoryClassBytes 转化为字节数</span><br><span class="line">    final int memoryClassBytes &#x3D; activityManager.getMemoryClass() * 1024 * 1024;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否为低内存设备</span><br><span class="line">    final boolean isLowMemoryDevice &#x3D; isLowMemoryDevice(activityManager);</span><br><span class="line">    </span><br><span class="line">    return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier : maxSizeMultiplier));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 判断是否为低内存设备</span><br><span class="line">  static boolean isLowMemoryDevice(ActivityManager activityManager) &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      return activityManager.isLowRamDevice();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Glide 使用 <code>MemorySizeCalculator</code> 对内存缓存根据设备情况进行自动计算，</p><p>如果默认剩余可用内存大于所需要提供的 2 屏幕像素内存，则直接申请为当前屏幕的两屏幕内存，如果不足，则根据当前剩余可用内存占比，按比例申请 2 屏幕像素内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (targetMemoryCacheSize + targetBitmapPoolSize &lt;&#x3D; availableSize) &#123;</span><br><span class="line">  memoryCacheSize &#x3D; targetMemoryCacheSize;</span><br><span class="line">  bitmapPoolSize &#x3D; targetBitmapPoolSize;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  float part &#x3D; availableSize &#x2F; (builder.bitmapPoolScreens + builder.memoryCacheScreens);</span><br><span class="line">  memoryCacheSize &#x3D; Math.round(part * builder.memoryCacheScreens);</span><br><span class="line">  bitmapPoolSize &#x3D; Math.round(part * builder.bitmapPoolScreens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自此对 <code>LruResourceCache</code> 有些初步了解</p><h1 id="资源创建"><a href="#资源创建" class="headerlink" title="资源创建"></a>资源创建</h1><p>回到对 <code>MemoryCache</code> 获取后的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">  EngineResource&lt;?&gt; cached &#x3D; getEngineResourceFromCache(key);</span><br><span class="line">  if (cached !&#x3D; null) &#123;</span><br><span class="line">    cached.acquire();</span><br><span class="line">    activeResources.activate(key, cached);</span><br><span class="line">  &#125;</span><br><span class="line">  return cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能从<code>MemoryCache</code>获取到指定的资源，则将该资源从<code>MemoryCache</code> 移除，并且转移到工作缓存中<code>ActiveResources</code>。</p><p>如果没有获得，那么就需要对资源进行主动创建了，</p><p>代码回到 <code>Engine.load</code>，如果资源未获得成功，则通过<code>waitForExistingOrStartNewJob</code>进行创建。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> public &lt;R&gt; LoadStatus load(</span><br><span class="line">      GlideContext glideContext,</span><br><span class="line">      Object model,</span><br><span class="line">      Key signature,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      Class&lt;?&gt; resourceClass,</span><br><span class="line">      Class&lt;R&gt; transcodeClass,</span><br><span class="line">      Priority priority,</span><br><span class="line">      DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">      boolean isTransformationRequired,</span><br><span class="line">      boolean isScaleOnlyOrNoTransform,</span><br><span class="line">      Options options,</span><br><span class="line">      boolean isMemoryCacheable,</span><br><span class="line">      boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">      boolean useAnimationPool,</span><br><span class="line">      boolean onlyRetrieveFromCache,</span><br><span class="line">      ResourceCallback cb,</span><br><span class="line">      Executor callbackExecutor) &#123;</span><br><span class="line">      ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      if (memoryResource &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行任务的创建</span><br><span class="line">        return waitForExistingOrStartNewJob(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            options,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            cb,</span><br><span class="line">            callbackExecutor,</span><br><span class="line">            key,</span><br><span class="line">            startTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">private &lt;R&gt; LoadStatus waitForExistingOrStartNewJob(</span><br><span class="line">      GlideContext glideContext,</span><br><span class="line">      Object model,</span><br><span class="line">      Key signature,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      Class&lt;?&gt; resourceClass,</span><br><span class="line">      Class&lt;R&gt; transcodeClass,</span><br><span class="line">      Priority priority,</span><br><span class="line">      DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">      boolean isTransformationRequired,</span><br><span class="line">      boolean isScaleOnlyOrNoTransform,</span><br><span class="line">      Options options,</span><br><span class="line">      boolean isMemoryCacheable,</span><br><span class="line">      boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">      boolean useAnimationPool,</span><br><span class="line">      boolean onlyRetrieveFromCache,</span><br><span class="line">      ResourceCallback cb,</span><br><span class="line">      Executor callbackExecutor,</span><br><span class="line">      EngineKey key,</span><br><span class="line">      long startTime) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; jobs 为 Jobs 的实例，目的是作为 EngineJob 的缓存容器</span><br><span class="line">    &#x2F;&#x2F; onlyRetrieveFromCache 为true则表示只加载到内存的任务</span><br><span class="line">    EngineJob&lt;?&gt; current &#x3D; jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    if (current !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果已经存在任务，则将当前所请求的回调添加到请求任务中，并指定回调所执行的</span><br><span class="line">      &#x2F;&#x2F; 线程池，cb ResourceCallback 一般由 SingleRequest 所实现</span><br><span class="line">      current.addCallback(cb, callbackExecutor);</span><br><span class="line">      if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 返回一个执行转台的代理，允许对任务进行取消 LoadStatus.cancel 操作</span><br><span class="line">      return new LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有则创建一个 加载任务</span><br><span class="line">    EngineJob&lt;R&gt; engineJob &#x3D;</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建资源解码任务，包装加载后的操作</span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob &#x3D;</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            key,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            options,</span><br><span class="line">            engineJob);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 添加到任务缓存池</span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 启动任务</span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return new LoadStatus(cb, engineJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Glide 对资源加载分为三级：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 ActiveResource 工作缓存中进行尝试加载，如果查询到则返回该资源，否则继续&lt;/li&gt;
&lt;li&gt;如果 ActiveResource 找不到，则通过 MemoryCache 进行查找加载，如果查询到则
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Glide" scheme="http://yoursite.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Glide-生命周期监控</title>
    <link href="http://yoursite.com/2019/06/20/Glide-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%91%E6%8E%A7/"/>
    <id>http://yoursite.com/2019/06/20/Glide-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%91%E6%8E%A7/</id>
    <published>2019-06-20T12:47:07.000Z</published>
    <updated>2020-04-23T12:59:57.639Z</updated>
    
    <content type="html"><![CDATA[<p>在框架中，经常会遇到内存泄漏问题，这就涉及到怎么去感知观测到Activity / Fragment 的生命周期，从而根据该周期进行内存的管理。（大部分情况下这两种组合视图构件，能应对比较多的场景） ，对Glide中，提供了不错的监控方案。</p><h1 id="一、场景的上下文"><a href="#一、场景的上下文" class="headerlink" title="一、场景的上下文"></a>一、场景的上下文</h1><p>在Glide中是需要传入所需要感知的上下文信息，比如  <code>with(Context)</code> ，<code>with(Fragment)</code> 等，这里的上下文不局限于 Context，包括</p><ul><li>Application  </li><li>Fragment  </li><li>Activity</li><li>View </li></ul><blockquote><p>其中对于View的感知是借助于 View 所提供的上下文 <code>View.getContext</code>（这就要求View必须是Attached后的情况了），Glide将最终转化为 <code>Application</code> 或 <code>Activity</code>的感知，而对于嵌套<code>Fragment</code>无法获知，情况比较无解（因为无法从View中直接获得 Fragment的上下文信息，其他办法或许可以，比如标记后遍历获取ViewTree），建议更多的是根据实际情况选择传入的上下文对象。</p></blockquote><h1 id="二、监控和监控器管理"><a href="#二、监控和监控器管理" class="headerlink" title="二、监控和监控器管理"></a>二、监控和监控器管理</h1><h2 id="2-1-Fragment-为例"><a href="#2-1-Fragment-为例" class="headerlink" title="2.1 Fragment 为例"></a>2.1 Fragment 为例</h2><p>从 <code>with(Fragment)</code> 开始入手，通过代码跟着可以进入到实际的管理类<code>RequestManagerRetriever</code> <code>get(Fragment)</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">public RequestManager get(@NonNull Fragment fragment) &#123;</span><br><span class="line">  Preconditions.checkNotNull(</span><br><span class="line">      fragment.getContext(),</span><br><span class="line">      &quot;You cannot start a load on a fragment before it is attached or after it is destroyed&quot;);</span><br><span class="line">  if (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    return get(fragment.getContext().getApplicationContext());</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    FragmentManager fm &#x3D; fragment.getChildFragmentManager();</span><br><span class="line">    return supportFragmentGet(fragment.getContext(), fm, fragment, fragment.isVisible());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于异步下去进行上下文 <code>with</code> 处理，由于可能已经发生泄漏，所以为了避免这个情况，Glide 默认将上下文重置为 <code>Application</code> 上。</p></blockquote><p>  这里继续 <code>supportFragmentGet</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">private RequestManager supportFragmentGet(</span><br><span class="line">    @NonNull Context context,</span><br><span class="line">    @NonNull FragmentManager fm,</span><br><span class="line">    @Nullable Fragment parentHint,</span><br><span class="line">    boolean isParentVisible) &#123;</span><br><span class="line">  SupportRequestManagerFragment current &#x3D;</span><br><span class="line">      getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">  RequestManager requestManager &#x3D; current.getRequestManager();</span><br><span class="line">  if (requestManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; TODO(b&#x2F;27524013): Factor out this Glide.get() call.</span><br><span class="line">    Glide glide &#x3D; Glide.get(context);</span><br><span class="line">    requestManager &#x3D;</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  return requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  @NonNull</span><br><span class="line">private SupportRequestManagerFragment getSupportRequestManagerFragment(</span><br><span class="line">    @NonNull final FragmentManager fm, @Nullable Fragment parentHint, boolean isParentVisible) &#123;</span><br><span class="line">  SupportRequestManagerFragment current &#x3D;</span><br><span class="line">      (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);</span><br><span class="line">  if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">    current &#x3D; pendingSupportRequestManagerFragments.get(fm);</span><br><span class="line">    if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">      current &#x3D; new SupportRequestManagerFragment();</span><br><span class="line">      current.setParentFragmentHint(parentHint);</span><br><span class="line">      if (isParentVisible) &#123;</span><br><span class="line">        current.getGlideLifecycle().onStart();</span><br><span class="line">      &#125;</span><br><span class="line">      pendingSupportRequestManagerFragments.put(fm, current);</span><br><span class="line">      fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();</span><br><span class="line">      handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两结合一起看，比较直观的可以知道 <code>SupportRequestManagerFragment</code> 是作为一个监控器的存在，寄宿于 FragmentMananger 中，负责对 Fragment 的生命周期进行监控。</p><blockquote><p>由于 <code>commit</code> 操作可能不是同步执行（因为commit 只会在主线程中执行，如果在异步中则post回主线程后执行），因此这里暂时暂存在 <code>pendingSupportRequestManagerFragments</code> ，防止重复创建添加 <code>Fragment</code>，需要等待主线程的 <code>handler</code> 完成回调才能从 <code>pendingSupportRequestManagerFragments</code> 移除（因为这时候已经commit 成功了）。</p></blockquote><blockquote><p>Glide 在 <code>SupportRequestManagerFragment</code> 也提供了一套生命周期订阅器， 如果当前 Fragment 已展示，则补充对该订阅者们的 onStart()事件</p></blockquote><p>另外针对非 Support 下 Fragment 的 兼容，可以忽律，目前google也不再维护，只作为补充兼容来看，具体内容以下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private android.app.Fragment findFragment(@NonNull View target, @NonNull Activity activity) &#123;</span><br><span class="line">  tempViewToFragment.clear();</span><br><span class="line">  findAllFragmentsWithViews(activity.getFragmentManager(), tempViewToFragment);</span><br><span class="line"></span><br><span class="line">  android.app.Fragment result &#x3D; null;</span><br><span class="line"></span><br><span class="line">  View activityRoot &#x3D; activity.findViewById(android.R.id.content);</span><br><span class="line">  View current &#x3D; target;</span><br><span class="line">  while (!current.equals(activityRoot)) &#123;</span><br><span class="line">    result &#x3D; tempViewToFragment.get(current);</span><br><span class="line">    if (result !&#x3D; null) &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (current.getParent() instanceof View) &#123;</span><br><span class="line">      current &#x3D; (View) current.getParent();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  tempViewToFragment.clear();</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说，Glide 通过将自己实现的<code>Fragment</code> 添加到相应目标下的 <code>FragmentManager</code> 中进行驻留。可以实现两个好处：</p><ul><li>依赖系统提供回调，可以对上下文对象的生命周期进行观察</li><li>依赖<code>FragmentManager</code>、<code>ChildFragmentManager</code>对<code>Fragment</code>的管理，监视器<code>Fragment</code>不需要自己维护，可跟随上下文对象生命周期的结束自动释放，无需担心内存泄漏</li></ul><h2 id="2-2-Activity"><a href="#2-2-Activity" class="headerlink" title="2.2 Activity"></a>2.2 Activity</h2><p>有了以上的大概描述，就不难理解Activity是怎么追踪的，因为在Actvity 的<code>FragmentManager</code>（<code>SupportFragmentActivity</code>）的 <code>Fragment</code>也是可以感知当前宿主的生命周期，所以同理，在对应的Manager 中 add 如自己的监控器<code>SupportRequestManagerFragment</code>。</p><h2 id="2-3-Application"><a href="#2-3-Application" class="headerlink" title="2.3 Application"></a>2.3 Application</h2><p>另外这里面比较特殊的是 <code>Application</code> 上下文对象的处理，由于跟随的是整个 App 的周期，因此无需担心内存泄漏问题。因此在全局的<code>RequestManagerRetriever</code> 中单独维护了一个全局的 <code>RequesterManager</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class RequestManagerRetriever implements Handler.Callback &#123;</span><br><span class="line"> ...</span><br><span class="line"> private volatile RequestManager applicationManager;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、监控器中的维护"><a href="#三、监控器中的维护" class="headerlink" title="三、监控器中的维护"></a>三、监控器中的维护</h1><p><code>SupportRequestManagerFragment</code> 需要维护几个内容</p><ul><li>维护自身及子Fragment的响应，<code>RequestManagerTreeNode</code> 提供自身向下<code>SupportRequestManagerFragment</code> 子节点的 <code>RequestMananger</code> 的沟通，对于经常看到的场景，我们在移除父Fragment后，同时也需要影响子 <code>RequestManager</code>的内容</li><li>提供<code>ActivityFragmentLifecycle</code>观察者注册，暴露周期观察接口，为其他功能观察当前上下文的生命周期提供入口。</li></ul><blockquote><p><code>SupportRequestManagerFragment</code> 并不直接负责 <code>RequestManger</code>的调用，只是提供构造和存在。</p></blockquote><blockquote><p><code>SupportRequestManagerFragment</code> 会在Fragment 发生 Attach 后，执行 root Fragment 绑定，维护父子节点的的关联关系（<code>rootRequestManagerFragment</code>、<code>childRequestManagerFragments</code>）</p></blockquote><p>基本上 <code>SupportRequestManagerFragment</code> 是作为该上下文中所独有内容的贮存的存在，并且维护着该上下文可能存在的关联关系，比如多个Fragment 嵌套时的关联沟通。属于承上启下适配器角色。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在框架中，经常会遇到内存泄漏问题，这就涉及到怎么去感知观测到Activity / Fragment 的生命周期，从而根据该周期进行内存的管理。（大部分情况下这两种组合视图构件，能应对比较多的场景） ，对Glide中，提供了不错的监控方案。&lt;/p&gt;
&lt;h1 id=&quot;一、场景的
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Glide" scheme="http://yoursite.com/tags/Glide/"/>
    
  </entry>
  
  <entry>
    <title>Android Q适配</title>
    <link href="http://yoursite.com/2019/05/14/AndroidQ%E9%80%82%E9%85%8D/"/>
    <id>http://yoursite.com/2019/05/14/AndroidQ%E9%80%82%E9%85%8D/</id>
    <published>2019-05-14T15:52:50.000Z</published>
    <updated>2020-04-14T15:55:09.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Activity-行为变更-无影响"><a href="#一、Activity-行为变更-无影响" class="headerlink" title="一、Activity 行为变更(无影响)"></a>一、Activity 行为变更(无影响)</h1><p>限制后台自启动Activity行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">允许Activity启动条件</span><br><span class="line">* 应用具有可见窗口（Activity）</span><br><span class="line">* 返回栈有一项 Activity</span><br><span class="line">* 应用具有最近启动的 Activity</span><br></pre></td></tr></table></figure><h1 id="二、权限变更-目前没影响，如果需要支持SYSTEM-ALERT-WINDOW权限，则检查"><a href="#二、权限变更-目前没影响，如果需要支持SYSTEM-ALERT-WINDOW权限，则检查" class="headerlink" title="二、权限变更(目前没影响，如果需要支持SYSTEM_ALERT_WINDOW权限，则检查)"></a>二、权限变更(目前没影响，如果需要支持SYSTEM_ALERT_WINDOW权限，则检查)</h1><ul><li>对于全屏通知需要添加 USE_FULL_SCREEN_INTENT 权限，该权限为为普通权限（建议加上）</li><li>Android Q（Go版本）设备上运行的应用无法获得 SYSTEM_ALERT_WINDOW 权限，如果所升级设备以及有该权限，则升级后，Android Q 还会保留该权限，否则无法获得该权限。</li></ul><h1 id="三、窗口适配调整、多窗口支持（影响，需要调整）"><a href="#三、窗口适配调整、多窗口支持（影响，需要调整）" class="headerlink" title="三、窗口适配调整、多窗口支持（影响，需要调整）"></a>三、窗口适配调整、多窗口支持（影响，需要调整）</h1><p>主要变更方向：新屏宽比适配，多窗口支持</p><ul><li><p>通过 resizeableActivity = false 来设置不支持多窗口</p></li><li><p>分屏、多窗口后支持多个窗口同时响应 onResume()、onPause()，新增一种多窗口状态，“ 在最顶层处于已恢复状态” (Q之前版本，一次只能恢复一个Activity，其他处于 Pause状态)，系统根据 Z-Order 分配至Activity 互动优先级，新增 onTopResumedActivityChanged() 回调区分该状态响应</p></li><li><p>支持新的尺寸比例 1: 1 4:3 3:2 等， 关联 <code>android:minAspectRatio</code>、<code>android:maxAspectRatio</code>声明，如果屏幕超出限制，则处于兼容模式</p></li><li><p>推荐跨窗口功能（窗口拖放数据）支持（android N开始支持）</p></li></ul><p><a href="https://developer.android.com/preview/features/foldables#new_screen_ratios" target="_blank" rel="noopener">多窗口适配</a></p><h3 id="三、非公开SDK变更"><a href="#三、非公开SDK变更" class="headerlink" title="三、非公开SDK变更"></a>三、非公开SDK变更</h3><p><a href="https://developer.android.com/preview/non-sdk-q" target="_blank" rel="noopener">接口列表</a></p><p>动态测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您还可以利用 StrictMode API 来测试您的应用是否使用非 SDK 接口。请使用 detectNonSdkApiUsage 方法来启用此 API。启用 StrictMode API 后，您可以使用 penaltyListener 来接收每次使用非 SDK 接口的行为所对应的回调，并且您可以在其中实现自定义处理。回调中提供的 Violation 对象派生自 Throwable，并且封闭式堆栈轨迹会提供相应使用行为的上下文。</span><br></pre></td></tr></table></figure><p>静态代码扫描测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">使用 veridex 工具进行测试</span><br><span class="line">您还可以在 APK 上运行静态分析工具 veridex。veridex 工具会扫描 APK 的整个代码库（包括所有第三方库），并报告发现的所有使用非 SDK 接口的行为。</span><br><span class="line"></span><br><span class="line">veridex 工具存在以下局限性：</span><br><span class="line"></span><br><span class="line">它无法检测到通过 JNI 实现的调用。</span><br><span class="line">它只能检测到一部分通过反射实现的调用。</span><br><span class="line">它对非活动代码路径的分析仅限于 API 级别的检查。</span><br></pre></td></tr></table></figure><h1 id="四、隐私变更"><a href="#四、隐私变更" class="headerlink" title="四、隐私变更"></a>四、隐私变更</h1><h2 id="定位（不影响，目前前台定位）"><a href="#定位（不影响，目前前台定位）" class="headerlink" title="定位（不影响，目前前台定位）"></a>定位（不影响，目前前台定位）</h2><p>主要变更方向：限制后台定位能力</p><ul><li><p>ACCESS_FINE_LOCATION 、ACCESS_COARSE_LOCATIN 在 Q 后仅限于前台请求设备位置信息，如果需要后台请求位置信息，则需要 ACCESS_BACKGROUND_LOCATION 权限，用户会收到定位提醒</p></li><li><p>方式位置信息，授权弹框，用户需要授予定位仅限前台使用或始终（前台和后台）使用。</p></li><li><p>如果 Target 9 或更低，系统将自动安装期间将 ACCESS_BACKGROUND_LOCATION 添加到 <uses-permission> 元素中。</uses-permission></p></li><li><p>前台服务类型需要添加 android:foregroundServiceType=”location” 属性</p></li><li><p>每次启动定位服务都需要判断定位权限，用户可以在任何时机取消定位授权</p></li></ul><h2 id="存储（升级Target有影响）"><a href="#存储（升级Target有影响）" class="headerlink" title="存储（升级Target有影响）"></a>存储（升级Target有影响）</h2><p>推行应用分区存储。</p><ul><li>Target Q 以后，访问外部存储设备中的文件会对所查看的内容进行特定应用目录和特定类型的媒体过滤，访问这些文件不需要任何权限。</li><li>Target Android 9 及其之下存储方式没有任何变化，也可以通过 reqeustLegacyExternalStorage 开启 Android Q的新存储行为。</li><li>READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE 在Q中权限移除</li><li><code>Context.getExternalFilesDir()</code>用于访问自己特定目录</li><li>访问其他应用创建的文件，需要获得<code>READ_EXTERNAL_STORAGE</code>权限，并且需要明确指定 MediaStore.Images、MediaStore.Video、MediaStore.Audio 媒体集合，通过存储访问框架进行访问 <code>MediaStore</code>、<code>DocumentsProvider</code></li><li>系统媒体需要对应的媒体动态访问权限、READ_MEDIA_IMAGES,READ_MEDIA_VIDEO 或 READ_MEDIA_AUDIO</li><li>照片中的位置信息，需要添加 ACCESS_MEDIA_LOCATION 权限</li><li>明年，所有应用都需要分区存储，无论哪种SDK级别</li></ul><h2 id="设备标识符（升不升级都有影响）"><a href="#设备标识符（升不升级都有影响）" class="headerlink" title="设备标识符（升不升级都有影响）"></a>设备标识符（升不升级都有影响）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[最佳实践](https:&#x2F;&#x2F;developer.android.com&#x2F;training&#x2F;articles&#x2F;user-data-ids)</span><br><span class="line"></span><br><span class="line">[特殊属性](https:&#x2F;&#x2F;googledeveloperschina.blogspot.com&#x2F;2017&#x2F;04&#x2F;android-o.html)</span><br><span class="line"></span><br><span class="line">Android Q上运行的应用开始，需要具有&#96;READ_PRIVILEGED_PHONE_STATE&#96;权限才能访问设备唯一标识（IMEI和序列号）</span><br><span class="line"></span><br><span class="line">* Traget Q 应用访问将发生 SecurityException</span><br><span class="line">* 之下应用如果有 READ_PHONE_STATE 权限将返回null或占位符数据，否则SecurityException</span><br></pre></td></tr></table></figure><h3 id="IMEI、DeviceID-影响，已无法获取"><a href="#IMEI、DeviceID-影响，已无法获取" class="headerlink" title="IMEI、DeviceID(影响，已无法获取)"></a>IMEI、DeviceID(影响，已无法获取)</h3><h3 id="AndroidID（影响，签名一致不影响）"><a href="#AndroidID（影响，签名一致不影响）" class="headerlink" title="AndroidID（影响，签名一致不影响）"></a>AndroidID（影响，签名一致不影响）</h3><p>在Q运行的应用，每个独立签名应用所产生的AndroidId不一样（包名无关）。</p><ul><li>应用 target 升级，对AndroidId 不会产生影响</li></ul><h3 id="MAC（不影响，一直都不能正确获取）"><a href="#MAC（不影响，一直都不能正确获取）" class="headerlink" title="MAC（不影响，一直都不能正确获取）"></a>MAC（不影响，一直都不能正确获取）</h3><p>Android Q 会传输随机选择的 MAC 地址，目前vivo升级返回固定 伪Mac “02:00:00:00:00:00”</p><h3 id="数盟ID（不影响，无变化）"><a href="#数盟ID（不影响，无变化）" class="headerlink" title="数盟ID（不影响，无变化）"></a>数盟ID（不影响，无变化）</h3><h3 id="USB-序列号需要用户授权访问（无影响）"><a href="#USB-序列号需要用户授权访问（无影响）" class="headerlink" title="USB 序列号需要用户授权访问（无影响）"></a>USB 序列号需要用户授权访问（无影响）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 获取随机分配的 MAC 地址：设备所有者应用和配置文件所有者应用可以通过调用 getRandomizedMacAddress() 检索分配给特定网络的随机 MAC 地址。</span><br><span class="line">* 获取实际的出厂 MAC 地址：设备所有者应用可以通过调用 getWifiMacAddress() 检索设备的实际硬件 MAC 地址。此方法对于跟踪设备队列非常有用。</span><br><span class="line">* Android Q 撤消了 &#x2F;proc&#x2F;net 访问权限，其中包含有关设备网络状态的信息。需要访问此信息的应用（如 VPN）应引用 NetworkStatsManager 和 ConnectivityManager 类。</span><br></pre></td></tr></table></figure><h2 id="粘贴板（不影响）"><a href="#粘贴板（不影响）" class="headerlink" title="粘贴板（不影响）"></a>粘贴板（不影响）</h2><p>Android Q运行应用需要有前台窗口焦点才能访问粘贴板数据，否则无法访问到，返回空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 除非您的应用是默认输入法 (IME) 或是目前处于焦点的应用，否则应用无法访问剪贴板数据。</span><br></pre></td></tr></table></figure><h1 id="五、其他新增"><a href="#五、其他新增" class="headerlink" title="五、其他新增"></a>五、其他新增</h1><h2 id="设置面板（局部弹窗，考虑引导启动网络）"><a href="#设置面板（局部弹窗，考虑引导启动网络）" class="headerlink" title="设置面板（局部弹窗，考虑引导启动网络）"></a>设置面板（局部弹窗，考虑引导启动网络）</h2><p>可以在用户不离开的情况下，启动NFC或移动数据等基础设置(类似弹窗)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val panelIntent &#x3D; Intent(Settings.Panel.settings_panel_type)</span><br><span class="line">    startActivityForResult(panelIntent)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">settings_panel_type 可以是下列项之一：</span><br><span class="line"></span><br><span class="line">ACTION_INTERNET_CONNECTIVITY</span><br><span class="line">显示与互联网连接相关的设置，例如飞行模式、WLAN 和移动数据。</span><br><span class="line">ACTION_WIFI：</span><br><span class="line">显示 WLAN 设置，但不显示其他连接设置。这对于需要 WLAN 连接以执行大容量上传或下载的应用非常有用。</span><br><span class="line">ACTION_NFC</span><br><span class="line">显示与近距离无线通信 (NFC) 相关的所有设置。</span><br><span class="line">ACTION_VOLUME</span><br><span class="line">显示所有音频流的音量设置。</span><br></pre></td></tr></table></figure><h2 id="前台服务类型（不影响，语法糖）"><a href="#前台服务类型（不影响，语法糖）" class="headerlink" title="前台服务类型（不影响，语法糖）"></a>前台服务类型（不影响，语法糖）</h2><p>新增前台服务声明（不需要代码设置前台效果） </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Android Q 引入了一个新的 XML 清单属性 foregroundServiceType，您可以将其包含在多项特定服务的定义中。虽然很少适用，但您可以为一项特定服务分配多个前台服务类型。</span><br><span class="line"></span><br><span class="line">下表显示了不同的前台服务类型，以及适合在其中声明特定类型的服务：</span><br><span class="line"></span><br><span class="line">前台服务类型应声明相应类型的服务的示例使用情形</span><br><span class="line">connectedDevice监控穿戴式设备健身跟踪器</span><br><span class="line">dataSync从网络下载文件</span><br><span class="line">location延续用户发起的操作</span><br><span class="line">mediaPlayback播放有声读物、播客或音乐</span><br><span class="line">mediaProjection简短地录屏</span><br><span class="line">phoneCall处理正在进行的通话</span><br></pre></td></tr></table></figure><h1 id="六、图标兼容"><a href="#六、图标兼容" class="headerlink" title="六、图标兼容"></a>六、图标兼容</h1><p>对旧图标缩小处理，需要支持新的svg图标，由于各个厂商定制的ROM</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Activity-行为变更-无影响&quot;&gt;&lt;a href=&quot;#一、Activity-行为变更-无影响&quot; class=&quot;headerlink&quot; title=&quot;一、Activity 行为变更(无影响)&quot;&gt;&lt;/a&gt;一、Activity 行为变更(无影响)&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp</title>
    <link href="http://yoursite.com/2019/05/01/OkHttp/"/>
    <id>http://yoursite.com/2019/05/01/OkHttp/</id>
    <published>2019-05-01T10:20:10.000Z</published>
    <updated>2020-04-10T12:44:24.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、主要构件"><a href="#一、主要构件" class="headerlink" title="一、主要构件"></a>一、主要构件</h1><ul><li>OkhttpClient 请求总引擎代理</li><li>Request 请求体信息，通过Request.Builder构造，请求头、请求体信息</li><li>Call 请求连接代理，通过Call可以决定是同步还异步请求处理</li><li>Dispatcher 接收同步/异步请求要求，根据要求对请求进行同步/异步分发</li><li>Interceptor</li></ul><h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.squareup.okhttp3:okhttp:4.4.0&#39;</span><br><span class="line">&#x2F;&#x2F; 单元测试依赖</span><br><span class="line">testImplementation &#39;com.squareup.okhttp3:mockwebserver:4.4.0&#39;</span><br></pre></td></tr></table></figure><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22726/32DF5E930CAC4F18990DCC8E5E18F7D6"  alt="image"></p><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><ul><li>创建OkHttpClient和Request（Request.Builder）对象</li><li>将Request封装Call对象</li><li>调用Call.execute()发起同步请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client &#x3D; new OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build();</span><br><span class="line">Request request &#x3D; new Request.Builder().url(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;).get().build();</span><br><span class="line">Call call &#x3D; client.newCall(request);</span><br><span class="line">try &#123;</span><br><span class="line">    Response response &#x3D; call.execute(); &#x2F;&#x2F; 发送同步请求后将进入阻塞状态</span><br><span class="line">    System.out.println(response.body().string())</span><br><span class="line">&#125; catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><ul><li>创建OkHttpClient和Request（Request.Builder）对象</li><li>将Request封装Call对象</li><li>调用Call.enqueue()发起同步请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client &#x3D; new OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build();</span><br><span class="line">Request request &#x3D; new Request.Builder().url(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;).get().build();</span><br><span class="line">Call call &#x3D; client.newCall(request);</span><br><span class="line">call.enqueue(new Callback()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理异常，注意该处理都是在子线程里面处理的</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void onResponse(Call call, Response response) throw IOException&#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 成功 Response，该处理是在子线程里面处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">try &#123;</span><br><span class="line">    Response response &#x3D; call.execute(); &#x2F;&#x2F; 发送同步请求后将进入阻塞状态</span><br><span class="line">    System.out.println(response.body().string())</span><br><span class="line">&#125; catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Builder-配置"><a href="#Builder-配置" class="headerlink" title="Builder 配置"></a>Builder 配置</h2><p>Builder 提供了大量的配置内容，可以根据自己的需求进行对应的配置生成 Client</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> public static final class Builder &#123;</span><br><span class="line">        Dispatcher dispatcher; &#x2F;&#x2F;调度器</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 代理类，默认有三种代理模式DIRECT(直连),HTTP（http代理）,SOCKS（socks代理）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable Proxy proxy;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 协议集合，协议类，用来表示使用的协议版本，比如&#96;http&#x2F;1.0,&#96;http&#x2F;1.1,&#96;spdy&#x2F;3.1,&#96;h2等</span><br><span class="line">         *&#x2F;</span><br><span class="line">        List&lt;Protocol&gt; protocols;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 连接规范，用于配置Socket连接层。对于HTTPS，还能配置安全传输层协议（TLS）版本和密码套件</span><br><span class="line">         *&#x2F;</span><br><span class="line">        List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class="line">        &#x2F;&#x2F;拦截器，可以监听、重写和重试请求等</span><br><span class="line">        &#x2F;&#x2F; interceptors 针对所有连接情况，包括websocket</span><br><span class="line">        final List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F; 针对非websocket的连接</span><br><span class="line">        final List&lt;Interceptor&gt; networkInterceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        EventListener.Factory eventListenerFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 代理选择类，默认不使用代理，即使用直连方式，当然，我们可以自定义配置，</span><br><span class="line">         * 以指定URI使用某种代理，类似代理软件的PAC功能</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ProxySelector proxySelector;</span><br><span class="line">        &#x2F;&#x2F;Cookie的保存获取</span><br><span class="line">        CookieJar cookieJar;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 缓存类，内部使用了DiskLruCache来进行管理缓存，匹配缓存的机制不仅仅是根据url，</span><br><span class="line">         * 而且会根据请求方法和请求头来验证是否可以响应缓存。此外，仅支持GET请求的缓存</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable Cache cache;</span><br><span class="line">        &#x2F;&#x2F;内置缓存</span><br><span class="line">        @Nullable InternalCache internalCache;</span><br><span class="line">        &#x2F;&#x2F;Socket的抽象创建工厂，通过createSocket来创建Socket</span><br><span class="line">        SocketFactory socketFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 安全套接层工厂，HTTPS相关，用于创建SSLSocket。一般配置HTTPS证书信任问题都需要从这里着手。</span><br><span class="line">         * 对于不受信任的证书一般会提示</span><br><span class="line">         * javax.net.ssl.SSLHandshakeException异常。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable SSLSocketFactory sslSocketFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 证书链清洁器，HTTPS相关，用于从[Java]的TLS API构建的原始数组中统计有效的证书链，</span><br><span class="line">         * 然后清除跟TLS握手不相关的证书，提取可信任的证书以便可以受益于证书锁机制。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable CertificateChainCleaner certificateChainCleaner;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 主机名验证器，与HTTPS中的SSL相关，当握手时如果URL的主机名</span><br><span class="line">         * 不是可识别的主机，就会要求进行主机名验证</span><br><span class="line">         *&#x2F;</span><br><span class="line">        HostnameVerifier hostnameVerifier;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 证书锁，HTTPS相关，用于约束哪些证书可以被信任，可以防止一些已知或未知</span><br><span class="line">         * 的中间证书机构带来的攻击行为。如果所有证书都不被信任将抛出SSLPeerUnverifiedException异常。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        CertificatePinner certificatePinner;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 身份认证器，当连接提示未授权时，可以通过重新设置请求头来响应一个</span><br><span class="line">         * 新的Request。状态码401表示远程服务器请求授权，407表示代理服务器请求授权。</span><br><span class="line">         * 该认证器在需要时会被RetryAndFollowUpInterceptor触发。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Authenticator proxyAuthenticator;</span><br><span class="line">        Authenticator authenticator;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 连接池</span><br><span class="line">         *</span><br><span class="line">         * 我们通常将一个客户端和服务端和连接抽象为一个 connection，</span><br><span class="line">         * 而每一个 connection 都会被存放在 connectionPool 中，由它进行统一的管理，</span><br><span class="line">         * 例如有一个相同的 http 请求产生时，connection 就可以得到复用</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ConnectionPool connectionPool;</span><br><span class="line">        &#x2F;&#x2F;域名解析系统</span><br><span class="line">        Dns dns;</span><br><span class="line">        &#x2F;&#x2F;是否遵循SSL重定向</span><br><span class="line">        boolean followSslRedirects;</span><br><span class="line">        &#x2F;&#x2F;是否重定向</span><br><span class="line">        boolean followRedirects;</span><br><span class="line">        &#x2F;&#x2F;失败是否重新连接 hhhhhh6****** 3tn</span><br><span class="line">        boolean retryOnConnectionFailure;</span><br><span class="line">        &#x2F;&#x2F;回调超时</span><br><span class="line">        int callTimeout;</span><br><span class="line">        &#x2F;&#x2F;连接超时</span><br><span class="line">        int connectTimeout;</span><br><span class="line">        &#x2F;&#x2F;读取超时</span><br><span class="line">        int readTimeout;</span><br><span class="line">        &#x2F;&#x2F;写入超时</span><br><span class="line">        int writeTimeout;</span><br><span class="line">        &#x2F;&#x2F;与WebSocket有关，为了保持长连接，我们必须间隔一段时间发送一个ping指令进行保；</span><br><span class="line">        int pingInterval;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、请求流程分析"><a href="#三、请求流程分析" class="headerlink" title="三、请求流程分析"></a>三、请求流程分析</h1><p>大体全貌图</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23957/040003B90E114920918B8C1053C0194C"  alt="image"></p><h2 id="同步请求-1"><a href="#同步请求-1" class="headerlink" title="同步请求"></a>同步请求</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22746/E59131FA16C1481E97D46E456075BB1D"  alt="image"></p><h3 id="RealCalll-execute"><a href="#RealCalll-execute" class="headerlink" title="RealCalll.execute()"></a>RealCalll.execute()</h3><p>这方法主要处理：</p><ul><li>校验任务是否被执行过</li><li>将任务加入同步队列</li><li>触发拦截器处理Request队列内容</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">override fun execute(): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; 如果Call已经被执行过，则不允许被重复执行</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">     executed &#x3D; true</span><br><span class="line">   &#125;</span><br><span class="line">   timeout.enter()</span><br><span class="line">   callStart()</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Dispatcher 只是将该同步任务加入 runnigSyncCalls 队列中</span><br><span class="line">     client.dispatcher.executed(this)</span><br><span class="line">     &#x2F;&#x2F; 拦截器</span><br><span class="line">     return getResponseWithInterceptorChain()</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     client.dispatcher.finished(this)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="Dispatcher-executed-call-RealCall"><a href="#Dispatcher-executed-call-RealCall" class="headerlink" title="Dispatcher.executed(call:RealCall)"></a>Dispatcher.executed(call:RealCall)</h3><p>在Dispatcher 维护着多种队列<code>runningAsyncCalls</code>、<code>runningSyncCalls</code>、‘<code>readyAsyncCalls</code>，这里触发的同步任务，是将任务添加到 <code>runningSyncCalls</code> 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#x2F;&#x2F; ArrayDeque 是Deque的实现类，同样是使用一个数组维护，是线程不安全的集合对象，效率高于栈和LinkeList，可以作为双端队列也可以作为栈</span><br><span class="line">private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">...</span><br><span class="line">@Synchronized internal fun executed(call: RealCall) &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="getResponseWithInterceptorChain-触发拦截器处理"><a href="#getResponseWithInterceptorChain-触发拦截器处理" class="headerlink" title="getResponseWithInterceptorChain 触发拦截器处理"></a>getResponseWithInterceptorChain 触发拦截器处理</h3><p>在Okhttp所有请求中最终都将进入对拦截器的处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line"> internal fun getResponseWithInterceptorChain(): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">   val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 添加所有应用拦截器</span><br><span class="line">   interceptors +&#x3D; client.interceptors</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 重试拦截器</span><br><span class="line">   interceptors +&#x3D; RetryAndFollowUpInterceptor(client)</span><br><span class="line">   interceptors +&#x3D; BridgeInterceptor(client.cookieJar)</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 缓存专用拦截器</span><br><span class="line">   interceptors +&#x3D; CacheInterceptor(client.cache)</span><br><span class="line">   interceptors +&#x3D; ConnectInterceptor</span><br><span class="line">   </span><br><span class="line">   if (!forWebSocket) &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果不是websocket 则添加Network拦截器</span><br><span class="line">     interceptors +&#x3D; client.networkInterceptors</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 最后一个才是真正调用服务器请求入口，因此需要保证是最后一个</span><br><span class="line">   interceptors +&#x3D; CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 开始组建责任链，建立包装类，index指向拦截器队列的头部</span><br><span class="line">   val chain &#x3D; RealInterceptorChain(interceptors, this, null, 0, originalRequest,</span><br><span class="line">       client.connectTimeoutMillis,</span><br><span class="line">       client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">   var calledNoMoreExchanges &#x3D; false</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 责任链开始，在每一级的Interceptor都要求调用chain的process方法，这样构成了一级一级向下的责任</span><br><span class="line">     val response &#x3D; chain.proceed(originalRequest)</span><br><span class="line">     if (isCanceled()) &#123;</span><br><span class="line">       response.closeQuietly()</span><br><span class="line">       throw IOException(&quot;Canceled&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">     return response</span><br><span class="line">   &#125; catch (e: IOException) &#123;</span><br><span class="line">     calledNoMoreExchanges &#x3D; true</span><br><span class="line">     throw noMoreExchanges(e) as Throwable</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     if (!calledNoMoreExchanges) &#123;</span><br><span class="line">       noMoreExchanges(null)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>RealInterceptorChain.proceed(request: Request, exchange: Exchange?)</li></ul><p>proceed(request: Requst) 最终由 proceed(request: Request, exchange: Exchange?) 代理执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line">  fun proceed(request: Request, exchange: Exchange?): Response &#123;</span><br><span class="line">    if (index &gt;&#x3D; interceptors.size) throw AssertionError()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录调用proceed次数</span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果有 Exchange，</span><br><span class="line">    check(this.exchange &#x3D;&#x3D; null || this.exchange.connection()!!.supportsUrl(request.url)) &#123;</span><br><span class="line">      &quot;network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 确保每个chain.proceed 只能被调用一次</span><br><span class="line">    check(this.exchange &#x3D;&#x3D; null || calls &lt;&#x3D; 1) &#123;</span><br><span class="line">      &quot;network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里产生指向下一个拦截器（index + 1）的处理链，并将这个作为参数传入给当前的拦截器(index)</span><br><span class="line">    val next &#x3D; RealInterceptorChain(interceptors, call, exchange,</span><br><span class="line">        index + 1, request, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    val interceptor &#x3D; interceptors[index]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行当前所指向的拦截器的intercept方法</span><br><span class="line">    @Suppress(&quot;USELESS_ELVIS&quot;)</span><br><span class="line">    val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">        &quot;interceptor $interceptor returned null&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 确保 procceed() 只能被调用一次</span><br><span class="line">    check(exchange &#x3D;&#x3D; null || index + 1 &gt;&#x3D; interceptors.size || next.calls &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      &quot;network interceptor $interceptor must call proceed() exactly once&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 校验Response</span><br><span class="line">    check(response.body !&#x3D; null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125;</span><br><span class="line"></span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Chain 提供的是将interceptor 进行串联 并以以递归的形式向下传递（要求子intercptor 必须调用 intercept(chain: Interceptor.Chain) 参数 chain.process() 方法），最终进行网络请求的是最后的拦截器类 <code>CallServerInterceptor</code></p><ul><li>CallServerInterceptor.intercept(chain: Interceptor.Chain) 处理网络请求</li></ul><p>在 proceed 的方法处理中，提到了 Exchange 类，这里 Exchange 是对 HTTP 事务的包装(实际指向 ExchangeCodec)，因此在这里面最重要的是使用该类进行处理的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val exchange &#x3D; realChain.exchange()</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    val requestBody &#x3D; request.body</span><br><span class="line">    val sentRequestMillis &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对头部数据进行写入</span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    var invokeStartEvent &#x3D; true</span><br><span class="line">    var responseBuilder: Response.Builder? &#x3D; null</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 处理非 GET 和 HEAD 方式的请求，对body进行处理</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; HTTP&#x2F;1.1 协议里设计100 (Continue) HTTP 状态码的的目的是，在客户端发送 Request Message 之前，HTTP&#x2F;1.1 协议允许客户端先判定服务器是否愿意接受客户端发来的消息主体（基于 Request Headers）。即， 客户端 在 Post（较大）数据到服务端之前，允许双方“握手”，如果匹配上了，Client 才开始发送（较大）数据，如果 client 预期等待“100-continue”的应答，那么它发的请求必须包含一个 &quot; Expect: 100-continue&quot;  的头域！</span><br><span class="line"></span><br><span class="line">      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果头部域包含 Expect:100-continue 则进行预请求，判断服务器是否允许body传递，防止服务器拒收</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; true)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; HTTP&#x2F;2 的全双工，暂时忽略，需要客户端和服务端的支持</span><br><span class="line">        if (requestBody.isDuplex()) &#123;</span><br><span class="line">          &#x2F;&#x2F; Prepare a duplex body so that the application can send a request body later.</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, true).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, false).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用了 Expect: 100-continue 情况</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        &#x2F;&#x2F; 如果不是多路复用的情况</span><br><span class="line">        if (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          &#x2F;&#x2F; If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP&#x2F;1 connection</span><br><span class="line">          &#x2F;&#x2F; from being reused. Otherwise we&#39;re still obligated to transmit the request body to</span><br><span class="line">          &#x2F;&#x2F; leave the connection in a consistent state.</span><br><span class="line">          &#x2F;&#x2F; 执行了该动作，会导致不会有进一步的数据事务发生，</span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 因为不存在 body 体，释放request body资源释放</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 结束请求（返回Response），实际也调用了 Sink.flush()</span><br><span class="line">    if (requestBody &#x3D;&#x3D; null || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 读取 Response 信息（如果还未产生 Response 构建的情况）</span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    var code &#x3D; response.code</span><br><span class="line">    if (code &#x3D;&#x3D; 100) &#123;</span><br><span class="line">      &#x2F;&#x2F; Server sent a 100-continue even though we did not request one. Try again to read the actual</span><br><span class="line">      &#x2F;&#x2F; response status.</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response &#x3D; responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code &#x3D; response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response &#x3D; if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">      &#x2F;&#x2F; Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">      &#x2F;&#x2F; 对于 websocket 和 100-continue 情况</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 普通请求</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase &#x3D; true) ||</span><br><span class="line">        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    if ((code &#x3D;&#x3D; 204 || code &#x3D;&#x3D; 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123;</span><br><span class="line">      throw ProtocolException(</span><br><span class="line">          &quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23141/42B3A1AC46224242AD49DFB2FE684D5C"  alt="image"></p><h3 id="Call-enqueue-responseCallback-Callback"><a href="#Call-enqueue-responseCallback-Callback" class="headerlink" title="Call.enqueue(responseCallback: Callback)"></a>Call.enqueue(responseCallback: Callback)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  callStart()</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同样需要对Call进行是否执行过的校验</li><li>对RealCall使用AsyncCall进行包装</li><li>将AsynCall添加Dispatcher的异步队列中</li></ul><h3 id="Dispatcher-enqueue-call-AsyncCall"><a href="#Dispatcher-enqueue-call-AsyncCall" class="headerlink" title="Dispatcher.enqueue(call: AsyncCall)"></a>Dispatcher.enqueue(call: AsyncCall)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal fun enqueue(call: AsyncCall) &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加异步任务的就绪异步执行队列    </span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span><br><span class="line">    &#x2F;&#x2F; the same host.</span><br><span class="line">    if (!call.get().forWebSocket) &#123;</span><br><span class="line">      val existingCall &#x3D; findExistingCallWithHost(call.host())</span><br><span class="line">      if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 触发执行异步内容</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dispatcher-promoteAndExecute"><a href="#Dispatcher-promoteAndExecute" class="headerlink" title="Dispatcher.promoteAndExecute()"></a>Dispatcher.promoteAndExecute()</h3><ul><li>检查正在请求总数是否超限、检查单个Host正在请求数是否超限</li><li>自增当前可请求Host计数器</li><li>开始执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提供线程池用于异步请求任务执行</span><br><span class="line">@get:Synchronized</span><br><span class="line">@get:JvmName(&quot;executorService&quot;) val executorService: ExecutorService</span><br><span class="line">  get() &#123;</span><br><span class="line">    if (executorServiceOrNull &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 无核心线程，并且不限制所启动的线程数量，保留60即退出线程</span><br><span class="line">      executorServiceOrNull &#x3D; ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          SynchronousQueue(), threadFactory(&quot;$okHttpName Dispatcher&quot;, false))</span><br><span class="line">    &#125;</span><br><span class="line">    return executorServiceOrNull!!</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">private fun promoteAndExecute(): Boolean &#123;</span><br><span class="line">  this.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  val isRunning: Boolean</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    val i &#x3D; readyAsyncCalls.iterator()</span><br><span class="line">    while (i.hasNext()) &#123;</span><br><span class="line">      val asyncCall &#x3D; i.next()</span><br><span class="line">      &#x2F;&#x2F; 当前执行的异步认为大于最大数量则终止</span><br><span class="line">      if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity.</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 当前所调用的host请求数量大于最大限制，跳过当前请求</span><br><span class="line">      if (asyncCall.callsPerHost().get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity.</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 将允许执行的任务从就绪队列中移除</span><br><span class="line">      i.remove()</span><br><span class="line">      &#x2F;&#x2F; 记录当前请求host数量计数器</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 将允许执行的任务添加到正在执行队列中</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 是否有正在执行的任务（包括异步和同步任务）</span><br><span class="line">    isRunning &#x3D; runningCallsCount() &gt; 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 开始执行允许执行的队列，executorService 为线程池</span><br><span class="line">  for (i in 0 until executableCalls.size) &#123;</span><br><span class="line">    val asyncCall &#x3D; executableCalls[i]</span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RealCall-executeOn-executorService-ExecutorService"><a href="#RealCall-executeOn-executorService-ExecutorService" class="headerlink" title="RealCall.executeOn(executorService: ExecutorService)"></a>RealCall.executeOn(executorService: ExecutorService)</h3><ul><li>执行任务并且处理启动过程中（非执行）发生的异常捕获</li><li>对于异常启动的情况，需要回调给Dispatcher通知结束状态</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun executeOn(executorService: ExecutorService) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查当前线程是否持有 Dispatcher 锁</span><br><span class="line">      client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">      var success &#x3D; false</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池执行该内容，</span><br><span class="line">        executorService.execute(this)</span><br><span class="line">        success &#x3D; true</span><br><span class="line">      &#125; catch (e: RejectedExecutionException) &#123;</span><br><span class="line">        val ioException &#x3D; InterruptedIOException(&quot;executor rejected&quot;)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        &#x2F;&#x2F; 对于异常情况，会在 noMoreExchanges中根据情况释放连接</span><br><span class="line">        noMoreExchanges(ioException)</span><br><span class="line">        &#x2F;&#x2F; 回调给之前传入的Callback失败信息</span><br><span class="line">        responseCallback.onFailure(this@RealCall, ioException)</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 通知Dispatcher结束请求</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">          client.dispatcher.finished(this) &#x2F;&#x2F; This call is no longer running!</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从以上线程池执行可以看出<code>AsyncCall</code>本身是一个<code>Runnable</code>对象，因此具体的执行内容需要从<code>AsyncCall.run()</code> 入手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  override fun run() &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里只是命名线程名，并且对闭包内容在内部进行执行</span><br><span class="line">    threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 标记是否需要进行回调结果，由于异常可能发生在 onResponse 的时候，所以为了避免两次callback回调，进行标记处理</span><br><span class="line">      var signalledCallback &#x3D; false</span><br><span class="line">      timeout.enter()</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 在这里又重新进入了 getResponseWithInterceptorChain 的分析，参照同步请求的流程</span><br><span class="line">        val response &#x3D; getResponseWithInterceptorChain()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 为下面的回调进行标记，以及被回调过，防止再次发生异常时，重复执行回调（异常的回调）</span><br><span class="line">        signalledCallback &#x3D; true</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 对之前传入的 callback 进行成功回调</span><br><span class="line">        responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">      &#125; catch (e: IOException) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          &#x2F;&#x2F; Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(this@RealCall, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (t: Throwable) &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; 异常发生时，对请求进行一些取消行为</span><br><span class="line">        cancel()</span><br><span class="line">        if (!signalledCallback) &#123;</span><br><span class="line">        </span><br><span class="line">          &#x2F;&#x2F; 同样是对失败时的处理，包装异常类，通知之前的回调callback</span><br><span class="line">          val canceledException &#x3D; IOException(&quot;canceled due to $t&quot;)</span><br><span class="line">          canceledException.addSuppressed(t)</span><br><span class="line">          responseCallback.onFailure(this@RealCall, canceledException)</span><br><span class="line">        &#125;</span><br><span class="line">        throw t</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;  结束通知</span><br><span class="line">        client.dispatcher.finished(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Dispatcher-finished"><a href="#Dispatcher-finished" class="headerlink" title="Dispatcher.finished()"></a>Dispatcher.finished()</h4><p>无论是在成功或失败请求后，都需要在最后通知Dispatcher进行finished()动作。</p><ul><li>在结束任务通知后 继续调用promoteAndExecute()尝试启动新一轮任务（如果还有异步任务的话）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123;</span><br><span class="line">   &#x2F;&#x2F; 单元测试时用到</span><br><span class="line">   val idleCallback: Runnable?</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     if (!calls.remove(call)) throw AssertionError(&quot;Call wasn&#39;t in-flight!&quot;)</span><br><span class="line">     idleCallback &#x3D; this.idleCallback</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val isRunning &#x3D; promoteAndExecute()</span><br><span class="line"></span><br><span class="line">   if (!isRunning &amp;&amp; idleCallback !&#x3D; null) &#123;</span><br><span class="line">     idleCallback.run()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>在每次结束后都持续检测是否仍然有需要进行处理的任务。</p><h1 id="四、拦截器"><a href="#四、拦截器" class="headerlink" title="四、拦截器"></a>四、拦截器</h1><p>在以上的流程中，我们不难看出，Okhttp 在具体请求优化方面会体现在拦截器中，通过责任链模式，下面解析下各个拦截器的能力。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23954/5D1289AAEE5549BFA22870B476842CF1"  alt="image"></p><h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><p>该拦截器主要负责：</p><ul><li>创建连接ExchangeFinder 用于连接要求</li><li>当发生异常，对可进行恢复重试的连接进行恢复请求</li><li>当发生多次连接情况（重定向、授权要求），自动进行二次或多次连接</li><li>连接资源释放</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  var request &#x3D; chain.request()</span><br><span class="line">  val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">  val call &#x3D; realChain.call()</span><br><span class="line">  &#x2F;&#x2F; 用于计数循环请求（重定向）次数，该次数不能超过20次，否则抛出异常</span><br><span class="line">  var followUpCount &#x3D; 0</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 用于存储上个循环中所获得的Response，用于下次循环产生的Response对之前Response的追溯，可以跟踪重定向的来源等信息</span><br><span class="line">  var priorResponse: Response? &#x3D; null</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化ExchangeFinder ，为后面连接使用</span><br><span class="line">    call.prepareExchangeFinder(request)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断是否发生取消</span><br><span class="line">    if (call.isCanceled()) &#123;</span><br><span class="line">      throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对于异常情况，根据异常信息进行重试处理</span><br><span class="line">    var response: Response</span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取请求后的 Response</span><br><span class="line">      response &#x3D; realChain.proceed(request, null)</span><br><span class="line">      success &#x3D; true</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      &#x2F;&#x2F; RouteException发生于请求开始，因此requestSendStarted为false，如果该连接不可恢复则抛出异常，否则继续循环</span><br><span class="line">      if (!recover(e.lastConnectException, call, false, request)) &#123;</span><br><span class="line">        throw e.firstConnectException</span><br><span class="line">      &#125;</span><br><span class="line">      continue</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      &#x2F;&#x2F; IOException 可能发生于连接过程中，可能已发送部分请求或全部成功，如果是在连接后发生的异常，则请求可能是以及被发送出去了，标记requestSendStarted为true</span><br><span class="line">      val requestSendStarted &#x3D; e !is ConnectionShutdownException</span><br><span class="line">      if (!recover(e, call, requestSendStarted, request)) throw e</span><br><span class="line">      continue</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 不成功时强制关闭资源</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        call.exchangeDoneDueToException()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果上一个请求有返回Response，并且进入二次请求要求的话，则进行重新包装，用于之后的再次请求，</span><br><span class="line">    if (priorResponse !&#x3D; null) &#123;</span><br><span class="line">      response &#x3D; response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">              .body(null)</span><br><span class="line">              .build())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val exchange &#x3D; response.exchange</span><br><span class="line">    val route &#x3D; exchange?.connection()?.route()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据Response结果要求产生新的Request，比如重定向、授权要求等</span><br><span class="line">    val followUp &#x3D; followUpRequest(response, route)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有进一步请求要求则直接返回当前的Response</span><br><span class="line">    if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (exchange !&#x3D; null &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">        call.timeoutEarlyExit()</span><br><span class="line">      &#125;</span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果有多次请求要求，但是设置只允许请求一次的情况，只能返回Response</span><br><span class="line">    val followUpBody &#x3D; followUp.body</span><br><span class="line">    if (followUpBody !&#x3D; null &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理只有关闭的连接和资源的动作</span><br><span class="line">    response.body?.closeQuietly()</span><br><span class="line">    if (call.hasExchange()) &#123;</span><br><span class="line">      exchange?.detachWithViolence()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 限制最大重定向（重新请求）次数不能超过20次</span><br><span class="line">    if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">      throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将请求信息预留给下次循环的请求</span><br><span class="line">    request &#x3D; followUp</span><br><span class="line">    priorResponse &#x3D; response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  private fun recover(</span><br><span class="line">  e: IOException,</span><br><span class="line">  call: RealCall,</span><br><span class="line">  requestSendStarted: Boolean,</span><br><span class="line">  userRequest: Request</span><br><span class="line">): Boolean &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果设置了禁止重试（OkHttpClient.Builder.retryOnConnectionFailure(Boolean)），则不进行重试</span><br><span class="line">  if (!client.retryOnConnectionFailure) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 对于 设置有body的 Request 的 RequestBody.isOneShot 的方法返回trues时，则只允许发送一次，不允许重试请求</span><br><span class="line">  if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 根据异常信息判断该连接是否可以进行恢复重试</span><br><span class="line">  &#x2F;&#x2F; 1. 如果是协议异常则不进行重试</span><br><span class="line">  &#x2F;&#x2F; 2. 如果为中断异常但是不是连接超时的情况也不允许</span><br><span class="line">  &#x2F;&#x2F; 3. 如果是SSL握手异常并且是证书相关异常则不允许</span><br><span class="line">  &#x2F;&#x2F; 4. 如果是SSL验证结果不可信异常则不允许</span><br><span class="line">  if (!isRecoverable(e, requestSendStarted)) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 检测如果不是流传输异常或者没有Route可以尝试的话，则不进行重试</span><br><span class="line">  if (!call.canRetry()) return false</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><p>该拦截器用于处理:</p><ul><li>头部信息修正或者默认值处理，具体修改参考下面注释</li><li>Cookie支持，对服务器返回的Cookie信息回传给CookieJar处理</li><li>Gzip支持，对支持Gzip的请求结果Response进行解析</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 主要进行头部信息填充</span><br><span class="line">   * Content-Type:  来源于 RequestBody.contentType() （覆盖设置）</span><br><span class="line">   * Content-Length: 来源于 RequestBody.contentLength()，如果length &#x3D; -1 则进行 Transfer-Encoding: chunked 头部填充 （覆盖设置）</span><br><span class="line">   * Host: 来源于 Request.url.toHostHeader() （没有才进行填充）</span><br><span class="line">   * Connection: 默认设置 Keep-Alive (如果没有的话才设置，有的话则不继续替换)</span><br><span class="line">   * Accept-Encoding: 如果没设置 Accept-Encoding 并且没有设置Range(断点) 则默认设置 Accept-Encoding: gzip</span><br><span class="line">   * Cookie：这里的 Cookie 来源于 OkHttpClient.Builder.cookieJar(cookieJar: CookieJar)的设置，默认OkHttpClient为 CookieJar.NoCookies，没有Cookie 信息 (覆盖设置)</span><br><span class="line">   * User-Agent: 如果没设置，默认 okhttp&#x2F;4.4.0-SNAPSHOT</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val userRequest &#x3D; chain.request()</span><br><span class="line">    val requestBuilder &#x3D; userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    val body &#x3D; userRequest.body</span><br><span class="line">    if (body !&#x3D; null) &#123;</span><br><span class="line">      val contentType &#x3D; body.contentType()</span><br><span class="line">      if (contentType !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据body的contentType 信息进行 mime 内容头部信息填充</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      val contentLength &#x3D; body.contentLength()</span><br><span class="line">      if (contentLength !&#x3D; -1L) &#123;</span><br><span class="line">        </span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 标记gzip是否设置，用于后面解析Response判断</span><br><span class="line">    var transparentGzip &#x3D; false</span><br><span class="line">    &#x2F;&#x2F; 如果没设置 Accept-Encoding 并且没有设置Range(断点) 则默认设置 Accept-Encoding: gzip</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      transparentGzip &#x3D; true</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的 cookieJar 来源于 OkHttpClient.Builder.cookieJar(cookieJar: CookieJar)的设置，默认OkHttpClient为 CookieJar.NoCookies </span><br><span class="line">    &#x2F;&#x2F; 不设置Cookie 支持（Cookies 为空非null）,如果有则生成头部 Cookie 段</span><br><span class="line">    val cookies &#x3D; cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    if (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val networkResponse &#x3D; chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 解析Cookie 并回传给 CookieJar 进行处理</span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    val responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 处理gzip内容，如果之前设置了 gzip 支持，并且所返回的服务器 Response 同样 Content-Encoding 支持 gzip，则对返回的Response</span><br><span class="line">    &#x2F;&#x2F; 进行 gzip 解析并添加到新的Reponse 中</span><br><span class="line">    if (transparentGzip &amp;&amp;</span><br><span class="line">        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase &#x3D; true) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">      val responseBody &#x3D; networkResponse.body</span><br><span class="line">      if (responseBody !&#x3D; null) &#123;</span><br><span class="line">        val gzipSource &#x3D; GzipSource(responseBody.source())</span><br><span class="line">        val strippedHeaders &#x3D; networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">            .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        val contentType &#x3D; networkResponse.header(&quot;Content-Type&quot;)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><p>前面提到OkHttp 缓存拦截器 CacheInterceptor，在该拦截器中实现了网络缓存的绝大逻辑。</p><p>在intercept 工作中主要处理：</p><ul><li>根据 HTTP的缓存规则（比如根据头部信息、Tag等缓存条件）判断当前所进行的请求，以及在缓存中缓存的内容是否能命中该次请求（通过CacheStrategy进行构造处理）</li><li>对Request是否满足和Response是否满足进行分别处理：<ul><li>如果Request不满足条件（策略会校验是否有网络等情况，如果不满足则返回null) 而缓存Response 满足，则返回缓存Response</li><li>如果Request 和缓存Response 都不满足，则返回504 Response</li><li>如果Request 满足 而 缓存Response不满足，则使用请求后的Respnse</li><li>对于304结果，更新缓存并且返回缓存Response </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  &#x2F;&#x2F; cache 来源于 OkHttpClient.Builder.cache(cache: Cache?)，默认为null</span><br><span class="line">  val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">  val now &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 传入当前请求信息和获得的候选缓存Response，根据一些HTTP缓存规则，判断当前候选Reponse是否可用，对Request也会进行一些判断，比如当前网络是否可用</span><br><span class="line">  val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  val networkRequest &#x3D; strategy.networkRequest &#x2F;&#x2F; 如果网络不可用，则默认这里会为null</span><br><span class="line">  val cacheResponse &#x3D; strategy.cacheResponse &#x2F;&#x2F; 如果cacheCandidate可用，则这里会返回一致，如果不可用则返回null（缓存过期之类的）</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单元测试使用</span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前从缓存中获得的缓存候选和实际计算出的缓存Response不匹配（不符合条件，为空），则抛弃候选缓存Cache</span><br><span class="line">  if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果返回的网络请求为空，则说明网络当前不可用，并且允许缓存Response也为空，则默认返回504即可</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-1L)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果仅是网络不可用导致Request不能请求，那么直接返回命中的Response缓存即可，复用结果</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 执行网络请求</span><br><span class="line">  var networkResponse: Response? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">    networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">    if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果缓存存在，并且服务器返回304则更新下缓存信息并返回</span><br><span class="line">  if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">    if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line"></span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">      &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)</span><br><span class="line">      return response</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果有缓存器，并且缓存策略允许被缓存，则添加到缓存中</span><br><span class="line">  if (cache !&#x3D; null) &#123;</span><br><span class="line">    if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">      val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">      return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  目前缓存只缓存GET请求内容，官方解释说，如果所有的形式都缓存，复杂度高但是收效低，则对于非法的缓存进行移除（GET不需要？)</span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; catch (_: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在CacheInterceptor 中比较重要的是 <code>Cache</code> 类，它提供了整个缓存下的功能。这里分析下该类的主要构成。</p><p>从 Cache 中，我们不难发现，它所有的缓存行为都是通过 <code>DiskLruCache</code>进行代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> internal val cache &#x3D; DiskLruCache(</span><br><span class="line">     fileSystem &#x3D; fileSystem,</span><br><span class="line">     directory &#x3D; directory,</span><br><span class="line">     appVersion &#x3D; VERSION,</span><br><span class="line">     valueCount &#x3D; ENTRY_COUNT,</span><br><span class="line">     maxSize &#x3D; maxSize,</span><br><span class="line">     taskRunner &#x3D; TaskRunner.INSTANCE</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> internal fun get(request: Request): Response? &#123;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Okhttp 都是简单用Url作为索引</span><br><span class="line">   val key &#x3D; key(request.url)</span><br><span class="line">   val snapshot: DiskLruCache.Snapshot &#x3D; try &#123;</span><br><span class="line">       &#x2F;&#x2F; 通过DiskLruCache 获取缓存中的对象，如果没有则直接异常返回null</span><br><span class="line">     cache[key] ?: return null</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Give up because the cache cannot be read.</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 包装为Cache.Entry 对象，在Entry 中对 Snapshot对象进行解析，并对Entry中的字段进行赋值，转化为业务含义的的信息</span><br><span class="line">   val entry: Entry &#x3D; try &#123;</span><br><span class="line">     Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     snapshot.closeQuietly()</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 解析Snaphost中的 Reponse缓存信息，并转化为 Reponse 业务对象</span><br><span class="line">   val response &#x3D; entry.response(snapshot)</span><br><span class="line">   if (!entry.matches(request, response)) &#123;</span><br><span class="line">     response.body?.closeQuietly()</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return response</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">  fun response(snapshot: DiskLruCache.Snapshot): Response &#123;</span><br><span class="line">     val contentType &#x3D; responseHeaders[&quot;Content-Type&quot;]</span><br><span class="line">     val contentLength &#x3D; responseHeaders[&quot;Content-Length&quot;]</span><br><span class="line">     val cacheRequest &#x3D; Request.Builder()</span><br><span class="line">         .url(url)</span><br><span class="line">         .method(requestMethod, null)</span><br><span class="line">         .headers(varyHeaders)</span><br><span class="line">         .build()</span><br><span class="line">     return Response.Builder()</span><br><span class="line">         .request(cacheRequest)</span><br><span class="line">         .protocol(protocol)</span><br><span class="line">         .code(code)</span><br><span class="line">         .message(message)</span><br><span class="line">         .headers(responseHeaders)</span><br><span class="line">         .body(CacheResponseBody(snapshot, contentType, contentLength))</span><br><span class="line">         .handshake(handshake)</span><br><span class="line">         .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">         .receivedResponseAtMillis(receivedResponseMillis)</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>Cache</code>中更多的是对DiskLruCache 所需要处理的信息进行拆包和包装，因此这里我们直接看 <code>DiskLruCache</code>。</p><h4 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h4><p>在 DiskLruCache 主要分成几种对象结构：</p><ul><li>Entry 单个缓存数据的代理对象，用于在 LinkHashMap 中的存储，规定了缓存文件（cleanFiles）、临时文件（dirtyFiles）以及提供了 Snapshot 对象入口，Entry 不对数据有写入能力。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">internal inner class Entry internal constructor(</span><br><span class="line">    internal val key: String</span><br><span class="line">  ) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 数据长度</span><br><span class="line">    internal val lengths: LongArray &#x3D; LongArray(valueCount)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于正式写入的文件</span><br><span class="line">    internal val cleanFiles &#x3D; mutableListOf&lt;File&gt;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于临时数据写入的文件，目前默认都是2个，最终需要调用Edit.commit 才能写入正式文件</span><br><span class="line">    internal val dirtyFiles &#x3D; mutableListOf&lt;File&gt;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 文件是否可读取</span><br><span class="line">    internal var readable: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录当前被编辑的对象，有且只能有一个在编辑</span><br><span class="line">    internal var currentEditor: Editor? &#x3D; null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每一个Snapshot 会产生一个序列号，每次发生Edit.commit后 序列号都会发生变化</span><br><span class="line">    internal var sequenceNumber: Long &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 产生当前Entry对应的Snapshot对象</span><br><span class="line">    internal fun snapshot(): Snapshot?</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Snapshot 负责对缓存数据的详细源记录，包括值信息、磁盘缓存数据源（File Source)、数据长度等。提供给外部获取具体缓存内容使用。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inner class Snapshot internal constructor(</span><br><span class="line">  private val key: String, </span><br><span class="line">  private val sequenceNumber: Long, &#x2F;&#x2F; 每个独立提交都对应一个</span><br><span class="line">  private val sources: List&lt;Source&gt;, &#x2F;&#x2F; 缓存文件目前只有两个 0 index 为头文件 1 为 body 文件</span><br><span class="line">  private val lengths: LongArray &#x2F;&#x2F; 数据长度信息</span><br><span class="line">) : Closeable &#123;</span><br><span class="line">  fun key(): String &#x3D; key</span><br><span class="line">  &#x2F;&#x2F; 获得一个Edit 对象，对内容进行编辑事务处理。</span><br><span class="line">  fun edit(): Editor? &#x3D; this@DiskLruCache.edit(key, sequenceNumber)</span><br><span class="line">  fun getSource(index: Int): Source &#x3D; sources[index]</span><br><span class="line">  override fun close() &#123;</span><br><span class="line">    for (source in sources) &#123;</span><br><span class="line">      source.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Edit 负责对数据的写入事务处理，在完成事务有需要进行 commit 提交<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Edits the values for an entry. *&#x2F;</span><br><span class="line"> inner class Editor internal constructor(internal val entry: Entry) &#123;</span><br><span class="line">   &#x2F;&#x2F; 用来标记开启几个写入文件</span><br><span class="line">   internal val written: BooleanArray? &#x3D; if (entry.readable) null else BooleanArray(valueCount)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 检查 edit事务是否完成 commit 和 abort 可以触发 done &#x3D; true 动作</span><br><span class="line">   private var done: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 移除临时目录下所有文件</span><br><span class="line">   internal fun detach()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 返回指定的数据源（正式数据）（目前index &#x3D; 0 为头文件  index &#x3D; 1 为body文件）</span><br><span class="line">   fun newSource(index: Int): Source?</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建临时文件的写入代理</span><br><span class="line">   fun newSink(index: Int): Sink </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 提交修改的数据，将临时文件转为正式缓存文件</span><br><span class="line">   fun commit() </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 放弃修改，会将所有临时文件删除</span><br><span class="line">   fun abort() </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="缓存溢出处理"><a href="#缓存溢出处理" class="headerlink" title="缓存溢出处理"></a>缓存溢出处理</h5><p>在每次发生修改、提交都将对内容进行队列内容进行检测</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 一个包装的线程池</span><br><span class="line"> private val cleanupQueue &#x3D; taskRunner.newQueue()</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 清理任务</span><br><span class="line"> private val cleanupTask &#x3D; object : Task(&quot;$okHttpName Cache&quot;) &#123;</span><br><span class="line">   override fun runOnce(): Long &#123;</span><br><span class="line">     synchronized(this@DiskLruCache) &#123;</span><br><span class="line">       if (!initialized || closed) &#123;</span><br><span class="line">         return -1L &#x2F;&#x2F; Nothing to do.</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">        &#x2F;&#x2F; LinkHashMap 容量检测</span><br><span class="line">         trimToSize()</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         mostRecentTrimFailed &#x3D; true</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">        &#x2F;&#x2F; 日志清除</span><br><span class="line">         if (journalRebuildRequired()) &#123;</span><br><span class="line">           rebuildJournal()</span><br><span class="line">           redundantOpCount &#x3D; 0</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         mostRecentRebuildFailed &#x3D; true</span><br><span class="line">         journalWriter &#x3D; blackholeSink().buffer()</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return -1L</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line">  @get:Synchronized @set:Synchronized var maxSize: Long &#x3D; maxSize</span><br><span class="line">  set(value) &#123;</span><br><span class="line">     field &#x3D; value</span><br><span class="line">     if (initialized) &#123;</span><br><span class="line">       cleanupQueue.schedule(cleanupTask) &#x2F;&#x2F; 初始化缓存容量时对当前缓存进行一次清理</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> fun trimToSize() &#123;</span><br><span class="line">   while (size &gt; maxSize) &#123;</span><br><span class="line">     val toEvict &#x3D; lruEntries.values.iterator().next()</span><br><span class="line">     removeEntry(toEvict)</span><br><span class="line">   &#125;</span><br><span class="line">   mostRecentTrimFailed &#x3D; false</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> internal fun removeEntry(entry: Entry): Boolean &#123;</span><br><span class="line">   entry.currentEditor?.detach() &#x2F;&#x2F; Prevent the edit from completing normally.</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 移除Entry文件，目前为两个</span><br><span class="line">   for (i in 0 until valueCount) &#123;</span><br><span class="line">     fileSystem.delete(entry.cleanFiles[i])</span><br><span class="line">     size -&#x3D; entry.lengths[i]</span><br><span class="line">     entry.lengths[i] &#x3D; 0</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 日志记录</span><br><span class="line">   journalWriter!!.writeUtf8(REMOVE)</span><br><span class="line">       .writeByte(&#39; &#39;.toInt())</span><br><span class="line">       .writeUtf8(entry.key)</span><br><span class="line">       .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">   lruEntries.remove(entry.key)</span><br><span class="line"></span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 获取时清理</span><br><span class="line"> operator fun get(key: String): Snapshot? &#123;</span><br><span class="line">   ...</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     &#x2F;&#x2F; 执行清理</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return snapshot</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 删除时清理 </span><br><span class="line">internal fun removeEntry(entry: Entry): Boolean &#123;</span><br><span class="line">   ....</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true</span><br><span class="line"> &#125;  </span><br><span class="line"> </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><h5 id="产生-Edit"><a href="#产生-Edit" class="headerlink" title="产生 Edit"></a>产生 Edit</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Synchronized @Throws(IOException::class)</span><br><span class="line">@JvmOverloads</span><br><span class="line">fun edit(key: String, expectedSequenceNumber: Long &#x3D; ANY_SEQUENCE_NUMBER): Editor? &#123;</span><br><span class="line">  initialize()</span><br><span class="line"></span><br><span class="line">  checkNotClosed()</span><br><span class="line">  &#x2F;&#x2F; 正则命名验证</span><br><span class="line">  validateKey(key)</span><br><span class="line">  var entry: Entry? &#x3D; lruEntries[key]</span><br><span class="line">  &#x2F;&#x2F; 如果指定了序列话数值 expectedSequenceeNumber , 那么就是为了找到之前存入Entry的内容，找不到返回null</span><br><span class="line">  if (expectedSequenceNumber !&#x3D; ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">      (entry &#x3D;&#x3D; null || entry.sequenceNumber !&#x3D; expectedSequenceNumber)) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Snapshot is stale.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 正在编辑中的Entry 不被允许重复编辑</span><br><span class="line">  if (entry?.currentEditor !&#x3D; null) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Another edit is in progress.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 保险丝机制，mostRecentTrimFailed 标记对最近移除溢出数据时发生失败的情况，mostRecentRebuildFailed 日志写入失败的情况</span><br><span class="line">  &#x2F;&#x2F; 如果发生该情况，表示当前该工具存储状态异常，因此执行重新清理的任务，拒绝进行编辑</span><br><span class="line">  if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">    cleanupQueue.schedule(cleanupTask)</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Flush the journal before creating files to prevent file leaks.</span><br><span class="line">  val journalWriter &#x3D; this.journalWriter!!</span><br><span class="line">  journalWriter.writeUtf8(DIRTY)</span><br><span class="line">      .writeByte(&#39; &#39;.toInt())</span><br><span class="line">      .writeUtf8(key)</span><br><span class="line">      .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">  journalWriter.flush()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 日志写入发生异常，不允许进行编辑</span><br><span class="line">  if (hasJournalErrors) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Don&#39;t edit; the journal can&#39;t be written.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">    entry &#x3D; Entry(key)</span><br><span class="line">    lruEntries[key] &#x3D; entry</span><br><span class="line">  &#125;</span><br><span class="line">  val editor &#x3D; Editor(entry)</span><br><span class="line">  entry.currentEditor &#x3D; editor</span><br><span class="line">  return editor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="初始化与备份"><a href="#初始化与备份" class="headerlink" title="初始化与备份"></a>初始化与备份</h5><p>初始化包括几个流程：</p><ul><li>校验文件系统情况，如果丢失则用备份进行还原</li><li>正常初始化，读取目录下所有缓存文件信息</li><li>如果初始化失败，则移除整个缓存文件夹，并重新建立整个缓存文件夹。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">fun initialize() &#123;</span><br><span class="line">    this.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">    if (initialized) &#123;</span><br><span class="line">      return &#x2F;&#x2F; Already initialized.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 验证文件是否正常，如果丢失日志则进行备份还原</span><br><span class="line">    if (fileSystem.exists(journalFileBackup)) &#123;</span><br><span class="line">      if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果正常则删除备份文件，否则使用备份文件</span><br><span class="line">        fileSystem.delete(journalFileBackup)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        fileSystem.rename(journalFileBackup, journalFile)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prefer to pick up where we left off.</span><br><span class="line">    if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        readJournal()</span><br><span class="line">        processJournal()</span><br><span class="line">        initialized &#x3D; true</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 到此初始化完成</span><br><span class="line">        return</span><br><span class="line">      &#125; catch (journalIsCorrupt: IOException) &#123;</span><br><span class="line">        Platform.get().log(</span><br><span class="line">            &quot;DiskLruCache $directory is corrupt: $&#123;journalIsCorrupt.message&#125;, removing&quot;,</span><br><span class="line">            WARN,</span><br><span class="line">            journalIsCorrupt)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果初始化失败则删除整个缓存文件夹，重建整个缓存，维持正常的执行（保险丝机制）</span><br><span class="line">      try &#123;</span><br><span class="line">        delete()</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        closed &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rebuildJournal()</span><br><span class="line"></span><br><span class="line">    initialized &#x3D; true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p><code>ConnectInterceptor</code> 主要负责在执行内容传输前的连接建立流程，比如TCP、TLS等连接的建立，以及授权、验证等。并且在产生连接通道后（RealConnection）将对连接进行缓存（RealConnectionPool），以便于在后面中进行连接复用。在该连接中不涉及数据交互。</p><p>OkHttp对连接做了比较多的优化，在结构上比较复杂，需要先对数据结构熟悉：</p><ul><li>ConnectionSpec <code>描述在HTTP进行连接通道时所需要的配置内容，目前仅涉及HTTPS在TLS版本、加密套件</code></li><li>ConnectionSpecSelector <code>根据提供的ConnectionSpec列表，对SSLSocket进行配置</code></li><li>Route <code>用来描述网络数据包的传输路径，主要描述出和TCP建立的目标点，包括代理的描述。路由信息通过RouteSelector产生，在一个host下可能存在多个链接点，因此可能产生多个Route信息。</code></li><li>RouteDatabase <code>记录失败的Route信息，避免下次使用无效Route，配合RouteSelector使用</code></li><li>RouteSelector <code>根据Proxie代理信息和Address进行合适的Route选择，在RouteSelector 中会将URL、Port信息转化为Proxy，并通过DNS进行查询，将多个连接点封装为所有Route</code></li><li>Protocol <code>连接所使用的协议信息</code></li><li>Address <code>用于存储所有连接前置信息，包含连接所需要的主机名host、端口号port，Dns、代理服务器Proxy、对于包含Https要求，则提供 SSLSocketFactory、HostnameVerifier、CertificatePinner、Authenticator等授权信息，</code></li><li>RealConnection <code>代表着socket链路，每一个RealConnection代表一条跟服务器的通信链路，在该类中完成主要的连接流程（TCP握手、TLS连接验证、协议连接）</code></li></ul><h3 id="RouteSelector、Route-与-Proxy"><a href="#RouteSelector、Route-与-Proxy" class="headerlink" title="RouteSelector、Route 与 Proxy"></a>RouteSelector、Route 与 Proxy</h3><p>在OkHttp 中，同一个域名host下可能存在多个连接点(或者多个代理连接点)，对于这些连接点，OkHttp 抽象成 Route 信息以方便进行连接。</p><h4 id="预处理Proxy"><a href="#预处理Proxy" class="headerlink" title="预处理Proxy"></a>预处理Proxy</h4><p>RouteSelector 初始化中，对Proxy进行预处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">   &#x2F;&#x2F; 初始化 proxy 信息</span><br><span class="line">   resetNextProxy(address.url, address.proxy)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 如果在OkHttpClient.Builder.proxy 定义了则使用该定义内容，否则判断是否设置了 proxySelector(目前只有单元测试用到）</span><br><span class="line"> &#x2F;&#x2F; 如果 ProxySelector.select 返回为null 则返回 默认 Proxy.NO_PROXY 兜底 proxy 。</span><br><span class="line"> private fun resetNextProxy(url: HttpUrl, proxy: Proxy?) &#123;</span><br><span class="line">   eventListener.proxySelectStart(call, url)</span><br><span class="line">   proxies &#x3D; if (proxy !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 OkHttpClient.Builder.proxy 主动设置了代理信息，那么只记录该代理</span><br><span class="line">     listOf(proxy)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果在OkHttpClient 中设置了 proxy 则proxySelector 为 NullProxySelector，否则这里</span><br><span class="line">     &#x2F;&#x2F; proxySelector 返回的是系统（平台）的ProxySelector 否则还是为 NullProxySelector</span><br><span class="line">     &#x2F;&#x2F; NullProxySelector 默认 select 返回一个空集合，因此如果到空集合的话最红返回的是只有一个 NO_PROXY的集合</span><br><span class="line">     &#x2F;&#x2F; 作为兜底，NO_PROXY 默认 type &#x3D; Proxy.Type.DIRECT</span><br><span class="line">     val proxiesOrNull &#x3D; address.proxySelector.select(url.toUri())</span><br><span class="line">     if (proxiesOrNull !&#x3D; null &amp;&amp; proxiesOrNull.isNotEmpty()) &#123;</span><br><span class="line">       proxiesOrNull.toImmutableList()</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       immutableListOf(Proxy.NO_PROXY)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   nextProxyIndex &#x3D; 0</span><br><span class="line">   eventListener.proxySelectEnd(call, url, proxies)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="RouteSelector的使用"><a href="#RouteSelector的使用" class="headerlink" title="RouteSelector的使用"></a>RouteSelector的使用</h4><p>RouteSelector 关键方法为 <code>next</code>，执行该方法将产生一个 <code>Selection</code>对象，用于存储所产生的<code>Route</code>候选集合内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nextProxyIndex 用来标记当前所处理的代理集合的位置，在next和nextProxy中开始进行解析</span><br><span class="line">private fun hasNextProxy(): Boolean &#x3D; nextProxyIndex &lt; proxies.size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Throws(IOException::class)</span><br><span class="line">private fun nextProxy(): Proxy &#123;</span><br><span class="line">  &#x2F;&#x2F; proxy一定会有一个值，至少存在一个 NO_PROXY</span><br><span class="line">  if (!hasNextProxy()) &#123;</span><br><span class="line">    throw SocketException(</span><br><span class="line">        &quot;No route to $&#123;address.url.host&#125;; exhausted proxy configurations: $proxies&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">   val result &#x3D; proxies[nextProxyIndex++]</span><br><span class="line">   resetNextInetSocketAddress(result)</span><br><span class="line">   return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据Proxy和host dns解析所有可用的 InetSocketAddress 并存在 inetSocketAddresses 字段中</span><br><span class="line"> private fun resetNextInetSocketAddress(proxy: Proxy) &#123;</span><br><span class="line">    val mutableInetSocketAddresses &#x3D; mutableListOf&lt;InetSocketAddress&gt;()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化RouteSelector.inetSocketAddresses 属性，将解析的结果存储在该列表中</span><br><span class="line">    inetSocketAddresses &#x3D; mutableInetSocketAddresses</span><br><span class="line"></span><br><span class="line">    val socketHost: String</span><br><span class="line">    val socketPort: Int</span><br><span class="line">    &#x2F;&#x2F; 如果代理类型为直连或者Socket类型，则可以直接用他们提供的host port ，否则通过InetSocketAddress获取真实地址</span><br><span class="line">    if (proxy.type() &#x3D;&#x3D; Proxy.Type.DIRECT || proxy.type() &#x3D;&#x3D; Proxy.Type.SOCKS) &#123;</span><br><span class="line">      socketHost &#x3D; address.url.host</span><br><span class="line">      socketPort &#x3D; address.url.port</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      val proxyAddress &#x3D; proxy.address()</span><br><span class="line">      require(proxyAddress is InetSocketAddress) &#123;</span><br><span class="line">        &quot;Proxy.address() is not an InetSocketAddress: $&#123;proxyAddress.javaClass&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      socketHost &#x3D; proxyAddress.socketHost</span><br><span class="line">      socketPort &#x3D; proxyAddress.port</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查端口设置是否超过范围</span><br><span class="line">    if (socketPort !in 1..65535) &#123;</span><br><span class="line">      throw SocketException(&quot;No route to $socketHost:$socketPort; port is out of range&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 proxy 为 SOCKTS 代理则不需要处理 host dns，否则预处理host 的dns解析结果</span><br><span class="line">    if (proxy.type() &#x3D;&#x3D; Proxy.Type.SOCKS) &#123;</span><br><span class="line">     &#x2F;&#x2F; SOCKS 代理不需要解析host ip, 根据主机名和端口号创建未解析的套接字地址</span><br><span class="line">      mutableInetSocketAddresses +&#x3D; InetSocketAddress.createUnresolved(socketHost, socketPort)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      eventListener.dnsStart(call, socketHost)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 根据提供的host查询到支持的所有ip地址信息</span><br><span class="line">      val addresses &#x3D; address.dns.lookup(socketHost)</span><br><span class="line">      if (addresses.isEmpty()) &#123;</span><br><span class="line">        throw UnknownHostException(&quot;$&#123;address.dns&#125; returned no addresses for $socketHost&quot;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      eventListener.dnsEnd(call, socketHost, addresses)</span><br><span class="line">      &#x2F;&#x2F; 将所解析出来的所有地址封装套接字地址</span><br><span class="line">      for (inetAddress in addresses) &#123;</span><br><span class="line">        mutableInetSocketAddresses +&#x3D; InetSocketAddress(inetAddress, socketPort)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">operator fun next(): Selection &#123;</span><br><span class="line">    if (!hasNext()) throw NoSuchElementException()</span><br><span class="line"></span><br><span class="line">    val routes &#x3D; mutableListOf&lt;Route&gt;()</span><br><span class="line">    while (hasNextProxy()) &#123;</span><br><span class="line">      &#x2F;&#x2F; nextProxy() 读取一个Proxy信息，并对inetSocketAddresses 连接点进行预处理</span><br><span class="line">      val proxy &#x3D; nextProxy()</span><br><span class="line">      for (inetSocketAddress in inetSocketAddresses) &#123;</span><br><span class="line">      &#x2F;&#x2F;  将 inetSocketAddress 包装成 Route</span><br><span class="line">        val route &#x3D; Route(address, proxy, inetSocketAddress)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 该Route是否在黑名单中，否则添加到候选routes中</span><br><span class="line">        if (routeDatabase.shouldPostpone(route)) &#123;</span><br><span class="line">          postponedRoutes +&#x3D; route</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          routes +&#x3D; route</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (routes.isNotEmpty()) &#123;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果没有可用的 Route 就将之前不可用的 Route拿来尽可能尝试下</span><br><span class="line">    if (routes.isEmpty()) &#123;</span><br><span class="line">      routes +&#x3D; postponedRoutes</span><br><span class="line">      postponedRoutes.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Selection(routes)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在next中主要处理：</p><ul><li>读取Proxy信息，如果非Socket代理则对host提前进行dns解析，得到ip</li><li>对Proxy和所解析出所有结果进行Route包装</li><li>将所获得的Route包装集合封装到Selection中，提供给使用方选择连接点</li></ul><h3 id="ConnectionSpec-与-ConnectionSpecSelector"><a href="#ConnectionSpec-与-ConnectionSpecSelector" class="headerlink" title="ConnectionSpec 与 ConnectionSpecSelector"></a>ConnectionSpec 与 ConnectionSpecSelector</h3><p>ConnectionSpec 主要是对连接时对Socket的配置，这里面包括TLS所需要进行的版本和密码套件协商信息，而ConnectionSpecSelector 则对最终选择的ConnectionSpec 进行筛选，目前仅对SSLSocket进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主要对Socket所支持的协议和加密配套进行交集判断</span><br><span class="line">  fun isCompatible(socket: SSLSocket): Boolean &#123;</span><br><span class="line">    if (!isTls) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tlsVersionsAsString !&#x3D; null &amp;&amp;</span><br><span class="line">        !tlsVersionsAsString.hasIntersection(socket.enabledProtocols, naturalOrder())) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cipherSuitesAsString !&#x3D; null &amp;&amp;</span><br><span class="line">        !cipherSuitesAsString.hasIntersection(</span><br><span class="line">            socket.enabledCipherSuites, CipherSuite.ORDER_BY_NAME)) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fun configureSecureSocket(sslSocket: SSLSocket): ConnectionSpec &#123;</span><br><span class="line">    var tlsConfiguration: ConnectionSpec? &#x3D; null</span><br><span class="line">    for (i in nextModeIndex until connectionSpecs.size) &#123;</span><br><span class="line">      val connectionSpec &#x3D; connectionSpecs[i]</span><br><span class="line">      &#x2F;&#x2F; 判断该配置是否和当前连接兼容</span><br><span class="line">      if (connectionSpec.isCompatible(sslSocket)) &#123;</span><br><span class="line">        tlsConfiguration &#x3D; connectionSpec</span><br><span class="line">        nextModeIndex &#x3D; i + 1</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tlsConfiguration &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw UnknownServiceException(&quot;Unable to find acceptable protocols. isFallback&#x3D;$isFallback,&quot; +</span><br><span class="line">          &quot; modes&#x3D;$connectionSpecs,&quot; +</span><br><span class="line">          &quot; supported protocols&#x3D;$&#123;sslSocket.enabledProtocols!!.contentToString()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isFallbackPossible &#x3D; isFallbackPossible(sslSocket)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 对SSLSocket进行配置应用</span><br><span class="line">    tlsConfiguration.apply(sslSocket, isFallback)</span><br><span class="line"></span><br><span class="line">    return tlsConfiguration</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>OkHttp 中配置了几个基本的默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通用加密套件</span><br><span class="line">private val RESTRICTED_CIPHER_SUITES &#x3D; arrayOf(</span><br><span class="line">    &#x2F;&#x2F; TLSv1.3.</span><br><span class="line">    CipherSuite.TLS_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TLSv1.0, TLSv1.1, TLSv1.2.</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所有支持的加密套件，包括后面可能不被支持的加密，用于兼容一些老平台</span><br><span class="line">private val APPROVED_CIPHER_SUITES &#x3D; arrayOf(</span><br><span class="line">    &#x2F;&#x2F; TLSv1.3.</span><br><span class="line">    CipherSuite.TLS_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TLSv1.0, TLSv1.1, TLSv1.2.</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下加密套在Http2.0可能被废弃</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA)</span><br><span class="line"></span><br><span class="line">&#x2F;** 目前主流的配置方案 *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val RESTRICTED_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*RESTRICTED_CIPHER_SUITES) &#x2F;&#x2F; 密码套件</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2) &#x2F;&#x2F; TLS 支持版本</span><br><span class="line">    .supportsTlsExtensions(true) &#x2F;&#x2F; TLS异常</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 适配大部分平台的配置方案(扩大加密套件的支持，以兼容一些平台)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val MODERN_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)</span><br><span class="line">    .supportsTlsExtensions(true)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 向后大部分兼容的的配置方案，包含 TLS1.3、TLS1.2、TLS1.1、TLS1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val COMPATIBLE_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)</span><br><span class="line">    .supportsTlsExtensions(true)</span><br><span class="line">    .build()</span><br><span class="line">    </span><br><span class="line">&#x2F;** 明文配置，用于Http，不进行TLS *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val CLEARTEXT &#x3D; Builder(false).build()</span><br></pre></td></tr></table></figure><p>通过<code>OkHttpClient.Builder.connectionSpecs</code>可以对候选配置内容进行配置，默认情况下使用 <code>DEFAULT_CONNECTION_SPECS</code> 组合</p><h4 id="ConnectionSpec-apply-配置"><a href="#ConnectionSpec-apply-配置" class="headerlink" title="ConnectionSpec.apply 配置"></a>ConnectionSpec.apply 配置</h4><p>apply 主要对最终连接的 SSLSocket 的加密配套和 TLS版本根据 SSLSocket支持的情况和 OkHttp 配置要求的情况进行交集配置。</p><p><code>如果需要对OkHttp TLS 版本或者加密配套相关调整，需要注意改动不仅仅是OkHttp的配置还需要对SSLSocket.setEnableCipherSuites 进行处理，这些内容都可以在 OkHttpClient.Build.sslSocketFactory 进行配置</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">internal fun apply(sslSocket: SSLSocket, isFallback: Boolean) &#123;</span><br><span class="line">  val specToApply &#x3D; supportedSpec(sslSocket, isFallback)</span><br><span class="line">  </span><br><span class="line">  if (specToApply.tlsVersions !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledProtocols &#x3D; specToApply.tlsVersionsAsString</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (specToApply.cipherSuites !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites &#x3D; specToApply.cipherSuitesAsString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主要对SSLSocket 一些支持信息（TLS版本、加密套）和 所配置的内容进行匹配，取交集得到最终要求的TLS版本和配件套</span><br><span class="line">private fun supportedSpec(sslSocket: SSLSocket, isFallback: Boolean): ConnectionSpec &#123;</span><br><span class="line">  &#x2F;&#x2F; 所配置的加密配件和SSLSocket.enabledCipherSuites所支持的配件套交集</span><br><span class="line">  var cipherSuitesIntersection &#x3D; if (cipherSuitesAsString !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites.intersect(cipherSuitesAsString, CipherSuite.ORDER_BY_NAME)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 所配置的TLS版本和SSLSocket.enabledProtocols所支持交集结果</span><br><span class="line">  val tlsVersionsIntersection &#x3D; if (tlsVersionsAsString !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledProtocols.intersect(tlsVersionsAsString, naturalOrder())</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sslSocket.enabledProtocols</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; TLS_FALLBACK_SCSV 支持</span><br><span class="line">  val supportedCipherSuites &#x3D; sslSocket.supportedCipherSuites</span><br><span class="line">  val indexOfFallbackScsv &#x3D; supportedCipherSuites.indexOf(</span><br><span class="line">      &quot;TLS_FALLBACK_SCSV&quot;, CipherSuite.ORDER_BY_NAME)</span><br><span class="line">  if (isFallback &amp;&amp; indexOfFallbackScsv !&#x3D; -1) &#123;</span><br><span class="line">    cipherSuitesIntersection &#x3D; cipherSuitesIntersection.concat(</span><br><span class="line">        supportedCipherSuites[indexOfFallbackScsv])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Builder(this)</span><br><span class="line">      .cipherSuites(*cipherSuitesIntersection)</span><br><span class="line">      .tlsVersions(*tlsVersionsIntersection)</span><br><span class="line">      .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RealConnection中的连接"><a href="#RealConnection中的连接" class="headerlink" title="RealConnection中的连接"></a>RealConnection中的连接</h3><p>真正通道连接发生在 RealConnect.connet 。</p><p>connet 主要分为几个流程：</p><ul><li>获取Socket配置（ConnectionSpec、ConnectionSpecSelector）</li><li>校验如果没有配置SSLSocketFactory，是否支持明文配置（ConnectionSpec.CLEARTEXT），平台是否支持明文传输</li><li>根据Route连接要求，是否只是建立 TCP连接或者隧道连接，在建立连接后进行协议连接（TLS连接、HTTP2.0连接）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">fun connect(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   pingIntervalMillis: Int,</span><br><span class="line">   connectionRetryEnabled: Boolean,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   &#x2F;&#x2F; 要求 protocol 必须为null , 没有连接过</span><br><span class="line">   check(protocol &#x3D;&#x3D; null) &#123; &quot;already connected&quot; &#125;</span><br><span class="line"></span><br><span class="line">   var routeException: RouteException? &#x3D; null</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 获取连接配套配置</span><br><span class="line">   val connectionSpecs &#x3D; route.address.connectionSpecs</span><br><span class="line">   &#x2F;&#x2F; 获得配置选择器</span><br><span class="line">   val connectionSpecSelector &#x3D; ConnectionSpecSelector(connectionSpecs)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果 OkHttpClient.Builder 没有配置 SSLSocketFactory 则表示协议使用明文传输（不适用HTTPS)</span><br><span class="line">   if (route.address.sslSocketFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查明文配置是否在配置列表中</span><br><span class="line">     if (ConnectionSpec.CLEARTEXT !in connectionSpecs) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;CLEARTEXT communication not enabled for client&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F; 检查平台是否支持该域名的明文传输（9.0 默认不支持Http明文传输）</span><br><span class="line">     val host &#x3D; route.address.url.host</span><br><span class="line">     if (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;CLEARTEXT communication to $host not permitted by network security policy&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果设置了SSL 则不允许 H2_PRIOR_KNOWLEDGE 协议（需要明文传输）</span><br><span class="line">     if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;H2_PRIOR_KNOWLEDGE cannot be used with HTTPS&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   while (true) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       &#x2F;&#x2F; 是否要求隧道连接</span><br><span class="line">       if (route.requiresTunnel()) &#123;</span><br><span class="line">         connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">         if (rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">           &#x2F;&#x2F; We were unable to connect the tunnel but properly closed down our resources.</span><br><span class="line">           break</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 建立Socket连接</span><br><span class="line">         connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 确定协议和TLS连接，如果为HTTP2.0 则直接建立连接</span><br><span class="line">       establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">       eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">       break</span><br><span class="line">     &#125; catch (e: IOException) &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立TCP Socket连接</span><br><span class="line"> private fun connectSocket(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   val proxy &#x3D; route.proxy</span><br><span class="line">   val address &#x3D; route.address</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果是直连或者HTTP代理，都需要建立Socket，否则直接创建proxy的Socket代理</span><br><span class="line">   val rawSocket &#x3D; when (proxy.type()) &#123;</span><br><span class="line">     Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">     else -&gt; Socket(proxy)</span><br><span class="line">   &#125;</span><br><span class="line">   this.rawSocket &#x3D; rawSocket</span><br><span class="line"></span><br><span class="line">   eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">   rawSocket.soTimeout &#x3D; readTimeout</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 调用平台创建连接Socket的方法</span><br><span class="line">     Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">   &#125; catch (e: ConnectException) &#123;</span><br><span class="line">     throw ConnectException(&quot;Failed to connect to $&#123;route.socketAddress&#125;&quot;).apply &#123;</span><br><span class="line">       initCause(e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 建立TCP连接后的流控制</span><br><span class="line">     source &#x3D; rawSocket.source().buffer()</span><br><span class="line">     sink &#x3D; rawSocket.sink().buffer()</span><br><span class="line">   &#125; catch (npe: NullPointerException) &#123;</span><br><span class="line">     if (npe.message &#x3D;&#x3D; NPE_THROW_WITH_NULL) &#123;</span><br><span class="line">       throw IOException(npe)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立TLS连接</span><br><span class="line"> private fun connectTls(connectionSpecSelector: ConnectionSpecSelector) &#123;</span><br><span class="line">   val address &#x3D; route.address</span><br><span class="line">   val sslSocketFactory &#x3D; address.sslSocketFactory</span><br><span class="line">   var success &#x3D; false</span><br><span class="line">   var sslSocket: SSLSocket? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 调用 OkHttpClient.Build.sslSocketFactory 构造 SSLSocket</span><br><span class="line">     &#x2F;&#x2F; Create the wrapper over the connected socket.</span><br><span class="line">     sslSocket &#x3D; sslSocketFactory!!.createSocket(</span><br><span class="line">         rawSocket, address.url.host, address.url.port, true &#x2F;* autoClose *&#x2F;) as SSLSocket</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 定义TLS版本和加密配套及其扩展</span><br><span class="line">     val connectionSpec &#x3D; connectionSpecSelector.configureSecureSocket(sslSocket)</span><br><span class="line">     &#x2F;&#x2F; 如果支持TLS扩展，调用平台扩展</span><br><span class="line">     if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">       Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 进行握手</span><br><span class="line">     &#x2F;&#x2F; Force handshake. This can throw!</span><br><span class="line">     sslSocket.startHandshake()</span><br><span class="line">     &#x2F;&#x2F; block for session establishment</span><br><span class="line">     val sslSocketSession &#x3D; sslSocket.session</span><br><span class="line">     val unverifiedHandshake &#x3D; sslSocketSession.handshake()</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 证书验证（OkHostnameVerifier），验证地址和目标地址ip，如果不通过则抛出</span><br><span class="line">     if (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) &#123;</span><br><span class="line">       &#x2F;&#x2F; 验证不通过则抛出异常</span><br><span class="line">       val peerCertificates &#x3D; unverifiedHandshake.peerCertificates</span><br><span class="line">       if (peerCertificates.isNotEmpty()) &#123;</span><br><span class="line">         val cert &#x3D; peerCertificates[0] as X509Certificate</span><br><span class="line">         throw SSLPeerUnverifiedException(&quot;&quot;&quot;</span><br><span class="line">             |Hostname $&#123;address.url.host&#125; not verified:</span><br><span class="line">             |    certificate: $&#123;CertificatePinner.pin(cert)&#125;</span><br><span class="line">             |    DN: $&#123;cert.subjectDN.name&#125;</span><br><span class="line">             |    subjectAltNames: $&#123;OkHostnameVerifier.allSubjectAltNames(cert)&#125;</span><br><span class="line">             &quot;&quot;&quot;.trimMargin())</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         throw SSLPeerUnverifiedException(</span><br><span class="line">             &quot;Hostname $&#123;address.url.host&#125; not verified (no certificates)&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 证书锁定器，用来抵抗CA攻击、中间人攻击</span><br><span class="line">     val certificatePinner &#x3D; address.certificatePinner!!</span><br><span class="line"></span><br><span class="line">     handshake &#x3D; Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,</span><br><span class="line">         unverifiedHandshake.localCertificates) &#123;</span><br><span class="line">       &#x2F;&#x2F; certificateChainCleaner 用来验证证书链，并且排除一些和TLS握手无关的证书，返回可用的CA证书链</span><br><span class="line">       certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,</span><br><span class="line">           address.url.host)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 验证该host的证书支持的 hash 类型</span><br><span class="line">     certificatePinner.check(address.url.host) &#123;</span><br><span class="line">       handshake!!.peerCertificates.map &#123; it as X509Certificate &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; ALPN 扩展协议处理</span><br><span class="line">     val maybeProtocol &#x3D; if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">       Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       null</span><br><span class="line">     &#125;</span><br><span class="line">     socket &#x3D; sslSocket</span><br><span class="line">     source &#x3D; sslSocket.source().buffer()</span><br><span class="line">     sink &#x3D; sslSocket.sink().buffer()</span><br><span class="line">     protocol &#x3D; if (maybeProtocol !&#x3D; null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1</span><br><span class="line">     success &#x3D; true</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     &#x2F;&#x2F; 握手后操作</span><br><span class="line">     if (sslSocket !&#x3D; null) &#123;</span><br><span class="line">       Platform.get().afterHandshake(sslSocket)</span><br><span class="line">     &#125;</span><br><span class="line">     if (!success) &#123;</span><br><span class="line">       sslSocket?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立隧道连接</span><br><span class="line"> private fun connectTunnel(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   &#x2F;&#x2F; 封装请求头</span><br><span class="line">   var tunnelRequest: Request &#x3D; createTunnelRequest()</span><br><span class="line">   val url &#x3D; tunnelRequest.url</span><br><span class="line">   &#x2F;&#x2F; 做多尝试21次建立</span><br><span class="line">   for (i in 0 until MAX_TUNNEL_ATTEMPTS) &#123;</span><br><span class="line">     &#x2F;&#x2F; 先建立TCP连接</span><br><span class="line">     connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 创建隧道连接</span><br><span class="line">     tunnelRequest &#x3D; createTunnel(readTimeout, writeTimeout, tunnelRequest, url)</span><br><span class="line">         ?: break </span><br><span class="line"></span><br><span class="line">     rawSocket?.closeQuietly()</span><br><span class="line">     rawSocket &#x3D; null</span><br><span class="line">     sink &#x3D; null</span><br><span class="line">     source &#x3D; null</span><br><span class="line">     eventListener.connectEnd(call, route.socketAddress, route.proxy, null)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="回归findConnection"><a href="#回归findConnection" class="headerlink" title="回归findConnection"></a>回归findConnection</h3><p>回归到 <code>ConnectInterceptor.intercept</code> 方法，在该方法中，主要对调用 <code>RealCall.newExchange</code> 获取 <code>Exchange</code> 代理对象，通过 <code>Exchange</code> 可以建立的连接上进行数据交互。</p><p>在 <code>newExchange</code> 中主要经历几个流程：</p><p><code>RealCall.newExchange（返回 Exchange） -&gt; ExchangeFinder.find (返回 ExchangeCodec) -&gt; ExchangeFinder.findHealthyConnection （返回 RealConnection ）-&gt; ExchangeFinder.findConnection （返回 RealConnection）</code></p><p>在 findConnection 中获得主要负责连接的代理对象 <code>RealConnection</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">private fun findConnection(</span><br><span class="line">  connectTimeout: Int,</span><br><span class="line">  readTimeout: Int,</span><br><span class="line">  writeTimeout: Int,</span><br><span class="line">  pingIntervalMillis: Int,</span><br><span class="line">  connectionRetryEnabled: Boolean</span><br><span class="line">): RealConnection &#123;</span><br><span class="line">  var foundPooledConnection &#x3D; false</span><br><span class="line">  var result: RealConnection? &#x3D; null</span><br><span class="line">  var selectedRoute: Route? &#x3D; null</span><br><span class="line">  var releasedConnection: RealConnection?</span><br><span class="line">  val toClose: Socket?</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用被取消则直接退出</span><br><span class="line">    if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    hasStreamFailure &#x3D; false &#x2F;&#x2F; This is a fresh attempt.</span><br><span class="line"></span><br><span class="line">    releasedConnection &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果call.connection的连接不允许创建新的传输（noNewExcahnges)，则返回当前连接的Socket，以用于释放连接</span><br><span class="line">    toClose &#x3D; if (call.connection !&#x3D; null &amp;&amp; call.connection!!.noNewExchanges) &#123;</span><br><span class="line">      call.releaseConnectionNoEvents()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果call 以及存在 connection 则复用结果</span><br><span class="line">    if (call.connection !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 使用以及存在连接代替</span><br><span class="line">      &#x2F;&#x2F; We had an already-allocated connection and it&#39;s good.</span><br><span class="line">      result &#x3D; call.connection</span><br><span class="line">      releasedConnection &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果为null ，代表当前call 不存在使用中的连接，从之前的连接池中查询</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断连接池中是否存在符合条件的连接（已经被回收）</span><br><span class="line">      if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; call.connection</span><br><span class="line">      &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果未找到合适复用连接 则查看是否有需要优先选择的路由路线</span><br><span class="line">        selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">        nextRouteToTry &#x3D; null</span><br><span class="line">      &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果没有，则直接重新计算路由</span><br><span class="line">        selectedRoute &#x3D; call.connection!!.route()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">  if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">    eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">  &#125;</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在之前中已经找到已经可使用的连接</span><br><span class="line">  if (result !&#x3D; null) &#123;</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var newRouteSelection &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果还没有Route选定并且 RouteSelection 还未初始化，则进行初始化，以备下面使用</span><br><span class="line">  if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">    newRouteSelection &#x3D; true</span><br><span class="line">    routeSelection &#x3D; routeSelector.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查调用是否被取消</span><br><span class="line">    if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果新建 RouteSelection 则进行重新Route的获取</span><br><span class="line">    if (newRouteSelection) &#123;</span><br><span class="line">      routes &#x3D; routeSelection!!.routes</span><br><span class="line">      &#x2F;&#x2F; 获取连接池中适合call所使用的连接，如果返回true在表示已有合适的连接和call绑定（call.acquireConnectionNoEvents）</span><br><span class="line">      if (connectionPool.callAcquirePooledConnection(address, call, routes, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; call.connection &#x2F;&#x2F; 获取当前所获得的复用的连接</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没在连接池中获得复用连接，则从路由节点中获得新的路由点（尝试在接下来中进行连接）</span><br><span class="line">    if (!foundPooledConnection) &#123;</span><br><span class="line">      if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果之前还没对Route路线进行选择，则进行路由选择</span><br><span class="line">        selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建连接</span><br><span class="line">      result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">      connectingConnection &#x3D; result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果在连接池中找到则返回结果</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 开执TCP TLS 连接</span><br><span class="line">  result!!.connect(</span><br><span class="line">      connectTimeout,</span><br><span class="line">      readTimeout,</span><br><span class="line">      writeTimeout,</span><br><span class="line">      pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled,</span><br><span class="line">      call,</span><br><span class="line">      eventListener</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 连接成功后，如果routeDatabase列表中（失败节点）存在该Route则从黑名单中移除</span><br><span class="line">  call.client.routeDatabase.connected(result!!.route())</span><br><span class="line"></span><br><span class="line">  var socket: Socket? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    connectingConnection &#x3D; null</span><br><span class="line">    if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123;</span><br><span class="line">      result!!.noNewExchanges &#x3D; true</span><br><span class="line">      socket &#x3D; result!!.socket()</span><br><span class="line">      result &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">      nextRouteToTry &#x3D; selectedRoute</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      connectionPool.put(result!!)</span><br><span class="line">      call.acquireConnectionNoEvents(result!!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  return result!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在流程中 findConnection 是比较重要的一个流程。这里实现了OkHttp 连接复用流程。对于连接成功后的连接 通过 <code>RealConnectionPool.put</code> 进行缓存。</p><h4 id="ConnectionPool-连接复用"><a href="#ConnectionPool-连接复用" class="headerlink" title="ConnectionPool 连接复用"></a>ConnectionPool 连接复用</h4><p>ConnectionPool 在整个连接过程中，记录着连接的变化</p><h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p><code>CallServerInterceptor</code> 负责在数据传输上的处理，包括在HTTP上传递头部和Body信息（应用层数据传输）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"> override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val exchange &#x3D; realChain.exchange()</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    val requestBody &#x3D; request.body</span><br><span class="line">    val sentRequestMillis &#x3D; System.currentTimeMillis()</span><br><span class="line">    &#x2F;&#x2F; 向 Exchange 写入头部信息</span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    var invokeStartEvent &#x3D; true</span><br><span class="line">    var responseBuilder: Response.Builder? &#x3D; null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组装RequestBody，如果该次事务不需要则 exchange.noRequestBody()</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 100-continue 状况，表示需要多次传输</span><br><span class="line">      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行请求</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; true)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否支持二进制body（HTTP2.0）</span><br><span class="line">        if (requestBody.isDuplex()) &#123;</span><br><span class="line">          &#x2F;&#x2F; 创建二进制RequestBody</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, true).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 直接发送body内容</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, false).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        &#x2F;&#x2F; 不支持多路，关闭事务</span><br><span class="line">        if (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行不带body的请求</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 到这里如果不支持二进制body HTTP2.0 则完成该次请求</span><br><span class="line">    if (requestBody &#x3D;&#x3D; null || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取请求结果</span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    var code &#x3D; response.code</span><br><span class="line">    if (code &#x3D;&#x3D; 100) &#123;</span><br><span class="line">      &#x2F;&#x2F; Server sent a 100-continue even though we did not request one. Try again to read the actual</span><br><span class="line">      &#x2F;&#x2F; response status.</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response &#x3D; responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code &#x3D; response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response &#x3D; if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">      &#x2F;&#x2F; Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase &#x3D; true) ||</span><br><span class="line">        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    if ((code &#x3D;&#x3D; 204 || code &#x3D;&#x3D; 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123;</span><br><span class="line">      throw ProtocolException(</span><br><span class="line">          &quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、主要构件&quot;&gt;&lt;a href=&quot;#一、主要构件&quot; class=&quot;headerlink&quot; title=&quot;一、主要构件&quot;&gt;&lt;/a&gt;一、主要构件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;OkhttpClient 请求总引擎代理&lt;/li&gt;
&lt;li&gt;Request 请求体信息，通过Re
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="OkHttp" scheme="http://yoursite.com/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack-ViewModel</title>
    <link href="http://yoursite.com/2019/02/21/Jetpack-ViewModel/"/>
    <id>http://yoursite.com/2019/02/21/Jetpack-ViewModel/</id>
    <published>2019-02-20T17:36:11.000Z</published>
    <updated>2020-04-20T17:37:10.759Z</updated>
    
    <content type="html"><![CDATA[<p>ViewModel 目的在于借助于生命周期管理解决 View 层与界面数据相关的解耦。<br>通常使用在 Activity、Fragment 中关于数据的存储、Fragment间的通信等方面。</p><h1 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h1><p>基于AndroidX的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&quot;</span><br></pre></td></tr></table></figure><h1 id="二、-基本使用"><a href="#二、-基本使用" class="headerlink" title="二、 基本使用"></a>二、 基本使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        </span><br><span class="line">        val viewModel &#x3D; ViewModelProvider(this).get(MainViewModel::class.java)</span><br><span class="line">        contentVp.adapter &#x3D; FragmentsViewPager(</span><br><span class="line">            mutableListOf(</span><br><span class="line">                Main1Fragment(),</span><br><span class="line">                Main2Fragment()</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private inner class FragmentsViewPager(private val fragments : List&lt;Fragment&gt;) : FragmentPagerAdapter(supportFragmentManager) &#123;</span><br><span class="line">        override fun getItem(position: Int): Fragment &#x3D; fragments[position]</span><br><span class="line">        override fun getCount(): Int &#x3D; fragments.size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Main1Fragment: Fragment() &#123;</span><br><span class="line">    override fun onCreateView(</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        savedInstanceState: Bundle?</span><br><span class="line">    ): View? &#123;</span><br><span class="line">        val rootView &#x3D; inflater.inflate(R.layout.fragment_main, container, false)</span><br><span class="line">        val activity &#x3D; activity as AppCompatActivity</span><br><span class="line">        &#x2F;&#x2F; 获取 Activity 共享的 MainViewModel</span><br><span class="line">        val viewModel &#x3D; ViewModelProvider(activity).get(MainViewModel::class.java)</span><br><span class="line">        rootView.tagTv.text &#x3D; &quot;Fragment 1&quot;</span><br><span class="line">        rootView.sendBtn.setOnClickListener &#123;</span><br><span class="line">            viewModel.data.value &#x3D; rootView.inputEt.text.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.data.observe(activity, Observer &#123;message -&gt;</span><br><span class="line">            outputTv.text &#x3D; message</span><br><span class="line">        &#125;)</span><br><span class="line">        return rootView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Main2Fragment: Fragment() &#123;</span><br><span class="line">    override fun onCreateView(</span><br><span class="line">        inflater: LayoutInflater,</span><br><span class="line">        container: ViewGroup?,</span><br><span class="line">        savedInstanceState: Bundle?</span><br><span class="line">    ): View? &#123;</span><br><span class="line">        val rootView &#x3D; inflater.inflate(R.layout.fragment_main, container, false)</span><br><span class="line">        val activity &#x3D; activity as AppCompatActivity</span><br><span class="line">        &#x2F;&#x2F; 获取 Activity 共享的 MainViewModel</span><br><span class="line">        val viewModel &#x3D; ViewModelProvider(activity).get(MainViewModel::class.java)</span><br><span class="line">        rootView.tagTv.text &#x3D; &quot;Fragment 2&quot;</span><br><span class="line">        rootView.sendBtn.setOnClickListener &#123;</span><br><span class="line">            viewModel.data.value &#x3D; rootView.inputEt.text.toString()</span><br><span class="line">        &#125;</span><br><span class="line">        viewModel.data.observe(activity, Observer &#123;message -&gt;</span><br><span class="line">            outputTv.text &#x3D; message</span><br><span class="line">        &#125;)</span><br><span class="line">        return rootView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainViewModel: ViewModel() &#123;</span><br><span class="line">    val data &#x3D; MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/28160/WEBRESOURCEc15c683cca54809bb18bbc69b0d899dd"  alt="image"></p><p>以上例子是对两个Fragment 之间共享一个 <code>ViewModel</code> 例子，基本的流程如下：</p><ol><li>继承 <code>ViewModel</code> 产生自己的ViewModle 对象，在<code>ViewModel</code>实现类中，声明自己的字段（通常使用 LiveData 框架声明，方便对数据变化进行观察。）。</li><li>在需要对需要监听数据的类中（例如例子中Main1Fragment 与 Main2Fragment 需要对 MainViewModle.data 的值变化关心），构造<code>ViewModelProvider</code>，通过 <code>ViewModelProvider.get</code> 获取指定的<code>ViewModel</code>实例。 <blockquote><p>这里需要注意，构造 <code>ViewModelProvider(ViewModelStoreOwner owner)</code>时所传入的 owner 参数，关系到你需要从哪个<code>ViewModelStore</code>中获取对应的 <code>ViewModel</code> 缓存。因此以上例子中，都是从<code>activity</code>中获取<code>MainViewModel</code>.</p></blockquote></li><li>当数据发生变化时，对<code>ViewMdoel</code>内的字段进行赋值。因为这里使用的LiveData，因此当发生 <code>viewModel.data.setValue</code> 时，之前对<code>viewModel.data.observe</code> 进行注册的 <code>Observer {message -&gt; outputTv.text = message}</code> 回调将响应数据变化，执行操作，将数据刷新到 <code>outputTv</code> 上。</li></ol><h2 id="其他作用"><a href="#其他作用" class="headerlink" title="其他作用"></a>其他作用</h2><p>ViewModel 当然不仅在解决组件间通信起到作用，另外上还可以：</p><ul><li>解决运行时数据持久化问题，对于存储在 Activity 中的数据，当发生Activity内存回收、旋转等问题时，我们不得不重新对数据进行加载。ViewModel 则可以将这部分希望持久数据转移这里，当发生重建时，则重新读取的还是原来的ViewModel。</li><li>ViewModel 借助于 Lifecycle，当组件生命周期结束时，将自动进行释放<code>ViewModel.clear()</code>，如果发生重建则可以进行重新数据加载。让数据具有对生命周期的感知能力。</li><li>解耦 View 层的职责，降低 Activity 、Fragment 的负担，将复杂的逻辑通过ViewModel 进行解耦，Activity、Fragment View层几乎不需要进行耦合业务。</li></ul><h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><p>我们从 <code>ViewModel</code> 开始进行分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ViewModel &#123;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 触发对 ViewModel 内容的回收，ViewModel 提供了 mBagOfTags 可以用于存储着</span><br><span class="line">   &#x2F;&#x2F; Closeable 实现对象，如果在mBagOfTags 有Closeable 实例，则会自动调用</span><br><span class="line">   &#x2F;&#x2F; close()</span><br><span class="line">    @MainThread</span><br><span class="line">    final void clear() &#123;</span><br><span class="line">        mCleared &#x3D; true;</span><br><span class="line">        if (mBagOfTags !&#x3D; null) &#123;</span><br><span class="line">            synchronized (mBagOfTags) &#123;</span><br><span class="line">                for (Object value : mBagOfTags.values()) &#123;</span><br><span class="line">                    closeWithRuntimeException(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onCleared();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 用于暂存对象，与 getTag 相对</span><br><span class="line">    &lt;T&gt; T setTagIfAbsent(String key, T newValue) &#123;</span><br><span class="line">        T previous;</span><br><span class="line">        synchronized (mBagOfTags) &#123;</span><br><span class="line">            previous &#x3D; (T) mBagOfTags.get(key);</span><br><span class="line">            if (previous &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mBagOfTags.put(key, newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        T result &#x3D; previous &#x3D;&#x3D; null ? newValue : previous;</span><br><span class="line">        if (mCleared) &#123;</span><br><span class="line">            closeWithRuntimeException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获取在之前 setTagIfAbsent 中存储的对象</span><br><span class="line">    @SuppressWarnings(&#123;&quot;TypeParameterUnusedInFormals&quot;, &quot;unchecked&quot;&#125;)</span><br><span class="line">    &lt;T&gt; T getTag(String key) &#123;</span><br><span class="line">        if (mBagOfTags &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (mBagOfTags) &#123;</span><br><span class="line">            return (T) mBagOfTags.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewModel 只是个单纯的容器，在例子中<code>ViewModel</code>借助于 <code>ViewModelProvider.get</code> 进行创建并获取，其中 <code>ViewModelProvider</code>的构造需要 一个重要的参数 <code>ViewModelStoreOwner</code>，它提供了<code>ViewModel</code>所存储的所属位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ViewModelStoreOwner &#123;</span><br><span class="line">    ViewModelStore getViewModelStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/28244/WEBRESOURCE34bdb29514a7edc10c0cb5688bdf5df0"  alt="image.png"></p><p><code>ViewModelStoreOwner</code> 默认由 AndroidX 中 <code>AppCompatActivity</code> 、<code>Fragment</code>、<code>FragmentActivity</code> 主要组件实现，每个组件独立实现自身的 <code>ViewModelStore</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Activity 上的实现</span><br><span class="line">public class ComponentActivity extends androidx.core.app.ComponentActivity implements</span><br><span class="line">        LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner,</span><br><span class="line">        SavedStateRegistryOwner,</span><br><span class="line">        OnBackPressedDispatcherOwner &#123;</span><br><span class="line">    ...    </span><br><span class="line">    public ViewModelStore getViewModelStore() &#123;</span><br><span class="line">        if (getApplication() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Your activity is not yet attached to the &quot;</span><br><span class="line">                    + &quot;Application instance. You can&#39;t request ViewModel before onCreate call.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (mViewModelStore &#x3D;&#x3D; null) &#123;</span><br><span class="line">            NonConfigurationInstances nc &#x3D;</span><br><span class="line">                    (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">            if (nc !&#x3D; null) &#123;</span><br><span class="line">                &#x2F;&#x2F; Restore the ViewModelStore from NonConfigurationInstances</span><br><span class="line">                mViewModelStore &#x3D; nc.viewModelStore;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (mViewModelStore &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mViewModelStore &#x3D; new ViewModelStore();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mViewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  Fragment 的实现</span><br><span class="line">public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner,</span><br><span class="line">        ViewModelStoreOwner, SavedStateRegistryOwner &#123;</span><br><span class="line">        </span><br><span class="line">    ...    </span><br><span class="line">    public ViewModelStore getViewModelStore() &#123;</span><br><span class="line">        if (mFragmentManager &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;Can&#39;t access ViewModels from detached fragment&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return mFragmentManager.getViewModelStore(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FragmentActivity 的<code>getViewModelStore</code> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ViewModel 目的在于借助于生命周期管理解决 View 层与界面数据相关的解耦。&lt;br&gt;通常使用在 Activity、Fragment 中关于数据的存储、Fragment间的通信等方面。&lt;/p&gt;
&lt;h1 id=&quot;一、配置&quot;&gt;&lt;a href=&quot;#一、配置&quot; class=
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack-LiveData</title>
    <link href="http://yoursite.com/2019/02/17/Jetpack-LiveData/"/>
    <id>http://yoursite.com/2019/02/17/Jetpack-LiveData/</id>
    <published>2019-02-17T15:32:35.000Z</published>
    <updated>2020-04-20T17:34:22.465Z</updated>
    
    <content type="html"><![CDATA[<p>LiveData 算是对 Lifecycle 框架的应用，当LiveData 发生值变化时将对所订阅者进行更新，借助于Lifecycle生命周期的管理，自动对值更新、自动解绑进行了自动管理。</p><h1 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h1><p>基于AndroidX的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0&quot;</span><br></pre></td></tr></table></figure><h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val presenter by lazy &#123;</span><br><span class="line">        MainPresenter()</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        inputEt.addTextChangedListener(object : TextWatcher &#123;</span><br><span class="line">            override fun afterTextChanged(s: Editable?) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123;</span><br><span class="line">                presenter.data.value &#x3D; s.toString()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        presenter.data.observe(this, Observer &#123; text -&gt;</span><br><span class="line">            Log.i(&quot;BevisLogger&quot;, &quot;text changed : $text&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        lifecycle.addObserver(presenter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainPresenter: LifecycleObserver &#123;</span><br><span class="line">    val data &#x3D; MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子是对编辑框进行监控，当每次触填写字符变化时，都将相应Log输出。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27916/WEBRESOURCEa993828f8316bc75f186d313251dbf53"  alt="image.png"></p><p>每一个对编辑框编辑都触发，<code>MainPresenter.data</code> 都发起通知，Logger 输出：<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27918/WEBRESOURCE05918e89e3bcd22c75bae701b93f00be"  alt="image.png"></p><p>例子中主要涉及步骤：</p><ul><li>创建<code>LiveData</code>对象，声明类型，例子中在 MainPresenter 声明了 <code>MutableLiveData&lt;String&gt;</code> data 对象，因为声明类型为 <code>String</code> ，在 <code>LiveData</code> 中可以通过 <code>set</code> <code>get</code>设置<code>String</code>值。</li><li>在需要观察的对象中，调用<code>data.observe</code> 方法，传入 <code>LifecycleOwner</code> 和 回调对象 <code>Observer&lt;T&gt;</code></li><li>当每次对<code>LiveData.setValue</code> 或 <code>LiveData.postValue</code> 时，则会进行通知，响应到 <code>Observer&lt;T&gt;</code> 回调中。</li></ul><h1 id="三、源码解析"><a href="#三、源码解析" class="headerlink" title="三、源码解析"></a>三、源码解析</h1><p>LiveData 为我们解决了数据适配Android生命周期的问题，防止发生内存泄露。<br>通过LiveData 可以将项目最小成本的改造为数据驱动。下面分析在LiveData的主要几个动作。</p><h2 id="添加观察者"><a href="#添加观察者" class="headerlink" title="添加观察者"></a>添加观察者</h2><p>对于 <code>MutableLiveData&lt;String&gt;</code> 只是个简单的包装类，实际的实现逻辑集中在 <code>LiveData</code> 抽象类中。</p><p>我们先从订阅方法<code>observe</code> 开始。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">      &#x2F;&#x2F; 必须在主线程中进行观察者添加</span><br><span class="line">      assertMainThread(&quot;observe&quot;);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 如果当前被观察者已经销毁，则忽略订阅</span><br><span class="line">      if (owner.getLifecycle().getCurrentState() &#x3D;&#x3D; DESTROYED) &#123;</span><br><span class="line">          &#x2F;&#x2F; ignore</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 包装观察者，后面对 LifecycleBoundObserver 进行解析，该对象负责:</span><br><span class="line">      &#x2F;&#x2F; 1. </span><br><span class="line">      LifecycleBoundObserver wrapper &#x3D; new LifecycleBoundObserver(owner, observer);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 缓存观察者，一个 observer 只能绑定一个被观察者LifecycleOwner</span><br><span class="line">      ObserverWrapper existing &#x3D; mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">      if (existing !&#x3D; null &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                  + &quot; with different lifecycles&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (existing !&#x3D; null) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 数据包装作为观察者，订阅生命周期变化</span><br><span class="line">      owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这流程主要为了<code>Observer</code>包装为<code>LifecycleBoundObserver</code>，该<code>LifecycleBOundObserver</code>即为<code>LifecycleEventObserver</code> Lifecycle 框架定义的观察者，包装完成后 通过传入的<code>LifecycleOwner</code>建立订阅关系。</p><p>了解了以上订阅流程，那么就比较清楚，这里面重要的是当生命周期发生状态变化时，<code>LifecycleBoundObserver</code>的响应处理。</p><h2 id="变化与通知"><a href="#变化与通知" class="headerlink" title="变化与通知"></a>变化与通知</h2><p><code>LifecycleBoundObserver</code> 的继承关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们首先看  <code>LifecycleEventObserver.onStateChanged</code> 的响应实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">            @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果被观察者已经 DESTROYED 则注销订阅关系并不做响应        </span><br><span class="line">        if (mOwner.getLifecycle().getCurrentState() &#x3D;&#x3D; DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 当状态发生以STARTED状态为分界点状态前后变化时触发  </span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 当前的被观察者对象的周期阶段必须在STARTED及其之后为true，否则false</span><br><span class="line">    @Override</span><br><span class="line">    boolean shouldBeActive() &#123;</span><br><span class="line">        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br><span class="line">   </span><br><span class="line">private abstract class ObserverWrapper &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 当状态发生以STARTED状态为分界点状态前后变化时触发  </span><br><span class="line">    void activeStateChanged(boolean newActive) &#123;</span><br><span class="line">        &#x2F;&#x2F; 比较和之前的激活状态，如果发生变化才允许执行通知</span><br><span class="line">        if (newActive &#x3D;&#x3D; mActive) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新激活状态值</span><br><span class="line">        mActive &#x3D; newActive;</span><br><span class="line">        &#x2F;&#x2F; 表示未发生激活</span><br><span class="line">        boolean wasInactive &#x3D; LiveData.this.mActiveCount &#x3D;&#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 为激活状态进行计数，如果激活则 +1 如果失效 -1，如果被观察者正常周期结束，则会是 0 </span><br><span class="line">        LiveData.this.mActiveCount +&#x3D; mActive ? 1 : -1;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 之前为失效状态切换为当前激活状态(比如 CREATED -&gt; STARTED )，则调用 onActive</span><br><span class="line">        if (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 之前为失效状态更新为失效状态()，则调用 onInactive</span><br><span class="line">        if (LiveData.this.mActiveCount &#x3D;&#x3D; 0 &amp;&amp; !mActive) &#123;</span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 当前触发激活状态时，进行一次值变化通知</span><br><span class="line">        if (mActive) &#123;</span><br><span class="line">            dispatchingValue(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...    </span><br><span class="line">    </span><br><span class="line">   void dispatchingValue(@Nullable ObserverWrapper initiator) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果分发通知期间发现值发生变化，需要重新进行通知，那么标记当前分发的状</span><br><span class="line">        &#x2F;&#x2F; 态为 mDispatchInvalidated &#x3D; true </span><br><span class="line">        &#x2F;&#x2F; 非法状态，在下面循环中，如果发现该标记发生变化会重新进行通知</span><br><span class="line">        if (mDispatchingValue) &#123;</span><br><span class="line">            mDispatchInvalidated &#x3D; true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 标记正在执行通知</span><br><span class="line">        mDispatchingValue &#x3D; true;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 循环检测 mDispatchInvalidated 标记位，防止该次通知过期，需要重新通知</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F; 标记当前分发有效，如果在通知过程中，该值发生变化</span><br><span class="line">            &#x2F;&#x2F; 将重新进入该循环里面，重新进行通知</span><br><span class="line">            mDispatchInvalidated &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F; 如果指定了观察者目标</span><br><span class="line">            if (initiator !&#x3D; null) &#123;</span><br><span class="line">                单独对当前指定的观察者进行通知更新</span><br><span class="line">                considerNotify(initiator);</span><br><span class="line">                initiator &#x3D; null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历通知所有订阅者</span><br><span class="line">                for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator &#x3D;</span><br><span class="line">                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                    considerNotify(iterator.next().getValue());</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; 如果遍历过程中发现该次通知已经失效（由于值重新更新，需要</span><br><span class="line">                    &#x2F;&#x2F; 重新遍历），则中断通知剩下的观察者</span><br><span class="line">                    if (mDispatchInvalidated) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (mDispatchInvalidated);</span><br><span class="line">        mDispatchingValue &#x3D; false;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    private void considerNotify(ObserverWrapper observer) &#123;</span><br><span class="line">        if (!observer.mActive) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 确保是被观察者处于激活状态，否则不进行分发</span><br><span class="line">        if (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 值版本状态检查，如果最近观察者中的版本状态比</span><br><span class="line">        &#x2F;&#x2F; 当前通知的版本状态高，则该更新是非法的，值可</span><br><span class="line">        &#x2F;&#x2F; 能已经过期，不进行通知</span><br><span class="line">        if (observer.mLastVersion &gt;&#x3D; mVersion) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新观察者的值版本信息</span><br><span class="line">        observer.mLastVersion &#x3D; mVersion;</span><br><span class="line">        &#x2F;&#x2F; 执行观察者回调 onChanged</span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lifecycle 定义了几种状态，它们的关系为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESTROYED &lt; INITIALIZED &lt; CREATED &lt; STARTED &lt; RESUMED</span><br></pre></td></tr></table></figure><p>以 STARTED 为状态分界点，从 STARTED 之前的状态切换到 STARTED及其之后 或者 STARTED 切换到之前的状态时，会触发 <code>activeStateChanged</code> 响应。因此<code>activeStateChanged</code> 仅对是否允许值变化观察负责，相当于是对是否能够触发值变化回调的开关。</p><h2 id="setValue-值更新与通知"><a href="#setValue-值更新与通知" class="headerlink" title="setValue 值更新与通知"></a>setValue 值更新与通知</h2><p>那么当处于激活状态下，LiveData的发生变化是怎么进行通知？<br>我们从<code>LiveData.setValue</code> 入手。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">protected void setValue(T value) &#123;</span><br><span class="line">    assertMainThread(&quot;setValue&quot;);</span><br><span class="line">    &#x2F;&#x2F; 每次值发生变化，mVersion 都进行递增</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData &#x3D; value;</span><br><span class="line">    &#x2F;&#x2F; 对所有订阅者进行通知</span><br><span class="line">    dispatchingValue(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>续上上面的对<code>dispatchingValue</code>的解析就不难理解分发过程。</p><h2 id="postValue-值更新与通知"><a href="#postValue-值更新与通知" class="headerlink" title="postValue 值更新与通知"></a>postValue 值更新与通知</h2><p>除了<code>setValue</code>之外，LiveData 还提供了异步更新值的方法<code>postValue</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected void postValue(T value) &#123;</span><br><span class="line">    boolean postTask;</span><br><span class="line">    synchronized (mDataLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果 mPendingData 还未被主线程消费，则 postTask 为 fase，</span><br><span class="line">        &#x2F;&#x2F; 不允许重复启动值刷新任务</span><br><span class="line">        postTask &#x3D; mPendingData &#x3D;&#x3D; NOT_SET;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 值会在 mPostValueRunnable 任务中被消费</span><br><span class="line">        mPendingData &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; mPendingData &#x3D;&#x3D; NOT_SET 才允许被触发</span><br><span class="line">    if (!postTask) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 向主线程更新</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final Runnable mPostValueRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Object newValue;</span><br><span class="line">        synchronized (mDataLock) &#123;</span><br><span class="line">            newValue &#x3D; mPendingData;</span><br><span class="line">            &#x2F;&#x2F; 标记mPendingData已经被消费</span><br><span class="line">            mPendingData &#x3D; NOT_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新值</span><br><span class="line">        setValue((T) newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="observeForever"><a href="#observeForever" class="headerlink" title="observeForever"></a>observeForever</h2><p>通常情况下我们使用的值确实是跟随 Activity 、Fragment 生命周期进行更新的。但是在一些特殊情况下，我们需要提前与 <code>STARTED</code> 周期前进行值更新通知，但是受制于<code>LifecycleBoundObserver</code>中对于<code>shouldBeActive</code>的控制，仅允许在<code>STARTED</code>和<code>RESUMED</code>周期中才被允许进行值更新通知。</p><p>考虑到这种情况，LiveData提供了另外的注册方法<code>observerForever</code>，抛弃对生命周期的依赖。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public void observeForever(@NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    &#x2F;&#x2F; 还是需要在主线程中调用</span><br><span class="line">    assertMainThread(&quot;observeForever&quot;);</span><br><span class="line">    AlwaysActiveObserver wrapper &#x3D; new AlwaysActiveObserver(observer);</span><br><span class="line">    ObserverWrapper existing &#x3D; mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    if (existing instanceof LiveData.LifecycleBoundObserver) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                + &quot; with different lifecycles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (existing !&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.activeStateChanged(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的<code>observer</code>中，我们可以知道对于生命周期的控制是由于在<code>observer</code>中创建 的<code>LifecycleBoundObserver</code>。</p><p>在以上代码中，<code>observeForever</code>通过另外的<code>AlwaysActiveObserver</code>进行包装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private class AlwaysActiveObserver extends ObserverWrapper &#123;</span><br><span class="line"></span><br><span class="line">    AlwaysActiveObserver(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        super(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean shouldBeActive() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认将 <code>shouldBeActive</code> 都是返回 true，并且不再实现<code>LifecycleEventObserver</code>接口。这样就实现了不受制激活状态约束。</p><p>尽管实现了目的，但是这种注册方式无法自动注销订阅关系，如果不进行主动解绑<code>removeObserver</code> 则将发生内存泄露。如果必要这么做，需要在希望生命周期结束时自己调用一些移除观察者动作，这可以借助于自己实现 <code>LifecycleEventObserver</code> 接口。</p><h1 id="解除订阅关系"><a href="#解除订阅关系" class="headerlink" title="解除订阅关系"></a>解除订阅关系</h1><p>在之前的源码解析中，<code>LifecycleBoundObserver</code> 实现了对生命周期的监听。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">            @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">        if (mOwner.getLifecycle().getCurrentState() &#x3D;&#x3D; DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对生命周期的回调中 <code>onStateChanged</code> 在发生 DESTROYED 时，主动进行了注销 <code>removeObserver(mObserver)</code></p><h1 id="四、MediatorLiveData"><a href="#四、MediatorLiveData" class="headerlink" title="四、MediatorLiveData"></a>四、MediatorLiveData</h1><p>MedaitorLiveData 可以将多个被观察源 <code>LiveData</code>进行聚合，当注册的 LiveData 发生变化则通知所注册是对应的 <code>Observer</code>，MediatorLiveData 可以同时注册多个不同类型的被观察者和观察者。</p><blockquote><p>注意如果一个被观察者LiveData需要绑定多个观察者Observer，则需要调用多次 addSource</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class MediatorLiveData&lt;T&gt; extends MutableLiveData&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 对于每一个被观察源都有一个对应的 Source 进行该观察源的状态变化跟踪</span><br><span class="line">    private SafeIterableMap&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; mSources &#x3D; new SafeIterableMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public &lt;S&gt; void addSource(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? super S&gt; onChanged) &#123;</span><br><span class="line">        &#x2F;&#x2F; 产生跟随观察者</span><br><span class="line">        Source&lt;S&gt; e &#x3D; new Source&lt;&gt;(source, onChanged);</span><br><span class="line">        Source&lt;?&gt; existing &#x3D; mSources.putIfAbsent(source, e);</span><br><span class="line">        if (existing !&#x3D; null &amp;&amp; existing.mObserver !&#x3D; onChanged) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;This source was already added with the different observer&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (existing !&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hasActiveObservers()) &#123;</span><br><span class="line">            e.plug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private static class Source&lt;V&gt; implements Observer&lt;V&gt; &#123;</span><br><span class="line">        final LiveData&lt;V&gt; mLiveData;</span><br><span class="line">        final Observer&lt;? super V&gt; mObserver;</span><br><span class="line">        int mVersion &#x3D; START_VERSION;</span><br><span class="line"></span><br><span class="line">        Source(LiveData&lt;V&gt; liveData, final Observer&lt;? super V&gt; observer) &#123;</span><br><span class="line">            mLiveData &#x3D; liveData;</span><br><span class="line">            mObserver &#x3D; observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void plug() &#123;</span><br><span class="line">            mLiveData.observeForever(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void unplug() &#123;</span><br><span class="line">            mLiveData.removeObserver(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onChanged(@Nullable V v) &#123;</span><br><span class="line">            &#x2F;&#x2F; 很明显的看出  Souce 即是对 添加进这里的被观察源的观察者代理</span><br><span class="line">            if (mVersion !&#x3D; mLiveData.getVersion()) &#123;</span><br><span class="line">                mVersion &#x3D; mLiveData.getVersion();</span><br><span class="line">                mObserver.onChanged(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于以上的特性，LiveData 提供了一个便捷工具，可以对观察进行便捷转化。</p><h2 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h2><p>在该工具类中，有两个方法 <code>map</code> 和 <code>switchMap</code></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;X, Y&gt; LiveData&lt;Y&gt; map(</span><br><span class="line">          @NonNull LiveData&lt;X&gt; source,</span><br><span class="line">          @NonNull final Function&lt;X, Y&gt; mapFunction) &#123;</span><br><span class="line">      final MediatorLiveData&lt;Y&gt; result &#x3D; new MediatorLiveData&lt;&gt;();</span><br><span class="line">      result.addSource(source, new Observer&lt;X&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onChanged(@Nullable X x) &#123;</span><br><span class="line">              result.setValue(mapFunction.apply(x));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>map 实现了在<code>source</code>发生X类型值变化时，通过<code>mapFunction</code>将被观察的 X 值转化为 Y 值，并将 Y 值通知给观察者<code>Observer</code>的能力 ，和Rx的map 一样。</p><h3 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h3><p>switchMap 比较有用，当<code>source</code> 发生 X 值变化时，将触发 X 值的转化，并同时返回新的被观察者源<code>LiveData&lt;Y&gt;</code>，之前的<code>source</code>将失效不在接收变化通知， 当 <code>LiveData&lt;Y&gt;</code> 再次发生值变化将激活最终的观察者们。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;X, Y&gt; LiveData&lt;Y&gt; switchMap(</span><br><span class="line">            @NonNull LiveData&lt;X&gt; source,</span><br><span class="line">            @NonNull final Function&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction) &#123;</span><br><span class="line">        final MediatorLiveData&lt;Y&gt; result &#x3D; new MediatorLiveData&lt;&gt;();</span><br><span class="line">        result.addSource(source, new Observer&lt;X&gt;() &#123;</span><br><span class="line">            LiveData&lt;Y&gt; mSource;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onChanged(@Nullable X x) &#123;</span><br><span class="line">                LiveData&lt;Y&gt; newLiveData &#x3D; switchMapFunction.apply(x);</span><br><span class="line">                if (mSource &#x3D;&#x3D; newLiveData) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (mSource !&#x3D; null) &#123;</span><br><span class="line">                    result.removeSource(mSource);</span><br><span class="line">                &#125;</span><br><span class="line">                mSource &#x3D; newLiveData;</span><br><span class="line">                if (mSource !&#x3D; null) &#123;</span><br><span class="line">                    result.addSource(mSource, new Observer&lt;Y&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onChanged(@Nullable Y y) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 通知之前预注册到MediatorLiveData 的观察者们，数据发生变更</span><br><span class="line">                            result.setValue(y);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这常用于需要满足某种条件的情况下（即激活<code>source``onChanged</code>）,才进行后续对于 Y 变化的工作，可以提前对Y的工作进行预先设置，等到X变化触发条件才执行。</p><p>比如 当用户登录的时，触发用户钱包相关信息的上报，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用户信息</span><br><span class="line">private fun userInfo &#x3D; MutableLiveData&lt;UserInfo&gt;()</span><br><span class="line"></span><br><span class="line">private fun purseInfo &#x3D; </span><br><span class="line">    Transformations.switchMap(userInfo)&#123;userInfo -&gt;</span><br><span class="line">            val purseInfo &#x3D; MutableLiveData&lt;PurseInfo&gt;() </span><br><span class="line">            &#x2F;&#x2F; 执行用户名到钱包数据的转化</span><br><span class="line">            </span><br><span class="line">            purseInfo &#x3D; realPurseInfo</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 返回被观察者源</span><br><span class="line">            return@switchMap purseInfo</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    purseInfoResult.observe(this, Observer &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理相关钱包数据上报内容之类的</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通过网络耗时请求获得用户信息</span><br><span class="line">    fetchUserInfo() &#123; userInfo -&gt;</span><br><span class="line">        userInfo.value &#x3D; userInfo</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun fetchUserInfo(cb: Callback) &#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，我们提前对 钱包数据进行观察，在获得钱包数据前，需要对用户数据进行请求（耗时），当拉取成功后通知 userInfo 发生数据变化，该变化通知 switchMap 的 switchMapFunction 进行钱包数据的转化，并返回一个代理包装的 LiveData，之后激活之前预先注册观察钱包数据的观察者。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LiveData 算是对 Lifecycle 框架的应用，当LiveData 发生值变化时将对所订阅者进行更新，借助于Lifecycle生命周期的管理，自动对值更新、自动解绑进行了自动管理。&lt;/p&gt;
&lt;h1 id=&quot;一、配置&quot;&gt;&lt;a href=&quot;#一、配置&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Jetpack-Lifecycle</title>
    <link href="http://yoursite.com/2019/02/14/Jetpack-Lifecycle/"/>
    <id>http://yoursite.com/2019/02/14/Jetpack-Lifecycle/</id>
    <published>2019-02-14T15:32:35.000Z</published>
    <updated>2020-04-15T03:14:30.683Z</updated>
    
    <content type="html"><![CDATA[<p>Lifecycle 是 Jetpack 的一套生命周期监控框架，目的是用于对进程、 Activity 和 Fragment 生命周期感知。</p><p>方便开发者在一些开发细节上对生命周期的感知强化，比如防止内存泄露、内存控制、周期性任务等情况，比较出名的方案是 Glide 对于<code>Request</code> 自实现的一套管理方案，目前有了这套官方的支持，就不在需要处理注册通知、以及观察者销毁等事宜。</p><h1 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h1><p>基于androidX项目的Gradle依赖配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def lifecycle_version &#x3D; &quot;2.2.0&quot;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ktx 包是对 androidx.lifecycle:lifecycle-runtime:2.2.0  包kotlin方面的增强，如果不需要kotlin 可以换回该包</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycle_version&quot;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果使用的是java8 ，可以用该扩展包进行接口监听</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    kapt &quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lifecycle-extensions 依赖已经在2.2.0过期不再使用</code></p><ul><li>lifecycle-runtime-ktx 依赖关系</li></ul><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27283/WEBRESOURCE4b53087605cb1000c78ac8d8d259984e"  alt="image.png"></p><p>lifecycle-runtime-ktx 的 maven 依赖关系上，编译时已经包含：</p><ul><li>androidx.lifecycle:lifecycle-runtime:2.2.0</li><li>org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.0 (协程)</li></ul><h1 id="二、基本组成"><a href="#二、基本组成" class="headerlink" title="二、基本组成"></a>二、基本组成</h1><p><code>Lifecycle</code> 主要包括几个主要结构：</p><ul><li><p>LifecycleOwner <code>生命周期被观察者，主要被 AppCompatActivity、Fragment、LifecycleService 等需要被监控的目标类上实现，目前在androidX组件、aac 组件里面基本默认实现</code></p></li><li><p>LifecycleObserver <code>观察者接口，默认空实现，根据所提供的不同生命周期进行不同的接口（目前是Fragment 和 Activity），比如 FullLifecycleObserver 提供了Activity的生命周期监控，目前android主要提供两种观察者 LifecycleEventObserver 和 FullLifecycleObserver,</code></p></li><li><p>Lifecycle <code>提供观察者对被观察者的注册、注销、状态反馈，由 LifecycleOwner 提供</code></p></li><li><p>LifecycleRegistry <code>Lifecycle实现的子类，是观察者注册器，对LifecycleObserver进行注册、注销相关动作</code></p></li></ul><h1 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h1><p>Lifecycle提供了几种基础的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public enum Event &#123;</span><br><span class="line">     &#x2F;&#x2F; 参照 Activity的生命周期</span><br><span class="line">     ON_CREATE,</span><br><span class="line">     ON_START,</span><br><span class="line">     ON_RESUME,</span><br><span class="line">     ON_PAUSE,</span><br><span class="line">     ON_STOP,</span><br><span class="line">     ON_DESTROY,</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 以上任何状态变化都可以被该事件接收</span><br><span class="line">     ON_ANY</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对于与以下流程过程的响应。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27890/WEBRESOURCE70514b68dbae3e0d3b7f34c8a718bb3c"  alt="image.png"></p><h2 id="DefaultLifecycleObserver-形式回调"><a href="#DefaultLifecycleObserver-形式回调" class="headerlink" title="DefaultLifecycleObserver 形式回调"></a>DefaultLifecycleObserver 形式回调</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val presenter by lazy &#123;</span><br><span class="line">        MainPresenter()</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        lifecycle.addObserver(presenter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainPresenter: DefaultLifecycleObserver &#123;</span><br><span class="line">    override fun onCreate(owner: LifecycleOwner) &#123;</span><br><span class="line">        super.onCreate(owner)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>androidX 依赖的 <code>AppCompatActivity</code>、<code>Fragment</code> 默认都实现了 <code>LifecycleOwner</code> 接口，通过<code>getLifecycle</code>获取注册器进行注册。</p><blockquote><p>如果需要全量周期的实现可以替换成接口 FullLifecycleObserver ，DefaultLifecycleObserver 为该类的子类，为了避免不需要实现的方法声明。</p></blockquote><h2 id="OnLifecycleEvent-注解形式回调"><a href="#OnLifecycleEvent-注解形式回调" class="headerlink" title="@OnLifecycleEvent 注解形式回调"></a>@OnLifecycleEvent 注解形式回调</h2><p>对于观察者，还可以通过注解形式实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MainPresenter: LifecycleObserver &#123;</span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span><br><span class="line">    fun onCreate() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    fun onResume() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、原理初析"><a href="#四、原理初析" class="headerlink" title="四、原理初析"></a>四、原理初析</h1><p>Lifecycle 框架是个典型的观察者框架，只是这种模式被官方默认支持。</p><h2 id="注册与包装-Observer"><a href="#注册与包装-Observer" class="headerlink" title="注册与包装 Observer"></a>注册与包装 Observer</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27659/WEBRESOURCE448a5de37537f1150ef966f3527a1412"  alt="image.png"></p><p>整个流程主要集中在 <code>addObserver</code> 方法中，这边具体分析下这流程：</p><ul><li>将观察者构造为 ObserverWithState，并初始化状态（INITIALIZED 或 DESTROYED）</li><li>根据观察者的实现，生成不同的适配器。</li><li>更新新添加观察者的状态，直到和被观察者状态保持 一致。<ul><li>如果添加观察者时，它的状态滞后于被观察者，则会将所有未经过的状态执行一遍，比如当前Activity 状态为 onResume，则观察者会将 onCreate -&gt; onStart -&gt; onResume 都执行一遍。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line">public class LifecycleRegistry extends Lifecycle &#123;</span><br><span class="line">    ...</span><br><span class="line">    public void addObserver(@NonNull LifecycleObserver observer) &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查当前被观察者是否处于 DESTROYED ，如果是先初始化值为 </span><br><span class="line">        &#x2F;&#x2F; DESTROYED 否则 INITIALIZED</span><br><span class="line">        State initialState &#x3D; mState &#x3D;&#x3D; DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">        &#x2F;&#x2F; 初始化观察者包装类，该包装类有观察者对象和当前观察者感知到的状态 </span><br><span class="line">        &#x2F;&#x2F; 值。</span><br><span class="line">        ObserverWithState statefulObserver &#x3D; new ObserverWithState(observer, initialState);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 缓存到索引中</span><br><span class="line">        ObserverWithState previous &#x3D; mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果之前已经添加过则不重新进行后续的初始化</span><br><span class="line">        if (previous !&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 这是个弱引用，如果被观察者销毁了，则会返回null，那么久不进行</span><br><span class="line">        &#x2F;&#x2F; 后续的流程</span><br><span class="line">        LifecycleOwner lifecycleOwner &#x3D; mLifecycleOwner.get();</span><br><span class="line">        if (lifecycleOwner &#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; it is null we should be destroyed. Fallback quickly</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果当前其他的观察者处于状态更新中（sync()执行中）或者</span><br><span class="line">        &#x2F;&#x2F; 当前正在添加的观察者（添加事务还没执行完）不为空，则在完成当前对象添加后重新更新状态(sync())</span><br><span class="line">        boolean isReentrance &#x3D; mAddingObserverCounter !&#x3D; 0 || mHandlingEvent;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获得当前实际被观察者状态</span><br><span class="line">        State targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 标记正在执行添加事务流程的标记位</span><br><span class="line">        mAddingObserverCounter++;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果观察者状态比目标状态低，则将状态一级一级递增，并在递增过程中</span><br><span class="line">        &#x2F;&#x2F; 通知新添加的观察者状态变更</span><br><span class="line">        while ((statefulObserver.mState.compareTo(targetState) &lt; 0</span><br><span class="line">                &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">            pushParentState(statefulObserver.mState);</span><br><span class="line">            statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">            &#x2F;&#x2F; 为了防止更新过程中被观察者状态已经变更，则重新更新目标状态</span><br><span class="line">            targetState &#x3D; calculateTargetState(observer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 更新所有被观察者状态</span><br><span class="line">        if (!isReentrance) &#123;</span><br><span class="line">            &#x2F;&#x2F; we do sync only on the top level.</span><br><span class="line">            sync();</span><br><span class="line">        &#125;</span><br><span class="line">        mAddingObserverCounter--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    private State calculateTargetState(LifecycleObserver observer) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; previous &#x3D; mObserverMap.ceil(observer);</span><br><span class="line"></span><br><span class="line">        State siblingState &#x3D; previous !&#x3D; null ? previous.getValue().mState : null;</span><br><span class="line">        State parentState &#x3D; !mParentStates.isEmpty() ? mParentStates.get(mParentStates.size() - 1)</span><br><span class="line">                : null;</span><br><span class="line">        return min(min(mState, siblingState), parentState);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    static class ObserverWithState &#123;</span><br><span class="line">        State mState;</span><br><span class="line">        LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">        ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">            mLifecycleObserver &#x3D; Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">            mState &#x3D; initialState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void dispatchEvent(LifecycleOwner owner, Event event) &#123;</span><br><span class="line">            State newState &#x3D; getStateAfter(event);</span><br><span class="line">            mState &#x3D; min(mState, newState);</span><br><span class="line">            mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">            mState &#x3D; newState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">public class Lifecycling &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 该方法是根据观察者生成对应的包装装饰器   </span><br><span class="line">    static LifecycleEventObserver lifecycleEventObserver(Object object) &#123;</span><br><span class="line">        boolean isLifecycleEventObserver &#x3D; object instanceof LifecycleEventObserver;</span><br><span class="line">        boolean isFullLifecycleObserver &#x3D; object instanceof FullLifecycleObserver;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; FullLifecycleObserver 及其子类都是用  </span><br><span class="line">        &#x2F;&#x2F; FullLifecycleObserverAdapter 包装</span><br><span class="line">        if (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123;</span><br><span class="line">            return new FullLifecycleObserverAdapter((FullLifecycleObserver) object,</span><br><span class="line">                    (LifecycleEventObserver) object);</span><br><span class="line">        &#125;</span><br><span class="line">        if (isFullLifecycleObserver) &#123;</span><br><span class="line">            return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; LifecycleEventObserver 及其子类</span><br><span class="line">        if (isLifecycleEventObserver) &#123;</span><br><span class="line">            return (LifecycleEventObserver) object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对于不是规范性的观察者，比如 </span><br><span class="line">        &#x2F;&#x2F; OnLifecycleEvent注解、APT生成对象或者 直接实现于 </span><br><span class="line">        &#x2F;&#x2F; LifecycleObserver的观察者</span><br><span class="line">        final Class&lt;?&gt; klass &#x3D; object.getClass();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 进行回调类型的判断，如果回调类型为 GENERATED_CALLBACK </span><br><span class="line">        &#x2F;&#x2F; 需要先构造类实例（回调实例），该方式基本为 APT 提供</span><br><span class="line">        int type &#x3D; getObserverConstructorType(klass);</span><br><span class="line">        </span><br><span class="line">        if (type &#x3D;&#x3D; GENERATED_CALLBACK) &#123;</span><br><span class="line">            List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors &#x3D;</span><br><span class="line">                    sClassToAdapters.get(klass);</span><br><span class="line">                    </span><br><span class="line">            &#x2F;&#x2F; 只有一个构造则用 SingleGeneratedAdapterObserver        </span><br><span class="line">            if (constructors.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                GeneratedAdapter generatedAdapter &#x3D; createGeneratedAdapter(</span><br><span class="line">                        constructors.get(0), object);</span><br><span class="line">                return new SingleGeneratedAdapterObserver(generatedAdapter);</span><br><span class="line">            &#125;</span><br><span class="line">            GeneratedAdapter[] adapters &#x3D; new GeneratedAdapter[constructors.size()];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">                adapters[i] &#x3D; createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 多构造用 CompositeGeneratedAdaptersObserver 包装</span><br><span class="line">            return new CompositeGeneratedAdaptersObserver(adapters);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 可以支持反射</span><br><span class="line">        return new ReflectiveGenericLifecycleObserver(object);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    private static int getObserverConstructorType(Class&lt;?&gt; klass) &#123;</span><br><span class="line">        &#x2F;&#x2F; 先从缓存里面获取CallbackType，没有在进行解析</span><br><span class="line">        Integer callbackCache &#x3D; sCallbackCache.get(klass);</span><br><span class="line">        if (callbackCache !&#x3D; null) &#123;</span><br><span class="line">            return callbackCache;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 解析每个观察者类的回调形式（反射、构造调用）</span><br><span class="line">        int type &#x3D; resolveObserverCallbackType(klass);</span><br><span class="line">        sCallbackCache.put(klass, type);</span><br><span class="line">        return type;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 解析目标类对观察者类</span><br><span class="line">    private static int resolveObserverCallbackType(Class&lt;?&gt; klass) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否是反射类型</span><br><span class="line">        if (klass.getCanonicalName() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return REFLECTIVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果是由APT &quot;androidx.lifecycle:lifecycle-compiler:2.2.0&quot;</span><br><span class="line">        &#x2F;&#x2F; 自动生成的xxx_LifecycleAdapter的类，xxx为kclass类名，则根据规范生</span><br><span class="line">        &#x2F;&#x2F; 成构造器信息，并存到sClassToAdapters 备用</span><br><span class="line">        Constructor&lt;? extends GeneratedAdapter&gt; constructor &#x3D; generatedConstructor(klass);</span><br><span class="line">        if (constructor !&#x3D; null) &#123;</span><br><span class="line">            sClassToAdapters.put(klass, Collections</span><br><span class="line">                    .&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt;singletonList(constructor));</span><br><span class="line">            return GENERATED_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果没有使用APT生成对应的LifecycleAdapter类（没引入apt依赖的情况 </span><br><span class="line">        &#x2F;&#x2F; ），但是还是使用了 OnLifecycleEvent</span><br><span class="line">        &#x2F;&#x2F; 注解标记的方法，则通过反射实现调用</span><br><span class="line">        boolean hasLifecycleMethods &#x3D; ClassesInfoCache.sInstance.hasLifecycleMethods(klass);</span><br><span class="line">        if (hasLifecycleMethods) &#123;</span><br><span class="line">            return REFLECTIVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; superclass &#x3D; klass.getSuperclass();</span><br><span class="line">        List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; adapterConstructors &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 判断是否为继承自 LifecycleObserver 的子类的子类</span><br><span class="line">        if (isLifecycleParent(superclass)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 检测下父类的调用类型（递归），如果支持反射调用直接返回，否则</span><br><span class="line">            &#x2F;&#x2F; 获得构造器反射信息，并缓存</span><br><span class="line">            if (getObserverConstructorType(superclass) &#x3D;&#x3D; REFLECTIVE_CALLBACK) &#123;</span><br><span class="line">                return REFLECTIVE_CALLBACK;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 不支持反射则需要提前获得构造器反射信息（在之前的</span><br><span class="line">            &#x2F;&#x2F; getObserverConstructorType 里面已经对superclass</span><br><span class="line">            &#x2F;&#x2F; 进行构造器信息进行打包</span><br><span class="line">            adapterConstructors &#x3D; new ArrayList&lt;&gt;(sClassToAdapters.get(superclass));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 解析接口信息，如果有支持反射的则使用该反射类型信息，否则</span><br><span class="line">        &#x2F;&#x2F; 还是提前低构造器反射信息进行缓存</span><br><span class="line">        for (Class&lt;?&gt; intrface : klass.getInterfaces()) &#123;</span><br><span class="line">            if (!isLifecycleParent(intrface)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 为多接口的类，再次进行匹配可以进行调动的方式</span><br><span class="line">            if (getObserverConstructorType(intrface) &#x3D;&#x3D; REFLECTIVE_CALLBACK) &#123;</span><br><span class="line">                return REFLECTIVE_CALLBACK;</span><br><span class="line">            &#125;</span><br><span class="line">            if (adapterConstructors &#x3D;&#x3D; null) &#123;</span><br><span class="line">                adapterConstructors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 将 GENERATED_CALLBACK 回调类型的类型构造器反射信息</span><br><span class="line">            &#x2F;&#x2F; 打包进 adapterConstructors 集合中</span><br><span class="line">            adapterConstructors.addAll(sClassToAdapters.get(intrface));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 到这里可以确定该类的回调类型为 GENERATED_CALLBACK，必须先构造类</span><br><span class="line">        &#x2F;&#x2F; 才能使用所构造的类进行回调，将这个类的构造器信息集合缓存到</span><br><span class="line">        &#x2F;&#x2F; sClassToAdapters 构造器池中。</span><br><span class="line">        if (adapterConstructors !&#x3D; null) &#123;</span><br><span class="line">            sClassToAdapters.put(klass, adapterConstructors);</span><br><span class="line">            return GENERATED_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return REFLECTIVE_CALLBACK;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调适配"><a href="#回调适配" class="headerlink" title="回调适配"></a>回调适配</h2><p>Lifecycle 提供了丰富的回调形式，为此为了适应这种回调，会对观察者进行再一层适配器的封装：</p><ul><li><p>FullLifecycleObserverAdapter <code>如果观察者为 FullLifecycleObserver 则使用该适配器包装</code></p></li><li><p>SingleGeneratedAdapterObserver <code>针对APT生成的GenerateAdpater进行包装</code></p></li><li><p>CompositeGeneratedAdaptersObserver <code>针对APT生成的GenerateAdpater，如果观察者存在继承及其多实现满足回调情况，则通过通过该复合适配器包装</code></p></li><li><p>ReflectiveGenericLifecycleObserver <code>对于不适用APT的OnLifecycleEvent注解目标类，则使用反射处理</code></p></li></ul><p>具体解析参照 <code>原理初析</code> 中对 <code>lifecycleEventObserver</code> 方法的解析。</p><h1 id="五、相关传送门"><a href="#五、相关传送门" class="headerlink" title="五、相关传送门"></a>五、相关传送门</h1><p><a href="https://android.googlesource.com/platform/frameworks/support/+/androidx-master-dev" target="_blank" rel="noopener">AndroidX Google Git 项目地址</a></p><p><a href="https://developer.android.google.cn/jetpack/androidx/releases/lifecycle?hl=it" target="_blank" rel="noopener">Android Life 版本更新日志</a></p><p><a href="https://developer.android.google.cn/jetpack/docs/getting-started?hl=zh_cn" target="_blank" rel="noopener">Jetpack Google文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Lifecycle 是 Jetpack 的一套生命周期监控框架，目的是用于对进程、 Activity 和 Fragment 生命周期感知。&lt;/p&gt;
&lt;p&gt;方便开发者在一些开发细节上对生命周期的感知强化，比如防止内存泄露、内存控制、周期性任务等情况，比较出名的方案是 Glid
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Jetpack" scheme="http://yoursite.com/tags/Jetpack/"/>
    
  </entry>
  
  <entry>
    <title>Android源码编译和阅读</title>
    <link href="http://yoursite.com/2019/01/13/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2019/01/13/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%98%85%E8%AF%BB/</id>
    <published>2019-01-13T14:05:39.000Z</published>
    <updated>2020-04-13T14:07:30.131Z</updated>
    
    <content type="html"><![CDATA[<p>这几天花了点时间将Android源码 repo 下来，准备巩固下Android全体流程，简单记录下调试环境监理的过程。</p><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><p>在下载的源码项目下，直接可以执行 </p><p><code>source build/envsetup.sh</code></p><p>进行安装前的环境初始化。</p><p>这里注意，如果尝试在非 bash 环境初始化，会抛出一个警告。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26698/WEBRESOURCEffb85d0ab1a91830bb5209f1690c0c9e"  alt="image.png"></p><p>尽管不是异常，不过还是安全起见，切换到bash下去执行。</p><h1 id="编译类型"><a href="#编译类型" class="headerlink" title="编译类型"></a>编译类型</h1><p>执行 <code>lunch</code> 启动目录，Android 提供了几种编译选项：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26716/WEBRESOURCEef95c669a446ff30005d5500da96405f"  alt="image.png"></p><p>根据名字规则 <code>${BUILD}_${BUILD_TYPE}</code>，例如 <code>aosp_arm-eng</code>，BUILD = aosp_arm 而 BUILD_TYPE = eng</p><p>这里主要关注 BUILD_TYPE ：</p><ul><li>eng <code>有额外调试工具配置</code></li><li>user <code>适用于生产环境的版本，对系统的权限有一定约束</code></li><li>userdebug <code>和 user 类似，但是权限上处于root，并且可以进行调试</code></li></ul><p>这里因为我是电脑模拟器执行，因此使用 <code>x86</code> 的aosp版本就行。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26741/WEBRESOURCEb43ac574907067624d128a7487384e9d"  alt="image.png"></p><h1 id="编译idegen调试模块与问题"><a href="#编译idegen调试模块与问题" class="headerlink" title="编译idegen调试模块与问题"></a>编译idegen调试模块与问题</h1><p>开始执行项目编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make idegen</span><br></pre></td></tr></table></figure><p>直到出现</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26789/WEBRESOURCE9d1213f87038081b289b4aaff8bcaf5b"  alt="image.png"></p><p>成功标记即可。</p><p><code>make idegen</code> 生成 <code>idegen.jar</code> 后，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo development&#x2F;tools&#x2F;idegen&#x2F;idegen.sh</span><br></pre></td></tr></table></figure><p>开始漫长的执行等待，直到通知</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26812/WEBRESOURCEf42faa5a9598bc80d99e344d79cb1574"  alt="image.png"></p><p>完成以上所有动作后，会在源码根目录生成三个文件：</p><ul><li><p>android.iml (记录项目所包含的module、依赖关系、SDK版本等等，类似一个XML文件)</p></li><li><p>android.ipr (工程的具体配置，代码以及依赖的lib等信息，使用Android Studio 直接导入该文件)</p></li><li><p>android.iws (主要包含一些个人的配置信息，也有可能在执行上述操作后没有生成，这个没关系，在打开过一次项目之后就会自动生成了)</p></li></ul><p>调整文件读取权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 android.iml</span><br><span class="line">sudo chmod 777 android.ipr</span><br></pre></td></tr></table></figure><p>完成后使用<code>Android Stuido</code> 导入已有项目导入 <code>android.ipr</code> ，由于项目非常大，这里等待会久一点，完成后就可以放飞自我了。</p><h2 id="过程中的问题"><a href="#过程中的问题" class="headerlink" title="过程中的问题"></a>过程中的问题</h2><p>下面记录几个在编译过程中出现了几个问题的解决方法，仅代表我编译环境问题，不同的编译环境可能会产生不同的问题。</p><h3 id="Mac-OS-分区大小写问题"><a href="#Mac-OS-分区大小写问题" class="headerlink" title="Mac OS 分区大小写问题"></a>Mac OS 分区大小写问题</h3><p>由于我当前的 Mac 分区是不区分大小写的分区模式，因此抛出了异常。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26749/WEBRESOURCE4f40f94cceff916960e2cd8b994eb2a7"  alt="image.png"></p><p>这里只需要重新对盘继续分割，并将格式化类型设置为对大小写敏感即可。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26747/WEBRESOURCEf38106d537e15f03c5d5c21d1ba39526"  alt="image.png"></p><p>分区完成后，迁移代码到这里面编译即可</p><h3 id="Mac-SDK-支持问题"><a href="#Mac-SDK-支持问题" class="headerlink" title="Mac SDK 支持问题"></a>Mac SDK 支持问题</h3><p>由于我Mac版本是比较高的，而Android构建支持的版本较小[10.10、10.11、10.12]。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26771/WEBRESOURCE2c2301660cc3aae55c712cb96a396221"  alt="image.png"></p><p>解决方法是去下载以前老的Mac sdk版本，下载可以到<a href="https://github.com/phracker/MacOSX-SDKs" target="_blank" rel="noopener">这里</a>，下载完成后解压到 <code>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</code> 目录下，重新执行编译即可。</p><h3 id="Android-Studio-导入太慢"><a href="#Android-Studio-导入太慢" class="headerlink" title="Android Studio 导入太慢"></a>Android Studio 导入太慢</h3><p>由于项目非常大，因此这里会非常非常久，如果不希望这么慢，可以参考通过修改<code>android.iml</code>文件，在里面添加 <code>&lt;excludeFolder&gt;</code> 配置，剔除不需要同步的模块，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;excludeFloder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;项目名&quot;&gt;</span><br></pre></td></tr></table></figure><p>比如 不需要 <code>build</code> 下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;excludeFolder url&#x3D;&quot;file:&#x2F;&#x2F;$MODULE_DIR$&#x2F;build&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><h1 id="Android-Studio-导入源码"><a href="#Android-Studio-导入源码" class="headerlink" title="Android Studio 导入源码"></a>Android Studio 导入源码</h1><p>导入源码成功后，需要对Android Studio 进行一些配置调整。</p><p>因为我只对项目里面 <code>framework</code> 项目感兴趣，我这个以这个为例子。</p><h2 id="设置目标SDK版本"><a href="#设置目标SDK版本" class="headerlink" title="设置目标SDK版本"></a>设置目标SDK版本</h2><ol><li>进入项目设置 <code>Project Structure</code></li></ol><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26867/WEBRESOURCE22d80acfc60c2b9c3011dca3f08bce5d"  alt="image.png"></p><ol start="2"><li>选择 <code>Project</code> -&gt; 设置 SDK，因为我下载的项目是 Android 8.1 的源码，因此我这使用 API 27<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26876/WEBRESOURCE361fac66cb91d781c30f391eada394df"  alt="image.png"></li></ol><p>如果在这里面没有找到自己想要的 Android SDK 版本，可以通过 <code>Android Studio 菜单</code> -&gt; <code>Preferences</code> -&gt; <code>Android SDK</code></p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26884/WEBRESOURCE574b9031dfd54f14c9cd0e88033feb29"  alt="image.png"></p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26886/WEBRESOURCE4c73a68f7e616b2400509c8b0aa12bfd"  alt="image.png"></p><h2 id="设置项目范围和依赖"><a href="#设置项目范围和依赖" class="headerlink" title="设置项目范围和依赖"></a>设置项目范围和依赖</h2><ol><li>在之前的 <code>Project Structure</code> 下，选择<code>Modules</code> -&gt; <code>android</code> -&gt; <code>Sources</code><br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26872/WEBRESOURCEa2ec2acb4337f19ad85c194b5e739ee8"  alt="image.png"></li></ol><p>在 <code>Sources</code> 中罗列了所有的项目，对于加入管理的项目为 蓝色，被剔除的显示为黄色，具体可以参照 Mark as 的样式, 这里在不关心的项目上，<code>右键 -&gt; 菜单 -&gt; Excluded</code>，剔除对该项目进行管理。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26908/WEBRESOURCEe353f52b530a1d5bf8a85887e0284eac"  alt="image.png"></p><ol start="2"><li>切换到 <code>Dependencies</code> 下，移除其他依赖，仅保留自己需要的依赖。</li></ol><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26928/WEBRESOURCEededb7e6d6243cf0c025c9ff08d4d943"  alt="image.png"></p><p>这里因为要调试 <code>frameworks</code> 所以将 <code>Android SDK</code>、<code>frameworks</code>、<code>external</code> 加入依赖。</p><h2 id="添加SDK支持"><a href="#添加SDK支持" class="headerlink" title="添加SDK支持"></a>添加SDK支持</h2><p>进入 <code>SDKs</code> 项目，添加好所需要的 JDK 和 Android SDK 对应的编译版本。<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26947/WEBRESOURCEecc4e70e0ee03b65c5a77ed0ed9a0ab5"  alt="image.png"></p><p>完成以上动作后，在<code>framework</code>项目下的所有内容不在显示为红色未识别的标记</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/26958/WEBRESOURCEba6557de16f22b621f1b79c08da9c2de"  alt="image.png"></p><h1 id="编译模拟器"><a href="#编译模拟器" class="headerlink" title="编译模拟器"></a>编译模拟器</h1><p>IDE 自带的模拟不具备编译的条件，我们需要重新自己编译一个。</p><p>根据之前 <code>编译idegen调试模块</code> ，为了方便编译，我这边选择 <code>aosp_x86_64_eng</code>。</p><p>之后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j6 # -jx x指的是参与编译的cpu核心数</span><br></pre></td></tr></table></figure><p>完成编译后可以执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emulator</span><br></pre></td></tr></table></figure><p>执行模拟器</p><h1 id="调试连接"><a href="#调试连接" class="headerlink" title="调试连接"></a>调试连接</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天花了点时间将Android源码 repo 下来，准备巩固下Android全体流程，简单记录下调试环境监理的过程。&lt;/p&gt;
&lt;h1 id=&quot;环境部署&quot;&gt;&lt;a href=&quot;#环境部署&quot; class=&quot;headerlink&quot; title=&quot;环境部署&quot;&gt;&lt;/a&gt;环境部署&lt;/h
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>WMRouter 美团路由简析</title>
    <link href="http://yoursite.com/2018/09/27/WMRouter%20%E7%BE%8E%E5%9B%A2%E8%B7%AF%E7%94%B1%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/27/WMRouter%20%E7%BE%8E%E5%9B%A2%E8%B7%AF%E7%94%B1%E7%AE%80%E6%9E%90/</id>
    <published>2018-09-27T07:40:12.000Z</published>
    <updated>2020-04-28T07:41:33.685Z</updated>
    
    <content type="html"><![CDATA[<p>美团发布了一款路由框架，出于对美团品质的看好，拿来研究下，发现框架精简，架构简单易懂，容易扩展。顺便写下研究心得。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在模块化项目中，为了降低耦合性，通常将各个不相干的功能进行模块代码访问屏蔽，降低直接的引用依赖性。</p><p>这有效的降低代码复杂性，提供内敛程度的同时，也带来一些功能联系的调用复杂度度。</p><p>我们在一些特殊情况下需要进行跨模块功能的调用，这需要到用到类RPC能力，通过路由管理中心实现中间调用。</p><h2 id="WMRouter的功能"><a href="#WMRouter的功能" class="headerlink" title="WMRouter的功能"></a>WMRouter的功能</h2><p>在美团路由中提供了几种基础和扩展性功能：</p><ol><li>页面路由功能，基础必备和阿里路由一样，但是提供了更多的坐标描述方式。</li><li>方法调用，是直接代理了方法调用入口（这个比较喜欢，相比其他路由的来说，路由目标可以代理了方法【虽然实现还是要以类/接口为基础】，而不是一个类）</li><li>获取Class 实例 （还是类目标）</li><li>无参构造或者工厂构造、单例获取（还是类目标，只是多了自动实例化）</li></ol><p>综合路由的功能，主要以“坐标”+“坐标地图工具”为主，在辅以对获取到的“坐标内容”的功能处理的扩展。</p><p>“坐标信息”主要就是注解工具，通常为了描述目标物的解耦信息，会通过注解对该目标进行“坐标信息”的描述。</p><p>比如WMRouter中提供的<code>@RouterPage</code>,<code>@RouterUri</code>、<code>@RouterRegex</code>、<code>@RouterServer</code>注解，可用于描述不同场景需求下的描述需求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 坐标信息 &#x2F;main</span><br><span class="line">@RouterUri(path &#x3D; &quot;&#x2F;main&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 坐标目标内容</span><br><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过“坐标地图工具”进行坐标定位，获得目标内容信息后执行对应的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router.startUri(&quot;&#x2F;main&quot;);</span><br></pre></td></tr></table></figure><p>这里执行后将跳转到 <code>MainActivity</code> 页面。这里的目标内容，指的就是跳转页面的功能，区别在于跳转页面的描述信息属于“坐标信息”所提供的。</p><p>这里不对具体的路由使用做太多描述，可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;meituan&#x2F;WMRouter?utm_source&#x3D;gold_browser_extension</span><br></pre></td></tr></table></figure><p>获得这些基础内容。</p><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><p>框架的实现主要涉及三个构建时机：</p><ol><li>构建前：源码工作区提供的工具支持，负责对目标的“坐标”描述和路由功能的支持</li><li>APT构建流程：通过APT工具，对“坐标信息”进行各个模块下的采集注册，在各个模块下生成注册器类，并将注册类信息注册到 META-INFO 中（SPI)</li><li>AAPT构建 ：通过Gradle Android Plugin 提供的 Transform 入口，读取各个模块下产生的注册类信息，通过ASM工具生成一个调用<code>ServiceLoder.put</code>的注册类 <code>ServiceLoaderInit</code> 进行代码静态注册，转移文本注册内容。</li></ol><p>完成3操作后，其实1步骤中，可通过调用 <code>ServiceLoaderInit.init()</code>将多个模块下的坐标注册信息和目标物信息注册到 <code>ServiceLoader</code>的 map 中，解决跨模块问题中的路由信息的来源问题。</p><p>几个模块的切入示意图：<br><img src="/" class="lazyload" data-src="https://note.youdao.com/yws/api/personal/file/WEBb6801e50aa24a0f8edbdb20eb2a02c55?method=download&shareKey=22944f5f8a5a1ecb9132a0f49efe48b5"  alt="构造流程示意图"></p><ol><li>坐标标注工具  – <code>interface</code>  </li><li>坐标内容获取工具（加工）  –  <code>router</code></li><li>坐标注册工具  –  <code>compiler</code>、<code>plugin</code></li></ol><p>以下对几个操作进行代码结合查看：</p><h3 id="APT-处理"><a href="#APT-处理" class="headerlink" title="APT 处理"></a>APT 处理</h3><p>APT 对于注解有两类处理，一种是通用于 <code>Activity</code>、<code>UriHandler</code>的针对性注解<code>@RouterPage</code>、<code>@RouterUri</code>、<code>@RouterRgex</code> 。<br>对于这些有两层处理：</p><ol><li>生成对应的 <code>XXXInit</code>接口注册实现类，例如<code>RouterUri</code>，Processor需要将该模块下标记该坐标的目标物进行信息采集，并生成注册类，该类继承 <code>IUriAnnotationInit</code>实现子类（类名会附加上Hash值）,同样的方式对其他两个两个注解处理。</li></ol><ol start="2"><li>处理完成对应的<code>Init</code>子类后，对应多模块下的该类的实现并未达到统一，还需要将多个模块的产物进行统一。在这里APT受限于它的作用域范围，没办法执行跨模块的整理，因此作者采用SPI的概念，将该子类信息注册到<code>META-INFO</code>下，将统一操作延迟到 <code>Transform</code>下处理。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class UriAnnotationProcessor extends BaseProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env) &#123;</span><br><span class="line">        if (annotations &#x3D;&#x3D; null || annotations.isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        CodeBlock.Builder builder &#x3D; CodeBlock.builder();</span><br><span class="line">        String hash &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 产生 IUriAnnotationInit 注册方法&#96;void init(UriAnnotationHandler handler)的实现</span><br><span class="line">        for (Element element : env.getElementsAnnotatedWith(RouterUri.class)) &#123;</span><br><span class="line">            if (!(element instanceof Symbol.ClassSymbol)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            boolean isActivity &#x3D; isActivity(element);</span><br><span class="line">            boolean isHandler &#x3D; isHandler(element);</span><br><span class="line">            if (!isActivity &amp;&amp; !isHandler) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Symbol.ClassSymbol cls &#x3D; (Symbol.ClassSymbol) element;</span><br><span class="line">            RouterUri uri &#x3D; cls.getAnnotation(RouterUri.class);</span><br><span class="line">            if (uri &#x3D;&#x3D; null) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (hash &#x3D;&#x3D; null) &#123;</span><br><span class="line">                hash &#x3D; hash(cls.className());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CodeBlock handler &#x3D; buildHandler(isActivity, cls);</span><br><span class="line">            CodeBlock interceptors &#x3D; buildInterceptors(getInterceptors(uri));</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; scheme, host, path, handler, exported, interceptors</span><br><span class="line">            String[] pathList &#x3D; uri.path();</span><br><span class="line">            for (String path : pathList) &#123;</span><br><span class="line">                builder.addStatement(&quot;handler.register($S, $S, $S, $L, $L$L)&quot;,</span><br><span class="line">                        uri.scheme(),</span><br><span class="line">                        uri.host(),</span><br><span class="line">                        path,</span><br><span class="line">                        handler,</span><br><span class="line">                        uri.exported(),</span><br><span class="line">                        interceptors);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 产生注册类并将注册类信息写入到 META-INFO 中</span><br><span class="line">        writeHandlerInitClass(builder.build(), hash, Const.SCHEME_CLASS,</span><br><span class="line">                Const.URI_ANNOTATION_HANDLER_CLASS, Const.URI_ANNOTATION_INIT_CLASS);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public void writeHandlerInitClass(CodeBlock code, String hash,</span><br><span class="line">           String genClassName, String handlerClassName, String interfaceName) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           genClassName +&#x3D; Const.SPLITTER + hash;</span><br><span class="line">           MethodSpec methodSpec &#x3D; MethodSpec.methodBuilder(Const.INIT_METHOD)</span><br><span class="line">                   .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                   .returns(TypeName.VOID)</span><br><span class="line">                   .addParameter(TypeName.get(typeMirror(handlerClassName)), &quot;handler&quot;)</span><br><span class="line">                   .addCode(code)</span><br><span class="line">                   .build();</span><br><span class="line">           TypeSpec typeSpec &#x3D; TypeSpec.classBuilder(genClassName)</span><br><span class="line">                   .addSuperinterface(TypeName.get(typeMirror(interfaceName)))</span><br><span class="line">                   .addModifiers(Modifier.PUBLIC)</span><br><span class="line">                   .addMethod(methodSpec)</span><br><span class="line">                   .build();</span><br><span class="line">           &#x2F;&#x2F; 产生注册Java文件        </span><br><span class="line">           JavaFile.builder(Const.GEN_PKG, typeSpec)</span><br><span class="line">                   .build()</span><br><span class="line">                   .writeTo(filer);</span><br><span class="line">           String fullImplName &#x3D; Const.GEN_PKG + Const.DOT + genClassName;</span><br><span class="line">           String config &#x3D; new ServiceImpl(null, fullImplName, false).toConfig();</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 注册类信息写入 META-INFO</span><br><span class="line">           writeInterfaceServiceFile(interfaceName, Collections.singletonList(config));</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Gradle处理"><a href="#Gradle处理" class="headerlink" title="Gradle处理"></a>Gradle处理</h3><p>在 Plugin 中主要处理几个工作:</p><ol><li><p>获取<code>transformResourcesWithMergeJavaResFor + 变体名</code>任务资源内容聚合后的产出路径（确保主项目注册信息文件也能获取到），获取这些路径下之前SPI产生的注册信息文件，解析注册类信息并缓存，等待Transform处理。</p></li><li><p>在Transform阶段通过ASM产生字节码，静态（文本信息转字节码）注册这些注册类。</p></li><li><p><code>transformClassesAndResourcesWithProguardFor + 变体</code>混淆优化执行前，进行该项目一些防混淆内容的处理。</p></li></ol><h4 id="关于-Transform"><a href="#关于-Transform" class="headerlink" title="关于 Transform"></a>关于 Transform</h4><p>Transform API的好处的作用域广，可以实现对所有模块（跨模块）、第三方依赖代码的读写操作，坏处就是操作的代码阶段是Class时期，它属于编译后的Class字节码和Class字节码指令（我更愿意去理解smail指令，但是Dex并不提供切入，另外也没有合适的生成工具）。</p><p>依靠这个特性，在该阶段，作者通过读取项目和子项目下的注册信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class WMRouterTransform extends Transform &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        &#x2F;&#x2F; 只需要关注 JAR 内容即可，因为之前的注册信息是被写到每个模块编译内容下的META-INFO中，在JAR中体现在这个目录下</span><br><span class="line">        return TransformManager.CONTENT_JARS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        &#x2F;&#x2F; 只需要关注整个模块产出物即可，第三方依赖都不需要</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Handler和Interceptor"><a href="#Handler和Interceptor" class="headerlink" title="Handler和Interceptor"></a>Handler和Interceptor</h3><p>在路由工具上，基本可以分为两个功能体系的功能。</p><ol><li>页面路由</li><li>功能路由</li></ol><p>对于页面、UriHandler的目标内容，可以通过<code>Router.startUri</code>或者<code>UriRequest</code>进行功能调用，该功能的实现路径是基于<code>Handler</code>、<code>Interceptor</code>上所搭建。<br>具体流程可以参照：</p><p><img src="/" class="lazyload" data-src="https://note.youdao.com/yws/api/personal/file/WEBe97def29270cfc4e6400237f8219fd6e?method=download&shareKey=0f4bd644375309ae61c4d2568009c5f3"  alt="image"></p><p><code>注意：该图只是罗列主要流程，并不表示全部流程</code></p><p>WMRouter实现了比较多的<code>Handler</code>类型，每个<code>Handler</code>负责的职能都不大一样。</p><table><thead><tr><th>Handler名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>RootUriHandler</td><td>顶层Handler，负责注册，转发Handler，全局监听</td><td>DefaultRootUriHandler 为默认实现</td></tr><tr><td>PathHandler</td><td>路径处理类，负责注册、转发各个子路径Handler</td><td></td></tr><tr><td>PageAnnotationHandler</td><td>默认 RouterPage的处理入口</td><td></td></tr><tr><td>UriAnnotationHandler</td><td>Scheme + Host 处理类，负责注册对多个 Scheme + Host PathHandler处理类的注册、转发</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;美团发布了一款路由框架，出于对美团品质的看好，拿来研究下，发现框架精简，架构简单易懂，容易扩展。顺便写下研究心得。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在模块化项
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="路由" scheme="http://yoursite.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>BuildVariants认识</title>
    <link href="http://yoursite.com/2018/06/16/BuildVariants%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2018/06/16/BuildVariants%E8%AE%A4%E8%AF%86/</id>
    <published>2018-06-16T12:45:22.000Z</published>
    <updated>2020-04-10T12:47:45.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>构建变体(Build Variants)有两部分内容构成 :</p><p><code>buildTypes</code>（构建类型） + <code>productFlavors</code>（产品风味）</p><p>通过 <code>android { }</code> 配置变量进行部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    defaultConfig &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        flavorDimensions &quot;api&quot;,&quot;flavor&quot;</span><br><span class="line">        flavor1 &#123;</span><br><span class="line">            dimension &quot;flavor&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flavor2 &#123;</span><br><span class="line">            dimension &quot;flavor&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        api1 &#123;</span><br><span class="line">            dimension &quot;api&quot;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        api2 &#123;</span><br><span class="line">            dimension &quot;api&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h2><p>在一般情况下，项目创建时，项目默认创建了两种构建类型 <code>debug</code> 和 <code>release</code>。</p><p><code>debug</code>是在项目调试阶段的构建类型，而<code>release</code>则是面向发布。</p><p>这两个构建类型方便开发者对两种不同环境进行不同的构建配置。</p><p>比如签名信息、so支持类型、debug信息等。</p><h3 id="buildTypes-DSL"><a href="#buildTypes-DSL" class="headerlink" title="buildTypes DSL"></a>buildTypes DSL</h3><table><thead><tr><th>属性/方法</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>applicationIdSuffix</td><td>为计算后的 applicationId 添加该属性指定的后缀</td><td></td></tr><tr><td>consumerProguardFiles</td><td>将混淆规则文件添加到构建好的AAR中</td><td></td></tr><tr><td>crunchPngs</td><td>是否压缩PNG文件</td><td></td></tr><tr><td>debuggable</td><td>是否生成一个可调试的APk文件</td><td></td></tr><tr><td>embedMicroApp</td><td></td><td></td></tr><tr><td>javaCompileOptions</td><td>可以添加Java编译参数</td><td></td></tr><tr><td>jniDebuggable</td><td>是否生成一个可调试Native的APK文件</td><td></td></tr><tr><td>manifestPlaceholders</td><td>manifest文件占位符配置</td><td></td></tr><tr><td>matchingFallbacks</td><td>指定构建匹配失败时降级的构建类型</td><td></td></tr><tr><td>minifyEnabled</td><td>是否移除无用的代码</td><td></td></tr><tr><td>multiDexEnabled</td><td>Multi-Dex 是否支持</td><td></td></tr><tr><td>multiDexKeepFile</td><td>指定在需要主Dex File 存在的内容的声名文件</td><td></td></tr><tr><td>multiDexKeepProguard</td><td>指定一个文件，用于在编译时对主Dex classes 的额外混淆规则</td><td></td></tr><tr><td>name</td><td>当前构建类型的名字</td><td></td></tr><tr><td>postprocessing</td><td></td><td></td></tr><tr><td>proguardFiles</td><td>指定混淆规则文件</td><td></td></tr><tr><td>pseudoLocalesEnabled</td><td>是否生成仿冒资源，通过 resValue 生成</td><td></td></tr><tr><td>renderscriptDebuggable</td><td>生成一个用于调试 RenderScript 代码的apk</td><td></td></tr><tr><td>renderscriptOptimLevel</td><td>指定 RenderScript的编译优化等级</td><td></td></tr><tr><td>shrinkResources</td><td>是否优化未使用的资源</td><td></td></tr><tr><td>signingConfig</td><td>签名定义</td><td></td></tr><tr><td>testCoverageEnabled</td><td>是否启动覆盖测试</td><td></td></tr><tr><td>useProguard</td><td>是否总是启动代码混淆和资源优化</td><td></td></tr><tr><td>versionNameSuffix</td><td>添加版本后缀</td><td></td></tr><tr><td>zipAlignEnabled</td><td>是否启动zip对其</td><td></td></tr><tr><td>buildConfigField(type, name, value)</td><td>添加一个字段到 BuildConfig Class文件中</td><td></td></tr><tr><td>consumerProguardFile(proguardFile)</td><td>添加一个需要打包进AAR的混淆文件</td><td></td></tr><tr><td>consumerProguardFiles(proguardFiles)</td><td>添加些需要打包进AAR的混淆文件</td><td></td></tr><tr><td>externalNativeBuild(action)</td><td>定义native构建参数</td><td></td></tr><tr><td>initWith(that)</td><td>复制指定build type的所有属性信息</td><td></td></tr><tr><td>proguardFile(proguardFile)</td><td>添加一个混淆定义文件</td><td></td></tr><tr><td>proguardFiles(files)</td><td>添加混淆定义文件</td><td></td></tr><tr><td>resValue(type, name, value)</td><td>添加一个资源信息</td><td></td></tr><tr><td>setProguardFiles(proguardFileIterable)</td><td>设置混淆定义文件</td><td></td></tr></tbody></table><p>仅仅对<code>buildTypes</code>的配置并不能满足我们差异化构建的要求，因此插件中为我们提供了另外的构建配置 <code>productFlavors</code>。</p><h2 id="productFlavors"><a href="#productFlavors" class="headerlink" title="productFlavors"></a>productFlavors</h2><p>productFlavors 和 defaultConfig 同属于 <code>ProductFlavor</code>类。两者的配置内容基本没什么差异，但是在不同变体的构造任务中，对应的变体配置将覆盖默认配置内容。</p><p>productFlavors 需要通过 <code>flavorDimensions</code> 创建“模式”名，以用来对 多个flavor进行组织分组。</p><p>在上面的 <code>productFlavors {...}</code> 例子中，我们声名了两组模式的<code>productFlavor</code>，<code>api</code>和<code>flavor</code>，同时每个模式下，都有两个flavor。</p><p>根据构建的组合规则，Android Plugin 会根据这些分组进行组合关系。以上的例子为例。会产生以下几个 productFalvor组合构建任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. api1Flavor1Debug</span><br><span class="line">2. api1Flavor1Release</span><br><span class="line">3. api2Flavor1Debug</span><br><span class="line">4. api2Flavor1Release </span><br><span class="line">5. api1Flavor2Debug</span><br><span class="line">6. api1Flavor2Release</span><br><span class="line">7. api2Flavor2Debug</span><br><span class="line">8. api2Flavor2Release</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>Gralde产生的变体数量等同于每个flavor模式的组合数量和构建类型数量的乘积。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">falvor每个分组数量 * falvor每个分组数量... * BuildType子项数量</span><br></pre></td></tr></table></figure><p>同时产生是名字也是根据 <code>flavorDimensions</code>所声名的模式名顺序进行拼接。</p><p>比如例子中在 <code>flavorDimensions &quot;api&quot;,&quot;flavor&quot;</code>声名后，产生的编译名为<code>api*+flavor*+debug/release</code>的组合关系。</p><h3 id="productFlavor-DSL"><a href="#productFlavor-DSL" class="headerlink" title="productFlavor DSL"></a>productFlavor DSL</h3><h2 id="过滤变体"><a href="#过滤变体" class="headerlink" title="过滤变体"></a>过滤变体</h2><p>变体是Gradle根据配合内容进行组合增加的，往往会比我们所需求的变体要多，因此为了处理掉不不需要的变体。我们可以通过 <code>variantFilter {}</code>进行过滤。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">variantFilter &#123;</span><br><span class="line">     if(it.name.contains(&quot;flavor2&quot;))&#123;</span><br><span class="line">         it.setIgnore(true)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>这样对于变体名中包含 <code>flavor2</code> 的构建变体都将不会出现在 Build Variant 中。</p><h2 id="变体源"><a href="#变体源" class="headerlink" title="变体源"></a>变体源</h2><p>变体提供了对构建源的隔离，在不同的变体下，可以配置不同的 <code>sourceSet</code>信息。</p><p>默认情况下，<code>main/</code> 的构建源是默认存在的，无论通过任何变体进行构建都将纳入构建范围，因此这里在 <code>main/</code>下存储的都是哥哥变体都共享的资源，而如果需要根据变体信息进行特殊构建的内容，则需要放到对应的变体目录下。</p><p>比如对于 <code>api1Flavor1Debug</code> 变体。对于以下几个源都将纳入构建范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. api1&#x2F;</span><br><span class="line">2. flavor1&#x2F;</span><br><span class="line">3. debug&#x2F;</span><br><span class="line">4. api1Flavor1&#x2F;</span><br><span class="line">5. flavor1Debug&#x2F;</span><br><span class="line">6. api1Flavor1Debug&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>所以如果在这些目录下如果存在同名文件将导致编译冲突。</p><p>如果需要考虑其他的构建源，则可以考虑通过 <code>sourceSets {}</code>进行设置，因为 <code>sourceSet</code> 也支持变体设置因此可以通过以下设置，对单独构建变体进行设置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        api2Flavor2 &#123;</span><br><span class="line">            java.srcDirs &#x3D; [ project.getProjectDir().getAbsolutePath() + &#39;&#x2F;src&#x2F;api2Flavor2&#x2F;temp&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>这样就在 <code>api2Flavor2</code> 变体构建时，将 ‘/src/api2Flavor2/temp’ 纳入构建范围</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>一起编译 java/ 目录中的所有源代码以生成单一的输出。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：对于给定的构建变体，如果找到两个或两个以上定义同一 Java 类的源集目录，Gradle 就会引发一个构建错误。例如，在构建调试 APK 时，您不能同时定义 src&#x2F;debug&#x2F;Utility.java 和 src&#x2F;main&#x2F;Utility.java。这是因为 Gradle 会在构建过程中检查这两个目录并引发“duplicate class”错误。如果针对不同的构建类型需要不同版本的 Utility.java，您可以让每个构建类型定义其自己的文件版本，而不将其包含在 main&#x2F; 源集中。</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><ul><li>所有清单合并为单个清单。将按照上述列表中的相同顺序指定优先级。也就是说，某个构建类型的清单设置会替换某个产品风味的清单设置，依此类推。如需了解更多信息，请阅读合并清单。</li><li>同样，values/ 目录中的文件也会合并在一起。如果两个文件同名，例如存在两个 strings.xml 文件，将按照上述列表中的相同顺序指定优先级。也就是说，在构建类型源集中的文件中定义的值将会替换产品风味中同一文件中定义的值，依此类推。</li><li>res/ 和 asset/ 目录中的资源将打包到一起。如果两个或两个以上的源集中定义有同名资源，将按照上述列表中的相同顺序指定优先级。</li><li>最后，在构建 APK 时，Gradle 会为随库模块依赖项包含的资源和清单分配最低的优先级。</li></ul><h2 id="变体依赖"><a href="#变体依赖" class="headerlink" title="变体依赖"></a>变体依赖</h2><p>正如源设置一样，依赖也支持变体依赖</p><p>可以通过添加变体+依赖方式进行设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    api2Flavor2Compile &#39;junit:junit:4.12&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;构建变体(Build Variants)有两部分内容构成 :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buildTypes&lt;/code&gt;（构建类型） + 
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Transform的基本应用</title>
    <link href="http://yoursite.com/2018/06/09/Transform%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/09/Transform%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/</id>
    <published>2018-06-09T12:51:56.000Z</published>
    <updated>2020-04-10T13:19:56.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android Transform Api 是 Android Gradle Plugin 中提供的一个hook api，该api提供了在 class 转换为 dex 前的加工处理入口，通过该api，我们可以对执行class内容进行更改调整。</p><h2 id="Transform-的基本认识"><a href="#Transform-的基本认识" class="headerlink" title="Transform 的基本认识"></a>Transform 的基本认识</h2><p>Transform 实际是一个普通的回调入口，该回调将根据 Transform 所返回的各个配置，在 class 转换为 dex 前，根据配置内容进行调用，并将结果通过 <code>transform(Context, Collection, Collection, TransformOutputProvider, boolean)【过期】</code> 或 <code>transform(TransformInvocation)</code> 进行返回。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>在 Transform 中有几个必须实现的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class ClassCollectorTransform extends Transform&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><table><thead><tr><th>方法名</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>getName</td><td>Transform Task 命名，该返回名不是作为最后的命名，任务会自动补全该名字</td><td></td></tr><tr><td>getInputType()</td><td>Transform 需要输入的内容类型</td><td></td></tr><tr><td>getScopes</td><td>Transform 搜索范围类型</td><td></td></tr><tr><td>isIncemental</td><td>是否支持增量编译</td><td></td></tr></tbody></table><p>主要参数说明：</p><p>InputType</p><p>该参数指名需要操作的内容，主要：</p><ul><li>CLASSES Java代码</li><li>RESOURCES Java Resource 资源</li></ul><p>除此之外官方提供了一些其他操作内容，但是受限于前置任务的产出物，并不能完全适用于当前阶段的 transform（指定操作内容必须是已产生的产出物）</p><ul><li>DEX</li><li>NATIVE_LIBS</li><li>CLASSES_ENHANCED</li><li>DATA_BINDING</li><li>JAVA_SOURCES</li><li>DEX_ARCHIVE</li></ul><p>Scopes</p><p>该参数指明需要搜索的目标范围，主要提供以下几种内容：</p><ul><li>PROJECT <code>当前项目内容</code></li><li>SUB_PROJECTS <code>子项目内容</code></li><li>EXTERNAL_LIBRARIES <code>外部依赖库</code></li><li>TESTED_CODE <code>测试代码</code></li><li>PROVIDED_ONLY <code>provider 方式的本地或者远程依赖</code></li><li>PROJECT_LOCAL_DEPS <code>项目本地依赖（local jars)</code></li><li>SUB_PROJECTS_LOCAL_DEPS <code>子项目的本地依赖（local jars）</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据以上参数，基本上我们通过使用 InputType + Scope 能实现对应目标内容的输入源的控制。</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>配置完所需要的配置后，接下来就是对所输出的内容进行转换的过程。</p><p>在旧版中，内容是被输出到：</p><p><code>transform(Context contenxt, Collection inputs, Collection referencedInputs, TransformOutputProvider outputProvider, boolean isIncremental)</code>方法中</p><p>这里我们以新版为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform(TransformInvocation transformInvocation)</span><br></pre></td></tr></table></figure><p>TransformInvocation 只是对旧版的封装，及其增加一些补充内容，我们只对目前比较常用的一些参数进行描述。</p><p><strong>Context getContext()</strong></p><p>返回任务上下文，实质该Context为 TransformTask 的父类，TransformTask 是继承自 DefaultTask 的任务子类</p><p><strong>Collection getInputs()</strong></p><p>返回InputType Scopes所要求的内容，TransformInput 提供了两种结果输出，一种是jar，一种是 File（被DirectoryInput包装了） 输出，这两种内容我们都需要进行处理。</p><p><strong>TransformOutputProvider getOutputProvider()</strong></p><p>TransformOutputProvider 是官方提供的输出代理类，通过该工具类，我们可以将需要指定输出的内容输出到所要求的目录下。</p><p>下面用一个例子来简单操作下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class ExampleTransform extends Transform &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    String getName() &#123;</span><br><span class="line">        return &quot;Example&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123;</span><br><span class="line">        return TransformManager.CONTENT_CLASS</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123;</span><br><span class="line">        return TransformManager.SCOPE_FULL_PROJECT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean isIncremental() &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    void transform(TransformInvocation transformInvocation) throws TransformException, InterruptedException, IOException &#123;</span><br><span class="line">        super.transform(transformInvocation)</span><br><span class="line">        println &quot;begin transform&quot;</span><br><span class="line"></span><br><span class="line">        transformInvocation.getInputs().each &#123; TransformInput input -&gt;</span><br><span class="line">            input.directoryInputs.each &#123; DirectoryInput directoryInput-&gt;</span><br><span class="line">                File outputFile &#x3D; transformInvocation.getOutputProvider().getContentLocation(directoryInput.name,</span><br><span class="line">                        directoryInput.contentTypes, directoryInput.scopes,</span><br><span class="line">                        Format.DIRECTORY)</span><br><span class="line">                FileUtils.copyDirectory(directoryInput.file, outputFile)</span><br><span class="line"></span><br><span class="line">                println &quot;directory input  &gt;&gt;&gt; $&#123;directoryInput.file.getAbsolutePath()&#125;&quot;</span><br><span class="line">                println &quot;directory output &gt;&gt;&gt; $&#123;outputFile.getAbsolutePath()&#125; \n&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            input.jarInputs.each &#123; JarInput jarInput-&gt;</span><br><span class="line">                String jarName &#x3D; jarInput.name</span><br><span class="line">                File outputFile &#x3D; transformInvocation.getOutputProvider().getContentLocation(jarName,</span><br><span class="line">                        jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line"></span><br><span class="line">                FileUtils.copyFile(jarInput.file, outputFile)</span><br><span class="line"></span><br><span class="line">                println &quot;jar input  &gt;&gt;&gt; $&#123;jarInput.file.getAbsolutePath()&#125;&quot;</span><br><span class="line">                println &quot;jar output &gt;&gt;&gt; $&#123;outputFile.getAbsolutePath()&#125;\n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println &quot;end transform&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">:app:mergeDebugAssets</span><br><span class="line">:app:transformClassesWithExampleForDebug</span><br><span class="line">begin transform</span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;appcompat-v7-27.1.1.aar&#x2F;7228f687c4d3d50971fb2c4144b818e5&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;0.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;constraint-layout-1.1.2.aar&#x2F;1ffd866ac236943344a2db8900ec9ff0&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;1.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-fragment-27.1.1.aar&#x2F;366533887dab6e0bdc7b5f9565c8df3f&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;2.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;animated-vector-drawable-27.1.1.aar&#x2F;9aa09e1b40578aaf51e0fe3c26b1cf2b&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;3.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-core-ui-27.1.1.aar&#x2F;fbf121a4aa433efd0847730e6a71dfa6&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;4.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-core-utils-27.1.1.aar&#x2F;249c37a99952d8b3446a0f10707ef631&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;5.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-vector-drawable-27.1.1.aar&#x2F;0e11925044cb0cd7243a520ef57b6b65&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;6.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;support-compat-27.1.1.aar&#x2F;89e06865e27940d83a4ef0b84e7a40ec&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;7.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;com.android.support&#x2F;support-annotations&#x2F;27.1.1&#x2F;39ded76b5e1ce1c5b2688e1d25cdc20ecee32007&#x2F;support-annotations-27.1.1.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;8.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;com.android.support.constraint&#x2F;constraint-layout-solver&#x2F;1.1.2&#x2F;bfc967828daffc35ba01c9ee204d98b664930a0f&#x2F;constraint-layout-solver-1.1.2.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;9.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;livedata-core-1.1.0.aar&#x2F;63c28b9d84c74954069ca32d59a8948a&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;10.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;viewmodel-1.1.0.aar&#x2F;e7d22623b4477da4befa3300011bae7f&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;11.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;runtime-1.1.0.aar&#x2F;ddae57800275e6f4fbfcddbc1689ac1c&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;12.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;android.arch.lifecycle&#x2F;common&#x2F;1.1.0&#x2F;edf3f7bfb84a7521d0599efa3b0113a0ee90f85&#x2F;common-1.1.0.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;13.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;transforms-1&#x2F;files-1.1&#x2F;runtime-1.1.0.aar&#x2F;6a2bd34a44e70a5ec1df7445a52ad01e&#x2F;jars&#x2F;classes.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;14.jar</span><br><span class="line"></span><br><span class="line">jar input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;.gradle&#x2F;caches&#x2F;modules-2&#x2F;files-2.1&#x2F;android.arch.core&#x2F;common&#x2F;1.1.0&#x2F;8007981f7d7540d89cd18471b8e5dcd2b4f99167&#x2F;common-1.1.0.jar</span><br><span class="line">jar output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;15.jar</span><br><span class="line"></span><br><span class="line">directory input  &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;classes&#x2F;debug</span><br><span class="line">directory output &gt;&gt;&gt; &#x2F;Users&#x2F;XX&#x2F;Desktop&#x2F;Git&#x2F;transformExample&#x2F;app&#x2F;build&#x2F;intermediates&#x2F;transforms&#x2F;Example&#x2F;debug&#x2F;16 </span><br><span class="line"></span><br><span class="line">end transform</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>在以上例子中我们并未对拦截到的class内容进行任何操作，仅仅只是将它们进行转移，这里需要注意的是，我们对于拦截的内容，需要手动转移到指定的 <code>getContentLocation</code> 地址下，不能随意进行存储，否则将不能正常处理转换后的内容。</p><p>另外根据所指定的产物内容的不同，<code>getContentLocation</code>所存放的地址也不一样。</p><p>这里值得注意的是，如果我们忽略了部分代码的转移，那么在最后的包中，将不再有该代码文件的存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransformManager 提供了较多常用的封装工具，可以参考这里面的API进行调用</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>结合以上的内容，已经可以初步获取到所需要产物的输入内容，并能将所输出的内容转移到对应的目录下。在这个流程中，我们可以任意对输入内容进行修改后再进行转移，以达到所需要的代码调整的目的。</p><p>当然对应晦涩难懂的Class 字节码，我们不会直接对字节流进行读取后操作，而是借助于字节码工具，在进行加工处理。</p><p>比较出名的字节码操作库有javassist、asm、aspectJ等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Android Transform Api 是 Android Gradle Plugin 中提供的一个hook api，该api提供了在 
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Gradle中Task应用</title>
    <link href="http://yoursite.com/2018/06/01/Gradle%E4%B8%ADTask%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/06/01/Gradle%E4%B8%ADTask%E5%BA%94%E7%94%A8/</id>
    <published>2018-06-01T12:50:16.000Z</published>
    <updated>2020-04-10T13:20:09.301Z</updated>
    
    <content type="html"><![CDATA[<p>在认识Task之前需要知道Gradle的生命周期分为： 初始化阶段、配置阶段和执行阶段。</p><p>Task作为Project的单位，也遵循这个生命周期流程。</p><h2 id="Task-的配置、动作与依赖"><a href="#Task-的配置、动作与依赖" class="headerlink" title="Task 的配置、动作与依赖"></a>Task 的配置、动作与依赖</h2><h3 id="Task-的配置"><a href="#Task-的配置" class="headerlink" title="Task 的配置"></a>Task 的配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task exampleTask &#123;</span><br><span class="line">    config1 &#x3D; &quot;config 1&quot;</span><br><span class="line">    config2 &#x3D; &quot;config 2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义task时，我们会在定义后跟上一个闭包，这个闭包将在配置阶段执行，因此我们可以在该闭包中，执行对太任务的属性配置和动作添加等。</p><p>注意，配置执行几乎在每次脚本执行流程都将发生。</p><p>执行task的命令比较简单，这里就不举例了，可以直接创建一个 build.gradle（每个构建项目下，默认约定的文件名，没有为什么） 进行试验。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle 任务名</span><br></pre></td></tr></table></figure><h3 id="Task-的动作"><a href="#Task-的动作" class="headerlink" title="Task 的动作"></a>Task 的动作</h3><p>与配置不同，Task的动作发生在执行阶段。</p><p>动作添加比较常用的有两种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task exampleTask &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute example task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task exampleTask &#123;</span><br><span class="line">   doLast &#123;</span><br><span class="line">        println &quot;execute example task&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种运算符重载的方式在 gralde 5.0 可能将被废除，因此比较推荐的是使用第二种方式，在配置流程中即实现。当然你也可以直接调用 Task 的 doLast 方法直接添加，这里看个人需求而定，只是相对集中的话，方便管理。</p><h3 id="Task的依赖"><a href="#Task的依赖" class="headerlink" title="Task的依赖"></a>Task的依赖</h3><p>和project 一样，task 也和task 可以产生相互的依赖关系，我们比较常用的场景是，对于 B Task 执行前，我们需要确保 A Task 是执行的，否则将不执行。</p><p>这种情况，我们就可以使用Task 的API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dependsOn(tasks: Object...)</span><br></pre></td></tr></table></figure><p>在声明Task时，我们可以通过构建器，对Task对象进行简单的配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task exampleATask &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute A Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleBTask(dependsOn: exampleATask) &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute B Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleCTask(dependsOn: [exampleATask,exampleBTask]) &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute C Task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task exampleATask &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute A Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleBTask(dependsOn: exampleATask) &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute A Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleCTask(dependsOn: [exampleATask,exampleBTask]) &lt;&lt; &#123;</span><br><span class="line">    println &quot;execute B Task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分别定义A、B、C三个任务，B依赖于A，C依赖于A、B，这里我们执行了C Task，结果输出了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :SubExample:exampleATask</span><br><span class="line">execute A Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleBTask</span><br><span class="line">execute B Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleCTask</span><br><span class="line">execute C Task</span><br></pre></td></tr></table></figure><p>可以看到 Gradle为我们优化了 Task的流程，分别执行了 A、B、C 任务</p><p>这里注意下，如果我们在一个依赖中存在多个依赖，在依赖间并不存在可以推断的顺序时，将不保证按声明顺序执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">task exampleATask &lt;&lt; &#123;</span><br><span class="line">println &quot;execute A Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleBTask &lt;&lt; &#123;</span><br><span class="line">println &quot;execute B Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleCTask &lt;&lt; &#123;</span><br><span class="line">println &quot;execute C Task&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task exampleDTask(dependsOn: [exampleCTask,exampleBTask,exampleATask]) &lt;&lt; &#123;</span><br><span class="line">println &quot;execute D Task&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们运行 <code>exammpleDTask</code>任务，而输出的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :SubExample:exampleATask</span><br><span class="line">execute A Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleBTask</span><br><span class="line">execute B Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleCTask</span><br><span class="line">execute C Task</span><br><span class="line"></span><br><span class="line">&gt; Task :SubExample:exampleDTask</span><br><span class="line">execute D Task</span><br><span class="line">dependsOn&#96;的任务关系中，如果前置任务失败，则不会继续执行下面的Task，如果需要保证即使失败也需要执行接下来的任务，则可以使用Task的Api &#96;finalizedBy(paths: Object...)</span><br><span class="line">task exampleDTask(dependsOn: [exampleCTask,exampleBTask,exampleATask]) &#123;</span><br><span class="line">finalizedBy exampleETask</span><br><span class="line">doLast &#123;</span><br><span class="line">println &quot;execute D Task&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上最后需要确保 <code>exampleETask</code> 执行</p><h2 id="自定义Task"><a href="#自定义Task" class="headerlink" title="自定义Task"></a>自定义Task</h2><p>在 task 定义中我们经常看到这样定义的任务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task CopyTask(type:Copy) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>type</code> 即是 <code>CopyTask</code> 所声明的Task类型，它继承了 Copy Task 一切特性，这相当于我们的继承概念，而 CopyTask 便是其子类，并在<code>task</code>的声明中产生其实例。</p><p>这里我们将 <code>Copy</code> Task 当做其 Task 的一个模板，因为 copy 任务是经常被复用的，因此将其作为一个内置Task。</p><p>那么类似的情况，如果我们也有一个常用的Task模板，我们应该怎么自定义呢。</p><h3 id="简单自定义Task"><a href="#简单自定义Task" class="headerlink" title="简单自定义Task"></a>简单自定义Task</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">task ExampleSubTask(type:ExampleTask) &#123;</span><br><span class="line">taskParam &#x3D; &quot;ExampleSubTask&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ExampleTask extends DefaultTask &#123;</span><br><span class="line">String taskParam</span><br><span class="line"></span><br><span class="line">@TaskAction</span><br><span class="line">void start()&#123;</span><br><span class="line">println &quot;Example Task start $taskParam&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Task :ExampleSubTask</span><br><span class="line">Example Task start ExampleSubTask</span><br></pre></td></tr></table></figure><p>这是个简单的例子，我们继承默认的 Task 实现 <code>DefaultTask</code>，然后在对应的 Task 方法签名上声明 <code>@TaskAction</code>，作为任务的执行内容。</p><p>Tip：如果只是简单的实现Task内容，则可以使用<code>DefaultTask</code>，其他的细节可参照其父类进行对应的实现。</p><h2 id="备注-Api"><a href="#备注-Api" class="headerlink" title="备注 Api"></a>备注 Api</h2><h3 id="task依赖"><a href="#task依赖" class="headerlink" title="task依赖"></a>task依赖</h3><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>dependsOn(tasks:Object…)</td><td></td><td></td></tr></tbody></table><h3 id="动作定义"><a href="#动作定义" class="headerlink" title="动作定义"></a>动作定义</h3><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>doFirst(action: Closure)</td><td></td><td></td></tr><tr><td>doLast(action: Closure)</td><td></td><td></td></tr><tr><td>getActions()</td><td></td><td></td></tr></tbody></table><h3 id="输入-输出数据声明"><a href="#输入-输出数据声明" class="headerlink" title="输入/输出数据声明"></a>输入/输出数据声明</h3><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>getInputs()</td><td></td><td></td></tr><tr><td>getOutputs()</td><td></td><td></td></tr></tbody></table><h3 id="getter-setter-属性"><a href="#getter-setter-属性" class="headerlink" title="getter/setter 属性"></a>getter/setter 属性</h3><table><thead><tr><th>方法</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>getAnt()</td><td></td><td></td></tr><tr><td>getDescription()</td><td></td><td></td></tr><tr><td>getEnabled()</td><td></td><td></td></tr><tr><td>getGroup()</td><td></td><td></td></tr><tr><td>setDescription(description: String)</td><td></td><td></td></tr><tr><td>setEnabled(enabled: boolean)</td><td></td><td></td></tr><tr><td>setGroup(group: String)</td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在认识Task之前需要知道Gradle的生命周期分为： 初始化阶段、配置阶段和执行阶段。&lt;/p&gt;
&lt;p&gt;Task作为Project的单位，也遵循这个生命周期流程。&lt;/p&gt;
&lt;h2 id=&quot;Task-的配置、动作与依赖&quot;&gt;&lt;a href=&quot;#Task-的配置、动作与依赖&quot; c
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Java-同步与锁</title>
    <link href="http://yoursite.com/2018/05/30/Java-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/"/>
    <id>http://yoursite.com/2018/05/30/Java-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/</id>
    <published>2018-05-30T13:28:18.000Z</published>
    <updated>2020-04-28T07:26:20.600Z</updated>
    
    <content type="html"><![CDATA[<p>同步性的要求一般是围绕着 有序性和可见性进行，即使是锁也是为了辅助其目的进行。</p><h1 id="多核心多线程"><a href="#多核心多线程" class="headerlink" title="多核心多线程"></a>多核心多线程</h1><p>任何机器上的执行到最后都需要将执行的代码转化为一条一条的机器指令，我们经常所见的一行代码，可能会由十几条指令所构成。</p><p>在目前越来越先进的时代，CPU集成了多个处理器核心，允许在同一时间同时执行多个指令，以提高执行效率。</p><p>因此这就涉及到某些指令是否有无关联性，是否可被优化同时进行，而有些指令存在必然的上下连续，如果轻易变更执行顺序则容易发生二义，导致结果不准确，因此再此基础上，需要保证这些指令执行的原子性，进而体现出有序性。</p><p>如果这不容易理解可以看一个经典 <code>a++</code> 例子</p><p>比如连续两次的 a++递增操作，如果当前由两个CPU分别对这两个指令进行处理，则会导致两个CPU从总内存读取到缓存的值都为1，当递增进行时，两个处理器都是对 1 的递增，从而导致i的结果最终为 2 而不是3。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31237/WEBRESOURCE1263a5bb2ae96b8a03c721a75ebd18fb"  alt="image"></p><p>两个连续的<code>a++</code> 如果没有有序性的保证，则会在指令阶段被两个CPU所同时执行，由于两者感知不到对方的联系，结果会导致异常。</p><blockquote><p>cpu 缓存目前发展的比较快，目前存在三级缓存 L1、L2、L3 Cache ，则都是为了缓和CPU高速与低俗主内存的差距。缓存功能上会有差些差别，比如一个用于存数据的 L1dCache 一个用于存指令的 L1i Cache，缓存的结构在不同平台上可能会有所差异，这取决于处理器设计。</p></blockquote><p>Java 为支持多线程技术，提供了比较多的技术支持。</p><h1 id="指令执行的有序性"><a href="#指令执行的有序性" class="headerlink" title="指令执行的有序性"></a>指令执行的有序性</h1><p>Java 会根据一些既定的原则在编译时为我们梳理执行的有序的约束，而这些约束是开发者所需要了解的。</p><h2 id="happen-before-原则"><a href="#happen-before-原则" class="headerlink" title="happen-before 原则"></a>happen-before 原则</h2><p>happen-before 是对执行顺序规则的约束。</p><h3 id="单线程happen-before原则"><a href="#单线程happen-before原则" class="headerlink" title="单线程happen-before原则"></a>单线程happen-before原则</h3><p><code>在同一个线程中，书写在前面的操作happen-before后面的操作。</code> </p><p>这里指的是对于存在上下关联的代码，在同一个线程代码中需要保持其有序性。比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1</span><br><span class="line">int i1 &#x3D; i + 1</span><br><span class="line">int i2 &#x3D; i + i1</span><br></pre></td></tr></table></figure><p>i1 依赖于 i，i2依赖于i1，并且在同一线程代码块中执行，为了保证其依赖性关系，必须保证i先于i1、i1先于i2。</p><p>如果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i &#x3D; 1</span><br><span class="line">int i1 &#x3D; 2</span><br><span class="line">int i2 &#x3D; i + i2</span><br></pre></td></tr></table></figure><p>则i 和 i1的有序性则不在被关心，但是i 和 i1 必须在i2前完成。</p><h3 id="锁的happen-before原则"><a href="#锁的happen-before原则" class="headerlink" title="锁的happen-before原则"></a>锁的happen-before原则</h3><p><code>同一个锁的unlock操作，happen-before此锁的lock操作</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">   public synchronized void a1()&#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public synchronized void a2()&#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;    </span><br><span class="line">   </span><br><span class="line">    public synchronized void a3()&#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果执行有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A a &#x3D; A()</span><br><span class="line"></span><br><span class="line">a.a1()</span><br><span class="line">a.a2()</span><br><span class="line">Thread() &#123;</span><br><span class="line">    public run() &#123;</span><br><span class="line">        a.a3()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start()</span><br></pre></td></tr></table></figure><p>则如果 a3 可被执行并且通过<code>synchronized</code>获取到锁（lock) 则在 解锁前（unlock）a1(), a2() 都将不会得到锁（lock），只有到 lock - unlock 完成，才会轮到下一个目标获得锁继续有效向下分配执行。</p><h3 id="volatile的happen-before原则"><a href="#volatile的happen-before原则" class="headerlink" title="volatile的happen-before原则"></a>volatile的happen-before原则</h3><p><code>对一个volatile变量的写操作，happen-before对此变量的任意操作(当然也包括写操作了)</code></p><p>即表现为当一个变量声明为 volatile 时，当一个线程对该变量进行写入，则另一个线程必须发生可见性生效。</p><p>详细例子可以参见 <a href="#volatile声明">volatile声明</a></p><h3 id="happen-before的传递性原则"><a href="#happen-before的传递性原则" class="headerlink" title="happen-before的传递性原则"></a>happen-before的传递性原则</h3><p><code>如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 1</span><br><span class="line">int b &#x3D; a + 1</span><br><span class="line">int c &#x3D; b + 1</span><br></pre></td></tr></table></figure><p>以上  c 依赖于 b、b依赖于 a、则可以推断出 c 依赖于 a</p><h3 id="其他原则"><a href="#其他原则" class="headerlink" title="其他原则"></a>其他原则</h3><ul><li>线程启动的happen-before原则 </li></ul><p><code>同一个线程的start方法happen-before此线程的其它方法</code></p><ul><li>线程中断的happen-before原则 </li></ul><p><code>对线程interrupt方法的调用，happen-before被中断线程的检测到中断发送的代码</code></p><ul><li>线程终结的happen-before原则 </li></ul><p><code>线程中的所有操作都happen-before线程的终止检测</code></p><ul><li>对象创建的happen-before原则  </li></ul><p><code>一个对象的初始化完成先于他的finalize方法调用</code></p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>通过规则约束了代码的顺序，而在底层中，Java还 通过内存屏障达到有序性目的。</p><p>在开发中我们经常会需要用到 <code>volatitle</code> 关键字，为了让所修饰的变量，保证对其赋值先后执行的有序性，不会被编译器进行代码重排优化，从而导致结果的不正常的结果。</p><p>比如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Main &#123;</span><br><span class="line">    public static int count &#x3D; 0;</span><br><span class="line">    public void main(Strig[] args) &#123;</span><br><span class="line">        count ++;</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while(count &gt; 0) &#123;</span><br><span class="line">                    ....</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于线程的创建和count的执行并无联系，如果代码被重排，导致count++执行在线程启动后，则很容易导致线程的提前终止。而如果加上volatitle则没有这个问题。</p><p>因此为了让开发者能精确控制某种情况，Java还提供了比较多技术，比如提到的 volatitle。而这些底层都是通过内存屏障所实现。</p><p>内存屏障指的是一个CPU指令（不同平台指令命名不一样，这里内存屏障只是概念，比如x86 有  sfence 指令），用于确保特定操作的执行顺序、对一些数据影响其可见性。在之前所使用的lock 指令前缀，也是内存屏障实现一种。</p><p>通过内存屏障指令，可以达到以下效果：</p><ol><li>确保指令前后不被重排。在所插入内存屏障的前后，保证前面指令先于后面执行，保证后面指令后于前面执行的效果，确保不被错误优化。</li><li>会导致CPU缓存失效，从而导致CPU缓存刷新数据值</li></ol><h3 id="内存屏障类型"><a href="#内存屏障类型" class="headerlink" title="内存屏障类型"></a>内存屏障类型</h3><p>不同平台提供的内存屏障实现不一样，根据实现方面的不同，可以分为几种类型：</p><p>可以分为对两个指令情况的顺序<br>Store: 将处理器缓存数据刷新到内存中<br>Load: 将内存中的数据拷贝到处理器缓存中</p><table><thead><tr><th>屏障类型</th><th>指令顺序</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1;LoadLoad;Load2</td><td>该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td></tr><tr><td>StoreStore Barriers</td><td>Store1;StoreStore;Store2</td><td>该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td></tr><tr><td>LoadStore Barriers</td><td>Load1;LoadStore;Store2</td><td>确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;StoreLoad;Load1</td><td>该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作.它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td></tr></tbody></table><blockquote><p>使用前需要确保使用的平台是否支持，比如x86 仅支持 StoreLoad Barriers</p></blockquote><ul><li>CPU 接受到屏障指令后，不将屏障指令放入序列缓冲区，而是将屏障指令及其后续指令进入队列中（FIFO）</li><li>在序列缓冲区的指令，允许被乱序执行</li><li>执行队列中屏障指令，在执行过程中同时刷新缓存</li><li>将剩余指令重新放回序列缓冲区</li><li>重新恢复乱序执行</li></ul><h3 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h3><p>final 关键字算是对内存屏障一种实施，JVM会在初始化final后插入 StoresStores Barriers 屏障，保证将 final 加载后对 final即赋值操作，不会因为重排而导致的乱序，并且保证初始时之前对内存的可见性。</p><p>因此 final 经常用于作为恶汉模式的单例初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public A &#123;</span><br><span class="line">    public static final A a &#x3D; new A()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例中的初始化问题"><a href="#单例中的初始化问题" class="headerlink" title="单例中的初始化问题"></a>单例中的初始化问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public A &#123;</span><br><span class="line">    private static A a &#x3D; null</span><br><span class="line">    public void init &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public static A getInstance() &#123;</span><br><span class="line">        if(a &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (A.class) &#123;</span><br><span class="line">                if(a &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    a &#x3D; new A();</span><br><span class="line">                    a.init()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码未单例模式构造中的一种饱汉模式。</p><p>这里对 a 单例变量做了两次判断，并且第二次是通过 synchronized 进行同步块实现。</p><p>在synchronized 中同样也实现了有序性和可见性，当触发同步块会强制对缓存进行更新，从而保证对a的可见性，同时由于有序性的保证，不会导致税 a 在 new A() 时，不会因为没有对a进行初始化（重排导致）而导致其他的问题</p><h1 id="多线程间的可见性"><a href="#多线程间的可见性" class="headerlink" title="多线程间的可见性"></a>多线程间的可见性</h1><p>多线程的可见性是JVM在工作模式定义上所产生。</p><h2 id="线程内存结构"><a href="#线程内存结构" class="headerlink" title="线程内存结构"></a>线程内存结构</h2><p>在JVM运行时，主要涉及三个角色，分别为主内存、线程、执行引擎。</p><p>所有数据源的开始都是由主内存提供，对于所有线程都是可访问的。</p><p>线程是执行的代理者，也是JVM中最小的执行单位，通过线程才能和执行引擎进行交互工作。</p><h2 id="内存模型交互"><a href="#内存模型交互" class="headerlink" title="内存模型交互"></a>内存模型交互</h2><p>在JVM内存模型中，线程工作模式，是使用工作内存与主内存直接进行交互，线程在执行前会从主内存中获取对应的数据加载到工作内存中，在线程调用执行引擎执行中（或者执行引擎向线程索取）所需要的参数通过调用工作内存中的数据。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31816/WEBRESOURCE59c7a5ee8e15c0b12c1a6ec4f9a21552"  alt="image"><br>为了保证工作的有序性，在主内存、工作内存和执行引擎间定义了一操作：</p><h3 id="作用于主内存"><a href="#作用于主内存" class="headerlink" title="作用于主内存"></a>作用于主内存</h3><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>lock（锁定）</td><td>把一个变量标识为一条线程独占状态，执行后将清空该线程工作内存中此变量的值，执行引擎使用时将重新执行load或assign初始化</td></tr><tr><td>unlock（解锁）</td><td>把一个处于lock状态的变量释放出来，释放后的变量才可以被其他线程锁定</td></tr><tr><td>read（读取）</td><td>将一个变量值从主内存中传输到工作内存中，便于load后续操作。</td></tr><tr><td>write（写入）</td><td>把store操作从工作内存中得到的变量的值放入主内存的变量中</td></tr><tr><td>### 作用于工作内存</td><td></td></tr><tr><td>指令</td><td>说明</td></tr><tr><td>————–</td><td>————————————————————</td></tr><tr><td>use（使用）</td><td>把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作</td></tr><tr><td>assign（赋值）</td><td>把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</td></tr><tr><td>store（存储）</td><td>把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用</td></tr><tr><td>load（载入）</td><td>把read操作从主内存中得到的变量值放到工作内存的变量副本中</td></tr></tbody></table><h3 id="关于-read-write、load-store-的连续性"><a href="#关于-read-write、load-store-的连续性" class="headerlink" title="关于 read-write、load-store 的连续性"></a>关于 read-write、load-store 的连续性</h3><p>read 可以理解为把变量从主内存（shared memory）读取到CPU local memory （CPU cache）</p><p>write 则是从 CPU local memory 复制到主内存中</p><p>load 通过 CPU local memory 读取到工作内存 JVM stack （或者JVM 寄存器）中</p><p>store 则将 工作内存的数据写入到 CPU local memory 下，等待被写回主内存。</p><p>由于主内存和CPU缓存是保持同步（嗅探、缓存一致性），当一个CPU发生与主内存的存取操作，其他CPU同时也会得到通知，从而保证多个处理器间的一致性，保证了程序处理的正确性。</p><blockquote><p>另外由于在架构上不同，并不能保证 read - load  1 ：n 操作可以支持，或者反之，因此通常仅要求 1：1 连续性操作即可，该兼容同样适用 load-store</p></blockquote><h3 id="交互规则和约束"><a href="#交互规则和约束" class="headerlink" title="交互规则和约束"></a>交互规则和约束</h3><p>考虑到内存结构的在运行上正确性、执行兼容性、可见性等问题，在以上操作中需要保证一定的规则。</p><ul><li>内存模型要求 read-load、 store-write 必须按顺序执行，但是不保证连续执行，因此可以在两个指令间插入其他指令</li><li>不允许 read-load、store-write 操作单独出现，不允许一个变量从主内存读取但是工作内存不接受，或者从工作内存发起回写到主内存不接受的情况。</li><li>不允许一个线程丢弃它的最近的 assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存</li><li>不允许一个线程无原因地（没有发生任何  assign 操作）把数据从线程的工作内存同步回到主内存中</li><li>变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（未执行过load或assign指令）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过 assign 和 load操作。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，允许同一条线程重复执行多次lock，但是需要执行相同次数的unlock操作才能被解锁</li><li>如果一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值</li><li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</li></ul><h2 id="volatile声明"><a href="#volatile声明" class="headerlink" title="volatile声明"></a>volatile声明</h2><p>volidate 常用于一些变量的可见性声明，看下面一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Main &#123;</span><br><span class="line">    private static boolean close &#x3D; false;</span><br><span class="line">    public static void main(String[] arg) throws InterruptedException &#123;</span><br><span class="line">        Main main  &#x3D; new Main();</span><br><span class="line">        Thread a &#x3D; new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                int count &#x3D; 0;</span><br><span class="line">                while (!close) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        count ++;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(&quot;end thread , count &quot; + count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        Thread b &#x3D; new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(2000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                close &#x3D; true;</span><br><span class="line">                System.out.println(&quot;turn off thread &quot;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        b.start();</span><br><span class="line">        Thread.sleep(5000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子分别设立 a、b两个线程，通过共享变量 close 控制 a线程的循环执行，可以发现共享变量 close 并没有设置 volatile，结果和预期一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">turn off thread </span><br><span class="line"></span><br><span class="line">Process finished with exit code 130 (interrupted by signal 2: SIGINT)</span><br></pre></td></tr></table></figure><p>无法结束 a 线程循环状态。</p><blockquote><p>注意在以上实验 while (!close) {} 内不能使用含有任何锁的内容比如 锁（lock - unlock 一套）、Synconized 同步块、以及 System.out.println(..)方法内存在Synconized 同步块的情况，会导致在同步块结束时，对工作内存的强制更新，达到和可见性一样的目的，导致实验失败</p></blockquote><p>如果为 close 加上 <code>volatile</code> 则正常结果输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">turn off thread </span><br><span class="line">end thread , count -1153724066</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>通过对第37行代码汇编跟踪:<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31538/598F5BEFC15E42A4AEE6AE227867248F"  alt="image"></p><p>发现在执行 add 指令会增加 lock 前缀，这便是 volidate 的秘密所在。</p><p>在LOCK指令解释中，当发生内存修改操作时，LOCK前缀会去调用加锁的 读-修改-写操作，这常会触发两种中的一种操作（根据实现不同而表现不同）总线锁定或缓存锁定，也就是当发生锁定时，只有执行的处理器可以进行读写操作，其他处理器是无法访问，如果为总线锁定则整个总线将无法访问（LOCK#信号机制），阻塞其他处理器，缓存锁定则仅对访问的内存区域地址。</p><p>总而言之有lock 可以起到的几个作用：</p><ul><li>锁定总线或者缓存（根据实现和需要），如果在缓存锁定不能满足情况下，则升级为LOCK#信号进行总线锁定，防止其他处理器的访问</li><li>如果发生的为缓存锁定，则lock后的写操作回写数据，则同时会让其他处理器的缓存失效，并强制其他处理器重新中主内存中读取。（通过缓存一致性实现这个效果）</li></ul><h2 id="CPU-层的保证"><a href="#CPU-层的保证" class="headerlink" title="CPU 层的保证"></a>CPU 层的保证</h2><p>在上面的代码中只是停留在JVM层的运行保证上，那么对于机器底层是如何保证其操作的原子性。</p><p>如果无法满足，则直接会降级为其他锁操作，比如之前的总线、缓存锁定</p><h3 id="总线锁定"><a href="#总线锁定" class="headerlink" title="总线锁定"></a>总线锁定</h3><p>总线锁定是作用于多个处理器对总内存访问之间的操作。</p><p>当多个处理器对共享变量进行读取更新时，经常会造成前后更新和期望值不一致的情况。</p><p>因此为了阻止这种情况，总线锁定后，当CPU  执行指令时，发起 LOCK 内存 信号，将其他处理器的请求阻塞，此时内存为该处理独享，当完成后，则通知UNLOCK 内存</p><h3 id="缓存锁定"><a href="#缓存锁定" class="headerlink" title="缓存锁定"></a>缓存锁定</h3><p>缓存锁定是作用于处理器对具体内存地址访问时发生的操作。<br>相对于总线锁定，缓存锁定是对其的优化，由于总线锁定会导致其他正在执行的无关进程的影响，因此通过只锁定该变量的内存地址即可。</p><p>具体操作：执行读取会对地址进行锁定LOCK，如果缓存在处理器LOCK操作期间回写操作，则通过缓存一致性机制通知修改的内存地址，从而保证不会被多个处理器修改，如果在锁定期间被其他处理器发起回写操作，则会被拒绝，并且在锁定期间是不能同时被其他处理器缓存缓存行。</p><p>以上处理CPU原子性的自我保证，都是通过前缀lock 指令可以实现指令操作原子性（比如 ADD、OR、CMPXCHG、BTS 等有写入的操作指令）</p><h4 id="处理器原子性"><a href="#处理器原子性" class="headerlink" title="处理器原子性"></a>处理器原子性</h4><p>CPU 对字节的读取写入（一个缓存行，大部分最小一个字节）都是原子性的，如果处理器进行这些操作，则其他的处理器是无法访问，该内存区域处于独享状态。在后期中对于读取的单位有了更多的提升，比如 64 bit ，但是这些更复杂的操作在其他运行机制上也需要得到保证才能保证其原子性比如：</p><ul><li>保证读取不跨越多个缓存行</li><li>保证不超过总线宽度</li><li>保证不跨页表访问</li></ul><h2 id="缓存一致性（嗅探技术）"><a href="#缓存一致性（嗅探技术）" class="headerlink" title="缓存一致性（嗅探技术）"></a>缓存一致性（嗅探技术）</h2><p>在共享的数据总线上，所有的内存传输都在这条总线上进行，处理器对于内存的访问都需要经过仲裁处理（arbitrate ： 在一个指令周期中，只有一个CPU缓存可以读写缓存），CPU缓存的工作不仅包括与内存总线的交互，还包括对总线上所有数据交互的感知（比如其他处理器与总线发生的读写操作），比如当一个处理器发生读写操作，其他处理器同时都将得到通知，这便是缓存一致性<code>（嗅探技术）</code>，缓存一致性对之前提到的缓存行锁定提供了强力支持。</p><h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>缓存行锁定的单位即为缓存行，那么缓存行又是什么。</p><p>缓存行指的是CPU缓存中最小的存储单，也是一段存储空间，根据CPU架构实现的不同有32、64位等，目前主流为64字节大小。</p><p>当CPU执行读取内存的指令时，会将一段内存地址传递给一级数据缓存，一级数据缓存会检查内存地址所对应的缓存段，检查是否在缓存中，如果没有则从内存中加载整个缓存段，这里数据读取会根据<code>局部性原理</code>将相邻内存地址的的缓存段整块加载进处理器缓存中。</p><h3 id="MESI-协议"><a href="#MESI-协议" class="headerlink" title="MESI 协议"></a>MESI 协议</h3><p>市面上对于缓存一致性有比较多的实现，比较主流的是MESI协议。</p><p>在MESI协议中对缓存定义了四种状态：</p><ul><li>M(modify) ：表示该缓存已被修改（相对于S，同时也需要同步缓存），处于这一状态的数据，只在本CPU中有缓存数据，而其他CPU中没有。同时其状态相对于内存中的值来说，是已经被修改的，且没有更新到内存中</li><li>E(exclusive) ：表示该缓存被改CPU独占（无需同步缓存），处于这一状态的数据，只有在本CPU中有缓存，且其数据没有修改，即与内存中一致</li><li>S(share) ：表示该缓存被其他CPU共享（需要同步缓存，但是目前还没被修改），处于这一状态的数据，只有在本CPU中有缓存，且其数据没有修改，即与内存中一致</li><li>I（invalid）：表示该缓存已失效（针对共享缓存），本CPU中的这份缓存已经无效。</li></ul><p>在以上的各个状态中，如果处于不同的状态锁执行的职责会相对不一样。</p><ul><li>M：一个处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主存地址的操作，如果监听到，则必须在此操作执行前把其缓存行中的数据写回CPU</li><li>S：一个处于S状态的缓存行，必须时刻监听使该缓存行无效或者独享该缓存行的请求，如果监听到，则必须把其缓存行状态设置为I</li><li>E：一个处于E状态的缓存行，必须时刻监听其他试图读取该缓存行对应的主存地址的操作，如果监听到，则必须把其缓存行状态设置为S</li></ul><p>一个内存行针对于CPU的请求只有两种动作需要考虑回应：</p><ul><li><p>读：当CPU需要读取数据时，如果其缓存行的状态是I的，则需要从内存中读取，并把自己状态变成S，如果不是I，则可以直接读取缓存中的值，但在此之前，必须要等待其他CPU的监听结果，如其他CPU也有该数据的缓存且状态是M，则需要等待其把缓存更新到内存之后，再读取</p></li><li><p>写：当CPU需要写数据时，只有在其缓存行是M或者E的时候才能执行，否则需要发出特殊的RFO指令(Read Or Ownership，这是一种总线事务)，通知其他CPU置缓存无效(I)，这种情况下会性能开销是相对较大的。在写入完成后，修改其缓存状态为M</p></li></ul><blockquote><p>并非所有情况都会使用缓存一致性的，如被操作的数据不能被缓存在CPU内部或操作数据跨越多个缓存行(状态无法标识)，则处理器会调用总线锁定;另外当CPU不支持缓存锁定时，自然也只能用总线锁定了，比如说奔腾486以及更老的CPU。</p></blockquote><h1 id="关于锁"><a href="#关于锁" class="headerlink" title="关于锁"></a>关于锁</h1><p>Java 中提供了大量的锁实现和工具为我们在多线程中提供方便。<br>当然在了解锁工具前，我们需要对锁的知识有一些了解。</p><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>在运行时的对象结构中，存在在对锁的记录区域，这部分区域位于对象头区域。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/30954/WEBRESOURCE8bfaa4b2482158ebc99cf9f8d21cbd9a"  alt="image"></p><ul><li>markword <code>存储当前对象的锁状态、hashcode、GC age、偏向锁位等信息，在使用到锁机制时 Synconized、CAS 等都需要访问到</code></li><li>Class Pointer (对象类型指针) <code>类元数据指针，该指针用于确定实例所属的Class，如果为数组则会额外部分存储数组长度</code></li><li>instance data (实例数据区域) <code>存储对象的所有字段信息（父子类），分配规则与JVM配置有关。</code></li><li>padding（对齐数据）<code>用于对齐 8 byte 部分，任何对象大小都需要为8的整数倍，不足部分则补齐，不一定存在</code></li></ul><p>以上是JVM对象的主要结构。在markword 中存有该对象锁的状态信息，具体锁的状态和对于的字节意义如下（以32byte为例）：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/30960/WEBRESOURCE36d1456473b72a65b2a75deb40e95767"  alt="image"></p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁的升级是为了减少线程挂起恢复（内核访问造成访问性能差），在不必要的时候不必浪费过多CPU资源。</p><p>转化方向和条件如下： </p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/30991/WEBRESOURCE8f7f4c587f6e554b3140e9d841e4942d"  alt="image"></p><p>根据所状态的不同对于 markword 的存储的状态也会发生相应的变化</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>对象一开始处于无锁状态，如果未申请锁，则允许多线程进行访问。在无锁状态下对值的修改会一直处于尝试的状态，如果没有成功则重试，直到成功为止。</p><p>无锁的同步技术：CAS</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>解决问题：如果对象一直处于只有一个线程持有，那么即使使用锁也不必要进行同步操作</p><p>升级条件：当有其他线程访问的时候触发锁升级。</p><p>升级操作：</p><ul><li>标记为设置 01</li><li>偏向值设置 1</li><li>CAS获取线程ID并设置进去</li></ul><p>具体实现： ReentrantLock、synchronized 等</p><h3 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h3><p>解决问题：如果锁资源竞争不激烈，或者可以很快对锁进行释放获取（通过自旋锁就能解决的话），则不需要通过系统内核态让线程进行挂起、恢复状态，提升效率。</p><p>升级条件：锁竞争严重，超出限制（自旋时间或次数超时）</p><p>升级操作：</p><ul><li>撤销偏向锁，标记锁 00</li><li>线程生成 LockRecord 记录信息</li><li>线程通过CAS 将 LockRecord 记录信息更新到 markword 指针指向</li></ul><h3 id="重量锁"><a href="#重量锁" class="headerlink" title="重量锁"></a>重量锁</h3><p>如果以上锁都无法解决，则升级为重量锁，向系统申请资源对线程进行管理。</p><p>重量锁的每次资源获取都需要向系统申请资源，当线程挂起后，将进入等待系统资源申请成功信号，这时由用户态向内核态调度，当系统回复后，则切回用户态，这过程比较耗时。</p><h2 id="Synchronized（monitor-监控器）"><a href="#Synchronized（monitor-监控器）" class="headerlink" title="Synchronized（monitor 监控器）"></a>Synchronized（monitor 监控器）</h2><p>当方法中被标记该同步关键字，则在JVM常量池方法结构中对该方法的访问标记会增加 <code>ACC_SYNCHRONIZED</code> 标记，以区分该方法是否为同步方法。当开始执行时，会尝试让线程持有指定的monitor才能开始执行方法，当方法结束时则释放 monitor。</p><p>在字节码指令中，synchronized 会通过<code>monitorenter</code>、<code>monitorexit</code> 进行进入和释放行为。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Main &#123;</span><br><span class="line">    private static volatile int variable &#x3D; 0;</span><br><span class="line">    public static void main(String[] arg) throws InterruptedException &#123;</span><br><span class="line">        Main main &#x3D; new Main();</span><br><span class="line">        synchronized (main) &#123;</span><br><span class="line">            variable++;</span><br><span class="line">        &#125;</span><br><span class="line">        new Thread() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                super.run();</span><br><span class="line">                synchronized (main) &#123;</span><br><span class="line">                    variable++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释后main方法中字节码为：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31495/2CA0DEEB65AD4273804274CDEDF1AABE"  alt="image"></p><p>该指令即为对监视器锁的控制，在java中每个对象都关联着监视器锁，当线程尝试获取监视器时（monitor）将触发以下流程：</p><ul><li>检测monitor的计数器，如果为0则允许该线程获得monitor锁，并增加计数为1，该线程即为monitor的所有者。</li><li>如果不为0则检测monitor拥有者是否为该线程，如果是则进入重进入，monitor计数器继续累加。</li><li>如果检查到monitor的拥有者不是当前线程，则当前线程进入阻塞（用户态切换内核态），等待monitor计数器为0，则尝试重新获取锁。</li></ul><h2 id="其他锁"><a href="#其他锁" class="headerlink" title="其他锁"></a>其他锁</h2><h3 id="自旋锁、适应性自旋锁"><a href="#自旋锁、适应性自旋锁" class="headerlink" title="自旋锁、适应性自旋锁"></a>自旋锁、适应性自旋锁</h3><p>JVM的线程和系统线程通常是需要绑定的，对线程的挂起恢复都需要经过内核态，进行状态变化，这阶段比较消耗性能和时间。因此为了处理一些较为轻量的锁场景（比如锁等待只需要 10ns而挂起恢复线程需要 100ms 则不划算），产生的自旋锁。</p><p>自旋锁（JDK 1.4.2 开始支持）：也就是为了防止线程挂起进入内核态，将线程的执行停留在类似 <code>while(true)</code> 不断轮询的条件下，直到达到条件恢复或者挂起（称为自旋空转）。</p><p>自适应自旋（JDK 6 开始支持）：为了提升有效的自旋，在后期中对自旋锁固定尝试（默认为10次，可以通过JVM参数改变）改变为动态适应。在同一锁对象中，如果之前自旋成功获得锁，则默认系统在下次会认为容易获得成功，因此允许相对拉长自旋时间。如果自旋最近经常失败，则为了避免浪费资源，则可能会直接转为其他锁行为。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>线程获取锁后，是允许同一个线程再次对同一对象进行重复获取，如果没有改特性在很多情况下如果同一个线程获取同一个锁将导致死锁。</p><p>当获取一次锁后，锁对象头markwrok 中会记录锁持有者和获取成功的次数的计数器，每次累计为1，只有当释放相同次数的锁后才能对该对象的锁资源进行释放。</p><p>ReetrantLock 和 synchronized 都是可重入的</p><h3 id="乐观、悲观锁"><a href="#乐观、悲观锁" class="headerlink" title="乐观、悲观锁"></a>乐观、悲观锁</h3><p>这两种锁指的是对线程同步处理的不同方式。</p><ul><li>乐观锁：认为使用数据时数据不会发生修改，不进行锁的控制，当更新数据或者修改之前的数据时才会通过标记位或者CAS检查数据状态来决定是否需要更新。面向读场景多的情况，提升读取性能。</li><li>悲观锁：认为在使用数据期间数据可能会被其他线程修改，因此在对数据进行操作时，常用synchronized、Retee</li></ul><h3 id="独享、共享锁"><a href="#独享、共享锁" class="headerlink" title="独享、共享锁"></a>独享、共享锁</h3><ul><li><p>独享锁：锁一次只能被一个线程锁持有，其他线程无法对已锁对象进行加锁，可以进行数据读写。之前的 synchronized 即为独享锁</p></li><li><p>共享锁：如果线程对数据进行共享锁后，则其他线程只能对该对象添加共享锁，不能添加独享锁，获得共享锁的线程只能读取不能写入数据。相关技术为 AQS</p></li><li><h3 id="公平、非公平锁"><a href="#公平、非公平锁" class="headerlink" title="公平、非公平锁"></a>公平、非公平锁</h3></li><li><p>公平锁：即按照线程申请锁的顺序来获取锁</p><ul><li>优点：不会造成饥饿</li><li>缺定：吞吐率低处理效率低，除第一个线程外其他线程都需要被阻塞，CPU唤醒开销相对于非公平大，每次锁资源释放都需要唤醒所有线程，重新进入锁获取。</li></ul></li><li><p>非公平锁：多个线程会同时尝试获取锁，失败才进入等待，如果尝试获取时刚好锁处于可获取状态，则该线程直接越过之前的线程获得锁。</p><ul><li>优点：吞吐量高，不需要反复唤醒（减少挂起次数，如果刚好有锁资源，则刚好会给刚需要的还没进入挂起的线程资源），不必唤醒所有线程重新获取锁。</li><li>缺点：容易让等待久的线程更久，导致线程饿死，一直得不到运行的机会。</li></ul></li></ul><h2 id="锁工具-慢慢补充"><a href="#锁工具-慢慢补充" class="headerlink" title="锁工具(慢慢补充)"></a>锁工具(慢慢补充)</h2><h3 id="AbscractQueuedSynchronizer-AQS"><a href="#AbscractQueuedSynchronizer-AQS" class="headerlink" title="AbscractQueuedSynchronizer (AQS)"></a>AbscractQueuedSynchronizer (AQS)</h3><p>AQS是原理是将请求所有线程构建成一个CLH（ContentionList 基于自旋锁的双向链表，会对不断轮询前驱状态，如果发现前驱锁被释放，则结束当前线程自旋尝试去获得锁）队列，当一个线程节点执行完释放自身的锁时（lock.unlock()) 会激活后面的节点获取锁，如果正在执行的线程不再队列中，则等待执行的线程处于阻塞状态。</p><p>内部中通过一个int类型的成员变量state控制同步状态：</p><ul><li>当state=0时，则当前共享资源未被任何线程占用</li><li>当state=1时，则存在线程使用该共享资源</li></ul><p>如果没有被共享则直接获取到资源，如果有则其他线程机械能构建的队列中。</p><p>内部通过Condition进行相关控制调用：</p><ul><li>当执行 wait 则会将线程加入等待队列中</li><li>当执行 signal 则线程从等待队列中战役到同步队列中进行锁竞争</li><li>当执行 await 则进入等待队列</li></ul><p>这里面涉及两种队列同步队列和等待队列，</p><blockquote><p>当执行 await 会对锁资源进行释放，直到下次恢复（notify），将重新获得锁资源</p></blockquote><p>AQS实现了对多线程竞争的处理，但是对于锁需要继承它进行实现（比如 Sync），具体需要实现：</p><ul><li>独享锁：tryAcquire（被 acquire 调用）、tryRelease（被 release 调用）</li><li>共享锁：tryAcquireShared（被 tryAcquireShare 调用）、tryReleaseShared（被 releaseShared 调用）</li></ul><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 获取锁</span><br><span class="line"> public final void acquire(int arg) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查是否能获取锁，如果获取不到则添加到CLH队列中，并进入</span><br><span class="line">     &#x2F;&#x2F; 轮询自旋状态，在这过程中检查是否被 interrupt 中断</span><br><span class="line">     if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> private Node addWaiter(Node mode) &#123;</span><br><span class="line">     Node node &#x3D; new Node(mode);</span><br><span class="line">     &#x2F;&#x2F; 添加到 CLH 链表尾部，如果当前链表没产生则直接产生首尾节点</span><br><span class="line">     &#x2F;&#x2F; 直到添加成功</span><br><span class="line">     for (;;) &#123;</span><br><span class="line">         Node oldTail &#x3D; tail;</span><br><span class="line">         if (oldTail !&#x3D; null) &#123;</span><br><span class="line">             U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">             if (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                 oldTail.next &#x3D; node;</span><br><span class="line">                 return node;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             initializeSyncQueue();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;    </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 对所添加的节点node进行阻塞，如果在阻塞前能通过</span><br><span class="line"> &#x2F;&#x2F; tryAccquire获得锁则无需阻塞（非公平锁）</span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         boolean interrupted &#x3D; false;</span><br><span class="line">         &#x2F;&#x2F; 每次循环都是对锁检测和阻塞处理</span><br><span class="line">         </span><br><span class="line">         &#x2F;&#x2F; 等待过程检查是否需要进入显式阻塞（parkAndCheckInterrupt() &#x3D;&gt; sun.misc.Unsafe.park())</span><br><span class="line">         for (;;) &#123;</span><br><span class="line">             final Node p &#x3D; node.predecessor();</span><br><span class="line">             if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                 setHead(node);</span><br><span class="line">                 p.next &#x3D; null; &#x2F;&#x2F; help GC</span><br><span class="line">                 return interrupted;</span><br><span class="line">             &#125;</span><br><span class="line">             &#x2F;&#x2F; 先检查线程状态如果线程处于 </span><br><span class="line">             &#x2F;&#x2F; CANCEL状态则不需要阻塞，具体规则见 </span><br><span class="line">             &#x2F;&#x2F; shouldParkAfterFailedAcquire：</span><br><span class="line">             </span><br><span class="line">             if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                 parkAndCheckInterrupt())</span><br><span class="line">                 interrupted &#x3D; true;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (Throwable t) &#123;</span><br><span class="line">         cancelAcquire(node);</span><br><span class="line">         throw t;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> public final boolean release(int arg) &#123;</span><br><span class="line">     if (tryRelease(arg)) &#123;</span><br><span class="line">         Node h &#x3D; head;</span><br><span class="line">         if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)</span><br><span class="line">             unparkSuccessor(h);</span><br><span class="line">         return true;</span><br><span class="line">     &#125;</span><br><span class="line">     return false;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 锁释放后，从队列尾部向上找到一个状态可用的线程，找到后</span><br><span class="line"> &#x2F;&#x2F; 通知内核处理该线程 LockSupport.unpark</span><br><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line"></span><br><span class="line">     int ws &#x3D; node.waitStatus;</span><br><span class="line">     if (ws &lt; 0)</span><br><span class="line">         node.compareAndSetWaitStatus(ws, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     Node s &#x3D; node.next;</span><br><span class="line">     if (s &#x3D;&#x3D; null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">         s &#x3D; null;</span><br><span class="line">         for (Node p &#x3D; tail; p !&#x3D; node &amp;&amp; p !&#x3D; null; p &#x3D; p.prev)</span><br><span class="line">             if (p.waitStatus &lt;&#x3D; 0)</span><br><span class="line">                 s &#x3D; p;</span><br><span class="line">     &#125;</span><br><span class="line">     if (s !&#x3D; null)</span><br><span class="line">         LockSupport.unpark(s.thread);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面对于锁的获取是非公平的处理，当有线程进行竞争时，会优先让该线程进行锁获取尝试，如果不行才将线程追加到等待队列队尾（CLH链表队列）</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS 是一种乐观锁，主要围绕 内存值（V）、将要更新值（B）、预期值（A）进行 比较、交换、更新等操作，这些操作都会在底层保证的原子性下执行。在并发过程中的CAS，如果不满足条件会导致另一个线程写入或更新是失败的。</p><p>具体提供的方法有：</p><ul><li>compareAndSwapIn(Object o, long offset, int execpted, int x)<br>映射的JNI 方法是 ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123;</span><br><span class="line">  int mp &#x3D; os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx, dest</span><br><span class="line">    mov ecx, exchange_value</span><br><span class="line">    mov eax, compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx], ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过底层指令 <code>cmpxchg</code> 和 <code>lock</code> 进行保证。<br>lock 前缀会将该指令之前和之后的读写指令进行重拍，并且对于写缓冲区的所有数据都会直接刷新到总内存中（原子性）。</p><blockquote><p>如果为多核CPU <code>LOCK_IF_MP</code> 则提供 lock 前缀的内存屏障，如果单核则不需要。lock 前缀会在执行期间将总线锁住，从而保证其他处理器无法访问总线内存，这称为总线锁，后期有的cpu做了优化，避免总线资源过度消耗，比如 奔腾系列的 缓存锁定，并不对总线进行锁定，在满足条件后仅对缓存行的内存区域进度独占，但是如果竞争剧烈或者内存地址未对其，则还是会降级为总线锁定</p></blockquote><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><p>CAS 典型引发的问题，CAS目的是根据值的不同判断是否为旧值进行更新，但是如果 线程1 和线程2同时进行时，如果1、2 都从 内存值V中获得到 V，当 线程1经过一段时间计算，将计算值 B 更新到内存中，在之后线程1又经过计算 得到新值V更新到 内存中。造成一系列的更新又将内存恢复到之前的状态值，如果这时候线程2 进行对比更新操作，会发现 V 值和预期值一致，于是将更新内存值为另外一个 C 值。 那么这个将产生问题。</p><p>这例子中主要是希望如果线程1当内存值发生更新后，不希望线程2进行更新，但是由于 线程1更新的前后内存值未发生变化，导致线程2认为线程1没有发生变化。</p><h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p>JSE 5.0 后增加的锁接口，实现了比 synchronzed 关键字更加粒度小的锁控制，可显示进行锁获取和释放（synchronzed 为隐式，自动对锁进行获取和释放）。</p><p>几个关键方法：</p><ul><li>lock() : 获得锁，如果当锁不可用，会导致线程休眠，直到获得锁</li><li>lockInterruptibly() : 线程如果未发生中断，则获取锁。当线程发生中断或者锁被其他线程占用则进入休眠，在该线程在获取锁过程中可响应中断操作</li><li>newCondition(): Condition ：获取Condition，用于该线程的操作</li><li>unlock() : 释放该线程持有的锁</li><li>tryLock() : boolean :  尝试获取锁成功则返回true，不会进入休眠等待</li><li>tryLock(long time, TimeUnit unit): boolean : 在指定时间内获取锁，成功返回true</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>重入锁 ReentrantLock 是 Lock 锁的实现，支持对锁更精确化的控制。它是基于AQS开发而成，包含 Sync（实现AQS）、NoFairSync（非公平锁,实现自 Sync）、FairSync（公平锁，实现自Sync）的实现（继承于AQS的锁），重新实现了AQS的<br>tryRelease、tryAcquire、tryReleaseShared 等方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock()</span><br><span class="line">lock.lock() &#x2F;&#x2F; 锁获取</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock() &#x2F;&#x2F; 一定要放到 finally 保证锁与解锁的一致性，否则线程得不到释放，造成死锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>用于对共享资源的读和写操作，通常用于读取操作频繁，写操作较为低频的情况，能极大提供读取效率。内部通过维护两种锁机制来保证读写不受干扰：</p><ul><li>读取：共享锁，允许多个线程对共享资源同时进行读取</li><li>写入：独占锁（排他锁），只允许一个线程在同时进行写入操作</li></ul><p>读写锁支持特性有：</p><ul><li>公平性选择（公平与非公平）</li><li>重入锁</li><li>锁降级 写锁可以降级为读锁、并且由于多个锁锁定，会保证锁的获取、释放顺序（防止死锁）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;同步性的要求一般是围绕着 有序性和可见性进行，即使是锁也是为了辅助其目的进行。&lt;/p&gt;
&lt;h1 id=&quot;多核心多线程&quot;&gt;&lt;a href=&quot;#多核心多线程&quot; class=&quot;headerlink&quot; title=&quot;多核心多线程&quot;&gt;&lt;/a&gt;多核心多线程&lt;/h1&gt;&lt;p&gt;任何机器上的执
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Gradle配置Kotlin环境</title>
    <link href="http://yoursite.com/2018/05/24/Gradle%E9%85%8D%E7%BD%AEKotlin%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/05/24/Gradle%E9%85%8D%E7%BD%AEKotlin%E7%8E%AF%E5%A2%83/</id>
    <published>2018-05-24T12:47:07.000Z</published>
    <updated>2020-04-10T12:49:31.082Z</updated>
    
    <content type="html"><![CDATA[<p>在最新的Android Studio 上已经提供了默认的Kotlin工程的模板，但是这些简单的配置远不能满足一个复杂项目的构建要求，因此这里重新做下整理，搬运下Kotlin官方的内容。</p><h2 id="一、基本Kotlin环境配置"><a href="#一、基本Kotlin环境配置" class="headerlink" title="一、基本Kotlin环境配置"></a>一、基本Kotlin环境配置</h2><h3 id="Import-Plugin"><a href="#Import-Plugin" class="headerlink" title="Import Plugin"></a>Import Plugin</h3><p>1.如果Gradle 版本在2.1前可以使用以下引入方式。</p><p>1.1 在脚本文件下添加外部Gradle插件依赖引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    ext.kotlin_version &#x3D; &#39;1.2.61&#39;</span><br><span class="line"></span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>1.2 应用Gradle Kotlin插件</p><p>在需要引入项目（可能你是多项目构建，模块）构建脚本下引入插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &quot;kotlin&quot;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>2.如果Gradle版为2.1或以上，则可以在对应需要引入的构建脚本下方便的使用<code>plugins {}</code>脚本块进行快速引入（不需要再<code>buildscript</code>中声名引入了）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">      id &quot;org.jetbrains.kotlin.jvm&quot; version &quot;1.2.61&quot; &#x2F;&#x2F; 使用社区插件（非内置核心插件）方式引入，需要指定版本</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p><code>plugins {}</code>默认是指向Gradle自己的<code>https://plugins.gradle.org/m2</code>仓库，实测了下，maven依赖并不全，有时候会发现 not find 些依赖库。</p><p>解决这个问题可以在 <code>settings.gradle</code> 可以对 仓库地址进行配置下。(发现gralde插件还是会在一些比较老的仓库发布，作为备用，可以调整配置下)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pluginManagement &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">        gradlePluginPortal()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h3 id="Set-Source"><a href="#Set-Source" class="headerlink" title="Set Source"></a>Set Source</h3><p>Kotlin 插件默认将 <code>src / main / kotlin /</code>和 <code>src / main / java /</code> 作为 <code>srcDirs</code>路径</p><p>如果项目对默认路径做了调整，需要重新设置该信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sourceSets &#123;</span><br><span class="line">    main.kotlin.srcDirs +&#x3D; &#39;src&#x2F;main&#x2F;自己的目录&#39; &#x2F;&#x2F; 让 kotlin 知道哪些目录是存在kotlin代码源文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>在 Android Studio 中，还需要额外将kotlin目录添加到 <code>main.java.srcDirs</code>中，以让IDE能正确识别这些目录为源目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  sourceSets &#123;</span><br><span class="line">    main.java.srcDirs +&#x3D; &#39;src&#x2F;main&#x2F;kotlin&#39; &#x2F;&#x2F; 让 Android Studio 知道这些目录是存在代码文件的，自动识别，产生一些IDE的效果</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="二、标准库支持"><a href="#二、标准库支持" class="headerlink" title="二、标准库支持"></a>二、标准库支持</h2><p>在满足构建环境后，我们还需要配置一些在生产环境下，Kotlin代码需要使用的标准函数库，这里在对应的项目下引入标准库即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile &quot;org.jetbrains.kotlin:kotlin-stdlib&quot;</span><br><span class="line">    &#x2F;&#x2F; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7&quot; &#x2F;&#x2F; 如果仅需要支持 JDK7的话，直接使用这个</span><br><span class="line">    &#x2F;&#x2F; compile &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk8&quot; &#x2F;&#x2F; 如果仅需要支持 JDK8版本的话</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>关于其他的Kotlin库的支持，可以参照</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;kotlinlang.org&#x2F;docs&#x2F;reference&#x2F;using-gradle.html#configuring-dependencies</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="三、APT支持"><a href="#三、APT支持" class="headerlink" title="三、APT支持"></a>三、APT支持</h2><p>在 Android 插件中，官方已经支持APT了。但是加入 Kotlin 后，由于Kotlin构建环节和Java 有些微妙的变化，因此需要重建这个流程的构建，因此Kotlin为我们提供了另外的插件支持。</p><h3 id="引入插件"><a href="#引入插件" class="headerlink" title="引入插件"></a>引入插件</h3><p>和Kotlin插件引入类似，可以通过引入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#39;kotlin-kapt&#39;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id &quot;org.jetbrains.kotlin.kapt&quot; version &quot;1.2.61&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>在本来使用 <code>annotationProcessor</code>依赖方式的依赖上，改为 <code>kapt</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    kapt &#39;groupId:artifactId:version&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>kapt 不仅仅是会处理 kotlin 的内容，同时也可以处理 java 代码中的内容。</p><h3 id="变量配置"><a href="#变量配置" class="headerlink" title="变量配置"></a>变量配置</h3><p>Kotlin 提供了另外一个配置变量，对APT插件进行配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kapt &#123;</span><br><span class="line">    &#x2F;&#x2F; apt变量注入</span><br><span class="line">    arguments &#123;</span><br><span class="line">        arg(&quot;key&quot;, &quot;value&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; javac 编译环境配置</span><br><span class="line">    javacOptions &#123;</span><br><span class="line">        &#x2F;&#x2F; Increase the max count of errors from annotation processors.</span><br><span class="line">        &#x2F;&#x2F; Default is 100.</span><br><span class="line">        option(&quot;-Xmaxerrs&quot;, 500)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>注意： kotlint apt 支持生成Kotlin源文件，生成的源文件默认在 <code>processingEnv.options[&quot;kapt.kotlin.generated&quot;]</code>路径下，在最终编译时，将会把这个目录下的源文件进行编译。</p><h2 id="四、增量编译支持"><a href="#四、增量编译支持" class="headerlink" title="四、增量编译支持"></a>四、增量编译支持</h2><p>Kotlin 支持增量编译，可以通过 <code>gradle.properties</code> 进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kotlin.incremental&#x3D;true &#x2F;&#x2F; 开启增量，否则 false</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><p>或者对 <code>local.properties</code> 进行命令行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Pkotlin.incremental&#x3D;true</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p><h2 id="五、协程支持"><a href="#五、协程支持" class="headerlink" title="五、协程支持"></a>五、协程支持</h2><p>协程是Kotlin实验性特性，如果需要使用该特性，对kotlin变量进行配置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kotlin &#123;</span><br><span class="line">    experimental &#123;</span><br><span class="line">        coroutines &#39;enable&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  alt="点击并拖拽以移动"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在最新的Android Studio 上已经提供了默认的Kotlin工程的模板，但是这些简单的配置远不能满足一个复杂项目的构建要求，因此这里重新做下整理，搬运下Kotlin官方的内容。&lt;/p&gt;
&lt;h2 id=&quot;一、基本Kotlin环境配置&quot;&gt;&lt;a href=&quot;#一、基本Ko
      
    
    </summary>
    
    
      <category term="Kotlin" scheme="http://yoursite.com/categories/Kotlin/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
      <category term="Kotlin" scheme="http://yoursite.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Groovy与Java差异简记</title>
    <link href="http://yoursite.com/2018/05/20/Groovy%E4%B8%8EJava%E5%B7%AE%E5%BC%82%E7%AE%80%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/05/20/Groovy%E4%B8%8EJava%E5%B7%AE%E5%BC%82%E7%AE%80%E8%AE%B0/</id>
    <published>2018-05-20T13:48:47.000Z</published>
    <updated>2020-04-10T12:50:53.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>Groovy 支持运算符重载，和python 一样，重载对应的方法即可实现对应运算符功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Example&#123;</span><br><span class="line">    String msg &#x3D; &quot;default&quot;</span><br><span class="line"></span><br><span class="line">    Example(String msg)&#123;</span><br><span class="line">        this.msg &#x3D; msg</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Example plus(Example example)&#123;</span><br><span class="line">        msg +&#x3D; example.msg</span><br><span class="line">        return this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void main(String[] args)&#123;</span><br><span class="line">        Example exampleA  &#x3D; new Example(&quot;A&quot;)</span><br><span class="line">        Example exampleB &#x3D; new Example(&quot;B&quot;)</span><br><span class="line"></span><br><span class="line">        println((exampleA + exampleB).getMsg())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AB</span><br></pre></td></tr></table></figure><p>以上例子中 <code>+</code>的功能实现方法对应于 <code>plus</code>，因此重写了该方法，等同于实现了<code>+</code>的功能实现</p><h2 id="安全操作"><a href="#安全操作" class="headerlink" title="?.安全操作"></a>?.安全操作</h2><p>这个和Kotlin一样，使用<code>?.</code>调用操作，会在对象调用前，检查该对象是否为null，如果为null，则不进行调用操作，如果有返回值，则返回null</p><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def getMessage()&#123;</span><br><span class="line">    return &quot;Hello!!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    println(&quot;getMessage 1 : $&#123;example?.getMessage()&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    example &#x3D; null</span><br><span class="line"></span><br><span class="line">    println(&quot;getMessage 2 : $&#123;example?.getMessage()&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getMessage 1 : Hello!!</span><br><span class="line">getMessage 2 : null</span><br></pre></td></tr></table></figure><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>方法默认参数相对于其他语言已经比较熟悉，Groovy同样也支持。 Groovy 默认参数不局限仅能在末尾参数或者连续到末尾参数才能作为默认参数，它可以将中间参数作为默认参数</p><h3 id="使用例子-1"><a href="#使用例子-1" class="headerlink" title="使用例子"></a>使用例子</h3><p>情况1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def getArray(String a, String b &#x3D; &quot;obj b&quot;, String c, String d) &#123;</span><br><span class="line">    return [a, b, c, d]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    String a</span><br><span class="line">    String b</span><br><span class="line">    String c</span><br><span class="line">    String d</span><br><span class="line"></span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    (a, b, c, d) &#x3D; example.getArray(&quot;obj a&quot;, &quot;obj c&quot;, &quot;obj d&quot;)</span><br><span class="line"></span><br><span class="line">    println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;, c -&gt; $&#123;c&#125;, d -&gt; $&#123;d&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; obj a, b -&gt; obj b, c -&gt; obj c, d -&gt; obj d</span><br></pre></td></tr></table></figure><p>以上方法中，仅有b参数存在默认参数，而调用<code>getArray</code>方法仅提供三个参数，Groovy对于不满足默认方法签名的函数调用，会优先匹配到没有提供默认参数的参数上，因此这里<code>obj a</code>、<code>obj c</code>、<code>obj d</code>分别对应于 a、c、d 参数，而 b 则使用默认的参数 <code>obj b</code></p><p>情况2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def getArray(String a, String b &#x3D; &quot;obj b&quot;, String c, String d &#x3D; &quot;obj d&quot;) &#123;</span><br><span class="line">    return [a, b, c, d]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    String a</span><br><span class="line">    String b</span><br><span class="line">    String c</span><br><span class="line">    String d</span><br><span class="line"></span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    (a, b, c, d) &#x3D; example.getArray(&quot;obj a&quot;, &quot;obj b&quot;, &quot;obj c&quot;)</span><br><span class="line"></span><br><span class="line">    println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;, c -&gt; $&#123;c&#125;, d -&gt; $&#123;d&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; obj a, b -&gt; obj b, c -&gt; obj c, d -&gt; obj d</span><br></pre></td></tr></table></figure><p>情况3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def getArray(String a, String b &#x3D; &quot;obj b&quot;, String c &#x3D; &quot;obj c&quot;, String d, String e &#x3D; &quot;obj e&quot;, String f &#x3D; &quot;obj f&quot;, String g)&#123;</span><br><span class="line">    return [a, b, c, d, e, f, g]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    String a</span><br><span class="line">    String b</span><br><span class="line">    String c</span><br><span class="line">    String d</span><br><span class="line">    String e</span><br><span class="line">    String f</span><br><span class="line">    String g</span><br><span class="line"></span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    (a, b, c, d, e, f, g) &#x3D; example.getArray(&quot;obj a&quot;, &quot;obj d&quot;, &quot;obj d&quot;, &quot;obj g&quot;)</span><br><span class="line"></span><br><span class="line">    println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;, c -&gt; $&#123;c&#125;, d -&gt; $&#123;d&#125;, e -&gt; $&#123;e&#125;, f -&gt; $&#123;f&#125;, g -&gt; $&#123;g&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; obj a, b -&gt; obj d, c -&gt; obj c, d -&gt; obj d, e -&gt; obj e, f -&gt; obj f, g -&gt; obj g</span><br></pre></td></tr></table></figure><p>以上三个用例可以知道，当方法提供的调用参数不能满足方法所有参数数量时，会优先补足必须参数的参数值，后再对多出来的调用参数，按照已提供默认参数的参数顺序，进行赋值，覆盖默认参数的参数值。</p><h2 id="多赋值"><a href="#多赋值" class="headerlink" title="多赋值"></a>多赋值</h2><p>多赋值是对数据的”拆包”行为，在接收者们上需要使用<code>()</code>小括号，对需要“拆包”分别赋值对象进“打包”</p><h3 id="多赋值使用举例"><a href="#多赋值使用举例" class="headerlink" title="多赋值使用举例"></a>多赋值使用举例</h3><p>交换变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void main(String[] args) &#123;</span><br><span class="line">     String a &#x3D; &quot;obj a&quot;</span><br><span class="line">     String b &#x3D; &quot;obj b&quot;</span><br><span class="line"></span><br><span class="line">     (a, b) &#x3D; [b, a]</span><br><span class="line"></span><br><span class="line">     println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;&quot;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; obj b, b -&gt; obj a</span><br></pre></td></tr></table></figure><p>方法返回多结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def getArray() &#123;</span><br><span class="line">    return [&#39;element a&#39;,&#39;element b&#39;,&#39;element c&#39;,&#39;element d&#39;,&#39;element e&#39;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void main(String[] args)&#123;</span><br><span class="line">    Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">    def (a,b,c) &#x3D; example.getArray()</span><br><span class="line"></span><br><span class="line">    println(&quot;a -&gt; $&#123;a&#125;, b -&gt; $&#123;b&#125;, c -&gt; $&#123;c&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; element a, b -&gt; element b, c -&gt; element c</span><br></pre></td></tr></table></figure><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><ul><li>接受者可以与数组对象数量不一致，如果接受者 &gt; 数组对象，则多出的对象将为null，即使之前有对象，也会被重新置为 null；如果接受者 &lt; 数组对象，则只会接收数组前几个对应的对象内容。</li><li>被“拆包”对象，可以为数组、List</li></ul><h2 id="方法调用括号可选"><a href="#方法调用括号可选" class="headerlink" title="方法调用括号可选"></a>方法调用括号可选</h2><p>当方法调用时，存在至少一个参数，可以省略括号</p><h2 id="set与get"><a href="#set与get" class="headerlink" title="set与get"></a>set与get</h2><p>和 Kotlin 一样，Groovy会自动对下面public的属性进行get和set方法的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Example&#123;</span><br><span class="line">    String msg &#x3D; &quot;default&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static void main(String[] args)&#123;</span><br><span class="line">        Example example &#x3D; new Example()</span><br><span class="line"></span><br><span class="line">        println(example.msg)</span><br><span class="line"></span><br><span class="line">        example.setMsg(&quot;set msg&quot;)</span><br><span class="line"></span><br><span class="line">        println(example.msg)</span><br><span class="line"></span><br><span class="line">        println(example.getMsg())</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line">set msg</span><br><span class="line">set msg</span><br></pre></td></tr></table></figure><p>当然，set、get方法也可以被重写</p><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>特征有点类似于接口的扩张，特征可以进行方法实现，属性定义，并且类可以多继承特征。 特征用 trait 作为关键词，在使用它时，和接口一样使用<code>implements</code>进行实现，在其他的特征中继承扩展特征时，使用<code>extends</code>进行继承扩展（基本使用上和接口一样）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    C c &#x3D; new C()</span><br><span class="line"></span><br><span class="line">    println(c.getMsg())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface X&#123;</span><br><span class="line">    String getMsg();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait A implements X&#123;</span><br><span class="line">    String getMsg()&#123;</span><br><span class="line">        return &quot;A&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait B implements X&#123;</span><br><span class="line">    String getMsg()&#123;</span><br><span class="line">        &quot;B&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static class C implements B,A&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><h3 id="Tip-1"><a href="#Tip-1" class="headerlink" title="Tip"></a>Tip</h3><ul><li>如果在多继承中存在方法冲突，则后继承的内容会覆盖前面的（包括属性和方法）。</li></ul><h2 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h2><p>Groovy允许在方法调用的时候，省略括号</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;运算符重载&quot;&gt;&lt;a href=&quot;#运算符重载&quot; class=&quot;headerlink&quot; title=&quot;运算符重载&quot;&gt;&lt;/a&gt;运算符重载&lt;/h2&gt;&lt;p&gt;Groovy 支持运算符重载，和python 一样，重载对应的方法即可实现对应运算符功能。&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://yoursite.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://yoursite.com/tags/Gradle/"/>
    
      <category term="Groovy" scheme="http://yoursite.com/tags/Groovy/"/>
    
  </entry>
  
  <entry>
    <title>Java-汇编调试</title>
    <link href="http://yoursite.com/2018/05/16/Java-%E6%B1%87%E7%BC%96%E8%B0%83%E8%AF%95/"/>
    <id>http://yoursite.com/2018/05/16/Java-%E6%B1%87%E7%BC%96%E8%B0%83%E8%AF%95/</id>
    <published>2018-05-16T13:28:18.000Z</published>
    <updated>2020-04-27T08:38:20.371Z</updated>
    
    <content type="html"><![CDATA[<ul><li><h1 id="通过日志工具学习"><a href="#通过日志工具学习" class="headerlink" title="通过日志工具学习"></a>通过日志工具学习</h1><p>为了方便研究一些Java 特殊操作在底层的实际实现，不免要对Java程序实际的转化的汇编结果指令进行查看。</p><p>需要注意的是 Java 为我们生成的class文件，只是一层JVM可理解的执行指令，并不是机器所需的汇编码，只有当虚拟机运行期间才会对执行的指令进行汇编转化，<br>因此在此之前，需要对虚拟机进行一定的配置。</p></li></ul><ul><li><p>下载lib库 <code>https://github.com/bevis0/hsdis/blob/master/macOS/hsdis-amd64.dylib</code></p></li><li><p>将库添加到所使用的 JRE目录 /lib 下</p></li><li><p>在执行虚拟机添加执行参数 <code>-XX:+UnlockDiagnosticVMOptions  -XX:+PrintAssembly</code></p><p>执行配置允许后将控制台输出</p><p><img src="/" class="lazyload" data-src="https://note.youdao.com/src/32A7E11C3942474D9FE6E2449B0E088B"  alt="image"></p><p>相关汇编信息，该方案是基于JIT执行后得到结果</p></li></ul><h1 id="Jitwatch-学习字节码-汇编"><a href="#Jitwatch-学习字节码-汇编" class="headerlink" title="Jitwatch 学习字节码/汇编"></a>Jitwatch 学习字节码/汇编</h1><p>  下载项目<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;AdoptOpenJDK&#x2F;jitwatch</span><br></pre></td></tr></table></figure><br>  进入文件夹后执行<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;gradlew clean build run</span><br></pre></td></tr></table></figure></p><p>  后会启动控台页面</p><p>  <img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31322/59F3A90CD38A4DF4B114039B2FF7EE9A"  alt="image"></p><h2 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h2><p>  sandbox 可以在沙盒中添加代码，编译并查看JIT结果<br>  <img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31326/93D26F7E0B884763A73C565D994DD6CD"  alt="image"></p><p>  完成编码后执行run即可看到结果</p><p>  <img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31331/B880E800B9D84EF2BABFE623549C2BDB"  alt="image"></p><h2 id="openLog"><a href="#openLog" class="headerlink" title="openLog"></a>openLog</h2><p>  openLog 是对java执行log的分析，需要在Jvm 启动参数上添加<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading  -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile&#x3D;[输出路径&#x2F;文件名].log</span><br></pre></td></tr></table></figure></p><p>  LogFile 参数添加自己的log文件输出地址目标。</p><p>  执行编译执行后，会生成文件，后通过 openLog 打开该文件。</p><p>  点击 <code>config</code> 配置文件的路径和输出路径</p><p>  <img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31341/D1C4D016387641DD836E865B81CE74C7"  alt="image"></p><ul><li><p>source locations 为源码文件位置</p></li><li><p>class locations 为 javac编译后.class 文件路径</p><p>点击绿色已经编译成功类</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31346/723AF309355C4C7790E738C59C156313"  alt="image"></p><p>可以展开代码对应想详细信息</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/31344/21DE5A8D0034470B9902503A44DB6D6C"  alt="image"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;h1 id=&quot;通过日志工具学习&quot;&gt;&lt;a href=&quot;#通过日志工具学习&quot; class=&quot;headerlink&quot; title=&quot;通过日志工具学习&quot;&gt;&lt;/a&gt;通过日志工具学习&lt;/h1&gt;&lt;p&gt;为了方便研究一些Java 特殊操作在底层的实际实现，不免要对Java程序实
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM了解</title>
    <link href="http://yoursite.com/2018/05/15/JVM%E4%BA%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/15/JVM%E4%BA%86%E8%A7%A3/</id>
    <published>2018-05-15T13:28:18.000Z</published>
    <updated>2020-04-10T13:34:01.388Z</updated>
    
    <content type="html"><![CDATA[<p>对于程序，我们不仅需要了解开发时所需要的内容，还需要了解程序运行时的环境状态，这样可以方便我们对整个运行环境的掌控和开发。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24858/8FE2DDF94CCF45268EEC5290A0690FF1"  alt="image"></p><p>当我们通过javac 对所需要的源码编译后，便可以通过java虚拟机启动我们所编译的程序。</p><p>而后静态的二级制代码开始进入机器运行时内存中，通过执行引擎执行我们所提供的二进制指令。</p><p>在这流程中，我们需了解：</p><ol><li>编译后二进制代码怎么加载进入虚拟机运行时环境中。</li><li>对于加载后的代码虚拟机是怎么进行维护</li><li>对于运行过程中所产生的垃圾内存（已经需要被销毁的过期对象）怎么进行跟踪处理。</li></ol><h1 id="一、类加载"><a href="#一、类加载" class="headerlink" title="一、类加载"></a>一、类加载</h1><p>当虚拟机开始运行，虚拟机需要将我们所编译后的代码信息，通过类加载器（ClassLoader）加载到虚拟机运行时环境中。</p><p>在这里我们不从虚拟机执行代码角度上看，先从JVM运行逻辑上理解。根据二进制代码数据来源，JVM提供了不同的加载器。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24802/3DC5E3E8310643D28893372D7B07B2E2"  alt="image"></p><ul><li>Bootstrap ClassLoader <code>启动类加载器，负责对JDK/jre/lib 标准的运行时库进行加载。</code></li><li>ExtClassLoader <code>扩展类加载器，负责对JDK/jre/lib/ext 下扩展库进行加载</code></li><li>AppClassLoader <code>应用类加载器 负责对用户指定的 ClassPath 路径下的类进行加载，可以通过环境变量进行配置，用于运行库的扩展</code></li><li>UserClassLoader <code>用户自定义加载器 用户通过继承ClassLoader对自己所需要加载的库进行最后的加载扩展</code></li></ul><h2 id="双亲委托"><a href="#双亲委托" class="headerlink" title="双亲委托"></a>双亲委托</h2><p>为了类加载的安全性和避免重复加载，Java 提供了双亲机制，每一个ClassLoader 都存在一个父类加载器的引用，当一个ClassLoader需要加载某个类时，它将在自己搜索前先去询问它的父类加载器索引进行查询加载，依次类推直至找到最顶层的ClassLoader，当父类没有加载到则交由下级类去加载，如果最终没加载到则会抛出 ClassNotFoundExceptin 异常。对于一个类的加载需要依次根据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bootstrap ClassLoader -&gt; ExtClassLoader -&gt; AppClassLoader -&gt; UserClassLoader</span><br></pre></td></tr></table></figure><p>的解析顺序。</p><p>如果在加载链中被父加载器所加载，则该类的不会被其他类加载器加载，以防止重复加载或者恶意加载等问题。</p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同一个类也可以强制被不同的类加载器所加载，但是在JVM中并不会认为是同一个类。</span><br></pre></td></tr></table></figure><h2 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h2><p>以上流程是对整个大流程进行描述，但是对于二进制数据怎么映射为内存数据并未描述清楚。这里我们描述下理论上逻辑。</p><p>在主动使用加载过程中，主要经历几个流程：</p><ul><li>加载 <code>将外部Class文件二进制流加载到虚拟机方法区下，转化为运行时数据结构，并生成该类所引用的java.lang.Class对象，作为在方法区该类的数据访问入口。数组类由虚拟机直接创建，不通过类加载器创建</code></li><li>连接 <code>连接分为验证、准备、解析，对二进制数据进行内存结构化</code><ul><li>验证 <code>主要对class二进制文件规范进行校验，确保加载的正确性，主要包括 文件格式验证、元数据验证、字节码验证、符号引用验证</code> </li><li>准备 <code>为类静态变量信息进行内存分配，开辟空间并初始化内存为0值</code></li><li>解析 <code>解析类、接口、字段、类方法、接口方法（私有）、方法类型、方法句柄，符号引用转化为直接引用，直接执行指针地址</code></li></ul></li><li>初始化 <code>为所使用的类等信息进行构造、初始化等操作（static），生成类构造器&lt;clinit&gt;()方法，合并类static变量和语句块，执行&lt;clinit&gt;()方法</code></li></ul><p>对于类加载信息，在hotspot虚拟机中将放置于方法区中（JVM规范没有规定具体存放位置。</p><p>除了主动使用情况外，还存在被动使用情况，这不会触发<code>初始化</code>行为。</p><p>比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public final  static String str &#x3D; &quot;A&quot;;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(A.str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>A.str</code> 的调用仅触发加载和连接。由于所调用的字符串常量，在编译阶段以在常量池中，因此不需要对变量进行初始化。</p><h1 id="二、运行时内存结构"><a href="#二、运行时内存结构" class="headerlink" title="二、运行时内存结构"></a>二、运行时内存结构</h1><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24835/47BC61AD09484979BCD5FC76A23A8509"  alt="image"></p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区主要负责长期使用的一些信息：</p><ul><li>常量池</li><li>构造方法</li><li>全局变量</li><li>代码指令</li><li>类信息（类名、修饰符、字段描述、方法描述等）</li><li>JIT编译后的代码</li><li>反射动态生成的Class信息</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="/" class="lazyload" data-src="https://note.youdao.com/src/7D09DE78B3DB4A7AACD4E9C5BD2A8F04"  alt="image"></p><p>堆区域是Java虚拟机中所管理最大的区域，同时也是垃圾回收器主要回收的目标。</p><p>为了方便进行回收，在分代回收算法中，虚拟机对堆又进行了分配，主要包括：</p><ol><li>新生代（年轻代）中 from Survivor、to Survivor、eden 区域其中各比例 1 : 1 : 8。负责周期短的对象</li><li>老年代</li><li>以及在方法区中的永生代</li></ol><h2 id="虚拟机栈（线程私有）"><a href="#虚拟机栈（线程私有）" class="headerlink" title="虚拟机栈（线程私有）"></a>虚拟机栈（线程私有）</h2><p>栈内存是线程私有，生命周期和线程一致。</p><ol><li>栈帧（会有多个栈帧，每个方法将产生一个栈帧）</li><li>局部变量表</li><li>操作数栈</li><li>方法返回值<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2></li></ol><p>和虚拟机栈差不都，用于C/C++层执行</p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>也是线程私有，用于保存当前线程执行的内存地址，方便在多线程间的切换，状态恢复</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>除此之外在JDK1.4后还存在<code>直接内存</code>区域，该区域独立于堆外，可以直接操作内核态（由于需要内核空间支持，因此分配成本也大），如果需要频繁访问IO，可以减少堆外内存复制到内存内容进行磁盘的操作，另外扩大了JVM内存，目前可以通过NIO中DirectByteBuffer直接进行分配 </p><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>在Java 中线程是虚拟机运行的基础执行单位，在同一时间允许运行多线程执行（不考虑时间片）。为了应对多线程共享数据行为，Java使用了<code>JMM</code>控制多线程通信。</p><p>基于此在原内存模式上，又可以分为主内存和工作内存。之前<code>堆</code>、<code>程序计数器</code>、<code>方法区</code>内存区域属于主内存，而在<code>栈</code>中的栈帧结构属于线程私有的工作内存。</p><p>。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24894/9D552B0BC4714C1A9B5FFE77C2A4A86D"  alt="image"></p><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>为了便于理解Java的多线程特点，我们需要从底层上去理解这种工作模式的起源。</p><p>在现代的多核CPU执行速度上，是远高于内存、存储等IO设备的处理速率，为了缓和这种速度差矛盾，CPU上引入高速缓存（仅对单CPU核可见），方便将数据结果放到缓存中，以被后续被该CPU核调用，这造成主内存和CPU缓存间隔。由于每个CPU都存在仅自身可见的缓存，这就极易造成当其中单个变量发生变化时，对于其他CPU的缓存无法得到及时的更新，造成脏数据。</p><p>因此为了解决这种矛盾，官方提出了 缓存一致性协议，对于这类协议有 MESI、MSI、MOSI等。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/24925/560288F7626F428BAC6EB8D90F958699"  alt="image"></p><p>因此在之后CPU执行计算的流程：</p><ul><li>程序和数据加载到主内存</li><li>指令或数据被加载到CPU高速缓存</li><li>CPU执行指令并将结果写入高速缓存</li><li>高速缓存中的数据写回主内存</li></ul><p>在每次高速缓存和主内存的交互中，都需要借助缓存一致性操作进行更新读取（加载赋值写回）。</p><p>在以上的一致性的基础上，解决了数据对其他CPU可见性问题，但是多线程的处理还涉及到工作流程的问题，相同的执行流程下，不同的执行顺序会导致不同结果。</p><h3 id="JMM控制"><a href="#JMM控制" class="headerlink" title="JMM控制"></a>JMM控制</h3><p>基于Java 工作内存和主内存的CPU一样的结构。Java使用JMM控制两者之间的交互。</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25218/WEBRESOURCEa083a188f4c3cfc6a69c09495c9fc466"  alt="image.png"></p><p>本例中，线程A和B共享变量X，当线程A和B进行通信时，线程A将变量X从工作内存刷新到主内存中X，通过JMM通知线程B刷新变量X，线程B到主内存中读取变量X更新到工作内存中。两者的通信实质是通过JMM控制主内存和每个线程工作内存之间的交互，保证内存可见性。</p><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><p>在JMM中提供了8个操作来实现同步细节，这里面涉及三个操作角色。</p><p><code>主内存 &lt;-&gt; 工作内存 &lt;-&gt; 执行引擎</code></p><table><thead><tr><th>操作名</th><th>作用</th><th>操作目标</th></tr></thead><tbody><tr><td>read</td><td>把变量值从主内存读取到工作内存中，便于后面工作内存进行load</td><td>主内存</td></tr><tr><td>load</td><td>把主内存读取到的变量加载到工作内存变量副本中</td><td>工作内存</td></tr><tr><td>use</td><td>把工作内存中的变量传递给执行引擎，该操作发生在每当虚拟机在执行字节码指令需要变量时触发</td><td>工作内存</td></tr><tr><td>assign</td><td>将执行引擎获得的值赋值给工作内存，当执行引擎触发对变量赋值的指令时，触发该动作</td><td>工作内存</td></tr><tr><td>store</td><td>将工作内存中的变量值传送给主内存，以便于后面write操作</td><td>工作内存</td></tr><tr><td>write</td><td>把store得到的结果传送给主内存变量中</td><td>主内存</td></tr><tr><td>lock</td><td>将主内存中的一个变量标识为一个线程独占状态</td><td>主内存</td></tr><tr><td>unlock</td><td>把一个处于lock状态的变量释放，以便于被其他线程锁定</td><td>主内存</td></tr></tbody></table><p>这里面其中存在使用规则：</p><ul><li>read和load、store和write必须一起使用</li><li>assign操作后必须同步到主内存中</li><li>不允许工作内存无理由同步到主内存中（发生assign才行）</li><li>变量只能从主内存中诞生，不允许在工作内存中直接产生且进行assign操作</li><li>一个变量只允许一个线程执行lock操作，并且lock和unlock需要成对出现</li><li>如果发生lock操作，会清空线程工作内存中该变量的值（直接过期），当该线程执行引擎需要使用该变量值，必须重新操进行load和assign操作。</li><li>当一个变量执行unlock时，必须将锁定线程的变量store、write同步到主内存中</li></ul><h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><p>Java 和 C 不同，对于内存对象提供了自己的回收机制，通过一代一代垃圾回收机的改进，慢慢完善。</p><h2 id="对象存活计算"><a href="#对象存活计算" class="headerlink" title="对象存活计算"></a>对象存活计算</h2><p>在垃圾回收器之前，我们需要了解虚拟机是怎么判断一个对象是否仍然存活，什么时候需要被回收。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>比较简单的计数方案，为每个对象的对象头添加一个引用计数器，当引用时计数 + 1, 引用失效则 - 1，直到计数器为0，则表示<br>该对象已经失效。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>引用计数执行快，对于不想被GC打断的程序比较有利</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法解决相互循环引用问题</li><li>JDK1.2后存在对多种引用形式（软、弱、虚等引用），引用计数无法区分这些情况。</li></ul><h3 id="可达性分析（GC-Root）"><a href="#可达性分析（GC-Root）" class="headerlink" title="可达性分析（GC Root）"></a>可达性分析（GC Root）</h3><p>通过一系列名为“GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连（用图论术语描述就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。在主流的商用程序语言中（Java、C#）,都是使用根搜索算法判定对象是否存活的。</p><p>可作为GC Roots的对象包括下面几种：</p><ol><li><p>虚拟机栈（栈帧中的本地变量表）中的引用的对象。<br><code>比较好理解为方法中所引用的对象，这些对象在堆中分配了地址空间，在虚拟机栈执行过程中，引用这些对象的地址引用，当完成方法的执行，当运行结束并且该对象生命周期结束，不再需要这些对象时，可以释放。这些对象通常在本地变量表中被记录，可以作为GC Root</code></p></li><li><p>方法区中的类静态属性引用的对象。<br><code>对于类中存在 static 的静态属性对象，该引用是存储在方法区中，生命周期可以在整个运行周期中，只能单独作为GC Root。</code></p></li><li><p>方法区中的常量引用的对象。<br><code>static final 所修饰的对象，这些对象也是被分配在方法区，生命周期可以在整个运行周期，可以作为GC Root</code></p></li><li><p>本地方法栈中JNI（Native方法）的引用的对象。</p></li></ol><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><p>主要将收集分成两个步骤：</p><ul><li>标记所有需要回收的对象</li><li>对所标记的对象进行回收</li></ul><p>该方案有两个缺点：</p><ul><li>标记清除效率不高，需要进行便利。</li><li>清除后空间碎片化不连续，无法充分利用剩余的空间，如果剩余空间不能满足所需要分配的对象，不得不在进行垃圾回收。</li></ul><h3 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h3><p>对于之前算法的改进。</p><ul><li>将内存空间分配为两块均等的区域。</li><li>当发生对象内存分配时，在第一块区域进行分配</li><li>当第一块内存不足以再次分配对象时，将存活对象复制到第二区域并第一区域进行清理</li></ul><p>优点：</p><ul><li>不需要考虑内存碎片化问题</li><li>运行效率高，按堆顶指针顺序分配内存</li></ul><p>缺点：</p><ul><li>内存区域缩小一半</li><li>如果存活对象多时，则复制操作将频繁进行。</li></ul><h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>标记-整理是对复制和标记-清除的改进，在之前的标记-清除的基础上，不对标记对象进行清除而是整理，移动存活的对象，更新所移动对象的指针。</p><p>对于不同的算法所进行的整理方式不同：</p><ul><li>滑动顺序 <code>将对象滑动到堆一端，并退出垃圾，保持对象在堆中的先后顺序</code></li><li>线性顺序 <code>将所有有关系的对象排列一起</code></li><li>任意顺序 <code>没有任何联系随意排序</code></li></ul><h4 id="整理算法"><a href="#整理算法" class="headerlink" title="整理算法"></a>整理算法</h4><ul><li>双指针回收算法：简单回收快，但是会打乱对象原布局</li><li>Lisp2算法（滑动回收算法）：通过在对象头用一个额外的记录槽保存迁移后的地址</li><li>引线整理算法：可以在不引入额外空间开销的情况下实现滑动整理，但需要2次遍历堆，且遍历成本较高</li><li>单次遍历算法：滑动回收，实时计算出对象的转发地址而不需要额外的开销</li></ul><h2 id="内存分代"><a href="#内存分代" class="headerlink" title="内存分代"></a>内存分代</h2><p>在了解分代收集算法前，需要对内存分代有点了解。</p><p>出现内存分代主原因是新老内存对象并存，极易造成整块内存频繁的回收，回收收集需要遍历范围大，影响效率。</p><p>那怎么做分代？根据对象的存活时间看，静态变量、类信息存活时间长，而对于方法变量这些活跃变量存活时间段，因此根据这些不同的生成周期看，内存被分为几个区域：</p><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25274/WEBRESOURCEefcf8bc9f941b7542b13ca528c69f59c"  alt="image.png"></p><ul><li>新生代<ul><li>一般位于堆中，包括eden 区，两个Survivor区域，这些区域通常保持 8 ：1 ： 1 比例。</li></ul></li><li>伊甸园区（eden） <code>对象被创建时，首先进入该区域，当进行垃圾回收后，幸存的对象进入Survivor区</code></li><li>Survivor区 <code>保存eden区域存活下来的对象</code><ul><li>Survivor 存在两个区域S0、S1, 这和所选择的回收算法有关，这一般是 复制算法，需要通过两个空间来换取回收的高效率，避免内存碎片。</li><li>两个区域始终会保持其中一个区域为空，当eden第一次发生回收，会被放置到 To Survivor 区域，同时另外一个From Survivor区域里面的对象也放置到To区域中，并情况From区域里面的内存，保持空状态，该区域会在内存不够时发生回收，并轮流保持一个区域为空。</li></ul></li><li>老年代 <ul><li>一般位于堆中</li></ul></li><li>永生代<ul><li>一般指方法区，永生区并不代表不发生回收，当进行Full GC 会对类卸载以及一些常量进行回收。 </li><li>JDK 1.8 后方法区改为元数据区</li></ul></li></ul><h3 id="GC模型分类"><a href="#GC模型分类" class="headerlink" title="GC模型分类"></a>GC模型分类</h3><p>针对不同分代中内存对象的特点，HotSpot中将GC分为三种模型：</p><ul><li>Minor GC: 作用于新生代，回收新生代中的垃圾，并且速度快且频繁，作为回收的主力。</li><li>Major GC: 作用于老年代，回收速度慢，一般伴随 Minor GC进行</li><li>Full GC: 作用于全部区域，包括堆、方法区（永久区）、直接内存，速度慢，需要停止工作线程，且时间较长。</li></ul><p>对于大部分对象而言在 Minor GC 回收中已经会被回收，但是仍然会存活部分的对象下来，这些存活下来的对象会被分配到 Survivor （S0、S1）下，如果Survivor 不足，则会通过空间分配担保将这些老对象分配到老年代中。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><ul><li>当发生Minor GC 时，JVM会检查老年代最大的连续空间是否大于新生代对象总空间</li><li>如果这个条件成立，那么MinorGC可以确保是安全的</li><li>如果不成立则JVM会查看<code>HandlePromotionFailure</code>设置值查看是否允许担保失败。<ul><li>若允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小。<ul><li>如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；</li><li>如果小于，或者HandlePromotionFailure设置不允许冒险，那这时要改为进行一次Full GC</li></ul></li></ul></li></ul><h3 id="老年代变迁"><a href="#老年代变迁" class="headerlink" title="老年代变迁"></a>老年代变迁</h3><h4 id="大对象进入老年代"><a href="#大对象进入老年代" class="headerlink" title="大对象进入老年代"></a>大对象进入老年代</h4><p>对于大量连续内存空间的对象，如果进入新生代容易触发GC，在虚拟机配置中<code>-XX:PretenureSizeThreshold</code>，如果对象大于该分配值，这会直接进入老年代，避免Eden、Survivor发生大量的内存复制。</p><h4 id="长期存活对象进入老年代"><a href="#长期存活对象进入老年代" class="headerlink" title="长期存活对象进入老年代"></a>长期存活对象进入老年代</h4><p>为了便于识别对象存活周期，虚拟机为对象定义了一个对象年年计数器。</p><p>所有在新生代产生的对象，年龄从0开始计数，当每经过一笔Minor GC后仍然存活下来，并且Survivor有足够的空间容纳，则这些对象会被转移到Survivor中，对象年龄开始进入计数 1，而在只收每次Survivor经历Minor GC 后，都会递增该年龄，当达到最大年龄（-XX:PretenureSizeThreshold），则会即将该对象分配老年代中，该计数器失效。</p><h4 id="同年龄对象过多进入老年代"><a href="#同年龄对象过多进入老年代" class="headerlink" title="同年龄对象过多进入老年代"></a>同年龄对象过多进入老年代</h4><p>进入老年代，不仅是到指定年龄后进入，当Surivivor中相同年龄N所有对象的大小总和大于Survivor的一般的时候，那些年龄大于等于该年龄N会直接进入老年代。</p><h2 id="分代收集算法（Generational-Collection）"><a href="#分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法（Generational Collection）"></a>分代收集算法（Generational Collection）</h2><p>通常虚拟机并不是仅用一种收集器，而是搭配使用，具体场景有最佳的收集方式</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25227/WEBRESOURCEc8a492bd9240a8b9f888d42ec7d4c1d3"  alt="image.png"><br>Serial收集器是一个串行收集器，在JDK1.3.1前用于HotSpot新生代的收集。</p><p>特点：</p><ul><li>针对新生代进行回收</li><li>使用复制算法回收</li><li>单线程收集，因此执行时是“Stop The World”，暂停所有工作线程</li></ul><p>该收集器一般配合 Serial Old 收集器使用，当执行完新生代回收后，进行老年代收集</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25229/WEBRESOURCEb82d8908367b954334dbf62b2762e77c"  alt="image.png"></p><p>ParNew 收集器是Serial收集器多线程版本，依然是针对新生代的</p><p>特点：</p><ul><li>基本和Serial收集器一致，但是属于多线程版本</li><li>该收集器在多核中表现好，但是单核下会有额外的线程切换开销，性能反而比Serial收集器差些</li></ul><h3 id="Parallel-Scavenge收集器（“吞吐量优先”收集器）（新生代）"><a href="#Parallel-Scavenge收集器（“吞吐量优先”收集器）（新生代）" class="headerlink" title="Parallel Scavenge收集器（“吞吐量优先”收集器）（新生代）"></a>Parallel Scavenge收集器（“吞吐量优先”收集器）（新生代）</h3><p>特点：</p><ul><li>新生代收集器，并行多线程收集</li><li>使用复制算法</li><li>该收集器提升关注点在于提升吞吐量（ 用户代码运行时间 / (用户代码允许时间 + 垃圾收集时间) ），主要适用于后台运算多而交互不多的情况。</li></ul><h3 id="Serial-Old收集器（老年代）"><a href="#Serial-Old收集器（老年代）" class="headerlink" title="Serial Old收集器（老年代）"></a>Serial Old收集器（老年代）</h3><p>JDK1.5 及其之前 和 Parallel Scavenge 收集器搭配使用。通常是CMS收集器的后背方案，当CMS发生 Concurrent Mode Failure时进行备用。</p><p>特点：</p><ul><li>针对老年代</li><li>使用标记-复制算法，并进行压缩处理</li><li>单线程收集</li></ul><h3 id="Parallel-Old收集器（老年代）"><a href="#Parallel-Old收集器（老年代）" class="headerlink" title="Parallel Old收集器（老年代）"></a>Parallel Old收集器（老年代）</h3><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/25257/WEBRESOURCE0d0f167cf64d87385e6961600e65b133"  alt="image.png"></p><p>在JDK1.6及之后提到Serail Old 收集器</p><p>特点：</p><ul><li>注重吞吐量和CPU敏感场景</li><li>针对老年代</li><li>采用标记-整理算法</li><li>多线程垃圾搜集</li></ul><h3 id="CMS收集器（Concurrent-Mark-Sweep）"><a href="#CMS收集器（Concurrent-Mark-Sweep）" class="headerlink" title="CMS收集器（Concurrent Mark Sweep）"></a>CMS收集器（Concurrent Mark Sweep）</h3><p>基于 标记-清除 算法。</p><p>CMS收集器主要目的是以最短回收停顿时间为目标，注重于响应时间，需要良好的用户体验，真正基本实现了垃圾收集线程和用户线程同时工作要求</p><p>特点：</p><ul><li>基于 标记-清除 算法</li><li>并发多线程标记</li><li>主要以减少停顿时间为目标</li><li>方法垃圾回收和用户线程同时进行</li></ul><p>缺点：</p><ul><li>产生内存碎片</li></ul><p>CMS收集器流程比较麻烦，主要分为4个步骤：</p><ul><li>初始化标记（CMS initial mark）<code>执行 “Stop The World”，标记GC Root所关联的对象</code></li><li>并发标记（CMS concrrent mark）<code>进行GC Roots Tracing过程，可以和用户线程并发进行</code></li><li>重新标记（CMS remark）<code>执行“Stop The World”，再次判断标记期间产生的对象存活，修正因用户程序继续运行而导致标记产生变动的那一并发对象的标记记录。执行时间相对并发标记短</code></li><li>并发清除（CMS concurrent sweep）<code>清除对象，处理时间较长，但是可以和用户线并发执行</code></li></ul><h3 id="G1收集器（Garbage-First）"><a href="#G1收集器（Garbage-First）" class="headerlink" title="G1收集器（Garbage First）"></a>G1收集器（Garbage First）</h3><p>相对于CMS收集器，基于 标记-整理 算法，并且可以精确控制停顿。</p><p>G1将堆分成多个Region，可以通过<code>G1HeapRegionSize</code>进行参数数值，该值必须为2的幂，分区完成后启动将不会发生变化。</p><p>对于Region的区域主要分为：</p><ul><li>Eden regions(年轻代-Eden区) </li><li>Survivor regions(年轻代-Survivor区)</li><li>Old regions（老年代）</li><li>Humongous regions（巨型对象区域）<code>对于占用了Region区域50%以上对象分配区域</code></li><li>Free resgions（未分配区域，也会叫做可用分区）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于程序，我们不仅需要了解开发时所需要的内容，还需要了解程序运行时的环境状态，这样可以方便我们对整个运行环境的掌控和开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; class=&quot;lazyload&quot; data-src=&quot;http://note.youdao.com/yws/r
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-LruCache</title>
    <link href="http://yoursite.com/2018/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LruCache/"/>
    <id>http://yoursite.com/2018/05/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LruCache/</id>
    <published>2018-05-05T06:15:03.000Z</published>
    <updated>2020-04-23T06:16:09.484Z</updated>
    
    <content type="html"><![CDATA[<p>Android 提供的LruCache 是针对于有限内存缓存的一种方案，代码篇幅不长，对几个基础行为进行分析下</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>Key、Value 不允许为 Null</li><li>线程安全</li></ul><h1 id="结构组成"><a href="#结构组成" class="headerlink" title="结构组成"></a>结构组成</h1><p>LruCache 内部是通过 <code>LinkedhHashMap</code> 实现缓存内容的存储，并且借助于 <code>LinkedHashMap</code> 所提供的Lru的支持进行管理，但是对于容量上限的管理，和扩容的处理则选择通过 <code>LruCache</code> 自身进行处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LruCache&lt;K, V&gt; &#123;</span><br><span class="line">    private final LinkedHashMap&lt;K, V&gt; map;</span><br><span class="line">    </span><br><span class="line">    public LruCache(int maxSize) &#123;</span><br><span class="line">        if (maxSize &lt;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;maxSize &lt;&#x3D; 0&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.maxSize &#x3D; maxSize;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; accessOrder &#x3D; true，则启动根据访问顺序进行排序</span><br><span class="line">        this.map &#x3D; new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上对 <code>LinkedHashMap</code>  初始化中，最末参数为 <code>accessOrder</code>，如果设置为<code>true</code> 则表示根据<code>LinkedHashMap</code>元素的访问进行排序，也就是说当初对 <code>LinkedHashMap.get</code> 或者其他访问行为，都将导致该元素放置到<code>LinkedHashMap</code>链表末端（表示最近最新访问过）。</p><blockquote><p>LinkedHashMap Lru采用的头部节点淘汰，访问越频繁的节点越放置到链表最末位。</p></blockquote><h1 id="构造元素"><a href="#构造元素" class="headerlink" title="构造元素"></a>构造元素</h1><p><code>LruCache</code> 的初始化必须提供一个<code>maxSize</code> ，表示最大存储的元素容量。除此之外，内部维护几个重要的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private final LinkedHashMap&lt;K, V&gt; map; </span><br><span class="line"></span><br><span class="line">&#x2F;** Size of this cache in units. Not necessarily the number of elements. *&#x2F;</span><br><span class="line">private int size;</span><br><span class="line">private int maxSize;</span><br><span class="line"></span><br><span class="line">private int putCount;</span><br><span class="line">private int createCount;</span><br><span class="line">private int evictionCount;</span><br><span class="line">private int hitCount;</span><br><span class="line">private int missCount</span><br></pre></td></tr></table></figure><ul><li>map <code>元素实际存储的Map</code></li><li>size <code>当前存储元素的长度，这里的size不是指map.size，添加元素的数量，LruCahce 会为添加的每个&lt;K,V&gt; 元素进行 sizeOf(K, V) 计算，为每一个元素单元计算一个长度单位（默认每个元素单位长度为 1），并将每个添加的元素长度单位累加到 size 中</code></li><li>maxSize <code>最大支持存储的元素单元容量，与 size 进行比较</code></li><li>putCount  <code>添加元素put行为次数</code></li><li>hitCount <code>查找到元素命中次数</code></li><li>missCount <code>未查找到元素的次数，和 hitCount 相对</code></li><li>creatCount <code>如果为查询到元素，会尝试创建默认值，创建成功则递增改值</code></li><li>evictionCount <code>发生在trimToSize，失效元素过期次数</code></li></ul><h1 id="获取-get"><a href="#获取-get" class="headerlink" title="获取 get"></a>获取 get</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当发生 key 获取value为空时，会调用该方法进行默认构造，如果返回不为null，则将创建的值</span><br><span class="line">&#x2F;&#x2F; 添加为 map 中</span><br><span class="line">protected V create(K key) &#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int sizeOf(K key, V value) &#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int safeSizeOf(K key, V value) &#123;</span><br><span class="line">    int result &#x3D; sizeOf(key, value);</span><br><span class="line">    if (result &lt; 0) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;&#x3D;&quot; + value);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) &#123;&#125;    </span><br><span class="line"></span><br><span class="line">public final V get(K key) &#123;</span><br><span class="line">    if (key &#x3D;&#x3D; null) &#123;</span><br><span class="line">        throw new NullPointerException(&quot;key &#x3D;&#x3D; null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V mapValue;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果在 map 中找到值，则直接返回</span><br><span class="line">        mapValue &#x3D; map.get(key);</span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            hitCount++;</span><br><span class="line">            return mapValue;</span><br><span class="line">        &#125;</span><br><span class="line">        missCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有找到要求的元素，进行创建尝试，默认LruCache 没有做实现，可以进行默认创建处理</span><br><span class="line">    V createdValue &#x3D; create(key);</span><br><span class="line">    if (createdValue &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果在 create 中创建默认值成功，则添加到map中</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        createCount++;</span><br><span class="line">        mapValue &#x3D; map.put(key, createdValue);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果这边有返回，则代表在之前的 create 过程中，key 已经添加了新值，那么</span><br><span class="line">        &#x2F;&#x2F; 将之前添加的值重新添加回去，覆盖新建的默认值，避免产生脏数据冲突</span><br><span class="line">        if (mapValue !&#x3D; null) &#123;</span><br><span class="line">            map.put(key, mapValue);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 为添加的元素计算出一个元素size单位长度，并将计算得到的单位长度累加到size中</span><br><span class="line">            size +&#x3D; safeSizeOf(key, createdValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在之前创建create过程中，如果已经有其他value添加进去map，触发 entryRemoved  </span><br><span class="line">    &#x2F;&#x2F; ，通知旧元素被删除，允许对元素发生删除时进行处理。</span><br><span class="line">    if (mapValue !&#x3D; null) &#123;</span><br><span class="line">        entryRemoved(false, key, createdValue, mapValue);</span><br><span class="line">        return mapValue;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果创建默认值过程中没有产生实际数据，则返回新值，触发容量优化</span><br><span class="line">        trimToSize(maxSize);</span><br><span class="line">        return createdValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>根据 Key 向 LinkedHashMap (map) 进行查询，如果查到结果则返回，如果没有则继续</li><li>尝试调用 create() 创建默认值，如果创建成功（不为null）则继续执行，如果为空则返回null</li><li>将创建的默认值添加到 LinkedHashMap(map) 中</li><li>如果添加后发现Key 在创建默认值过程中，已经存在Value，产生冲突，则将该值重新添加到 LinkedHashMap (map) 中，如果未产生冲突，则记录添加元素的单元长度（safeSizeOf）</li><li>如果之前产生冲突，则回调entryRemoved通知元素发生删除，并且返回原值</li><li>如果之前未发生冲突，则触发容量优化（trimToSize）返回默认值</li></ul><h1 id="put-添加元素"><a href="#put-添加元素" class="headerlink" title="put 添加元素"></a>put 添加元素</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public final V put(K key, V value) &#123;</span><br><span class="line">     if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) &#123;</span><br><span class="line">         throw new NullPointerException(&quot;key &#x3D;&#x3D; null || value &#x3D;&#x3D; null&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     V previous;</span><br><span class="line">     synchronized (this) &#123;</span><br><span class="line">         putCount++;</span><br><span class="line">         &#x2F;&#x2F; 计算添加元素的单元长度，并累计 size</span><br><span class="line">         size +&#x3D; safeSizeOf(key, value);</span><br><span class="line">         </span><br><span class="line">         &#x2F;&#x2F; 如果添加的Key目标之前已经有值，则剔除之前元素的单元长度</span><br><span class="line">         previous &#x3D; map.put(key, value);</span><br><span class="line">         if (previous !&#x3D; null) &#123;</span><br><span class="line">             size -&#x3D; safeSizeOf(key, previous);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Key 之前如果存有值，因为发生旧值删除，调用 entryRemoved 回调</span><br><span class="line">     if (previous !&#x3D; null) &#123;</span><br><span class="line">         entryRemoved(false, key, previous, value);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 优化容量</span><br><span class="line">     trimToSize(maxSize);</span><br><span class="line">     return previous;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>计算添加元素的单元长度，累计长度 size，并添加新元素</li><li>如果添加元素位置之前已有旧元素，则减去剔除元素的长度</li><li>如果发生旧元素的剔除，调用 entryRemoved 通知</li><li>优化存储容器，返回之前元素</li></ul><h1 id="容器优化"><a href="#容器优化" class="headerlink" title="容器优化"></a>容器优化</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 执行循环 一个一个的将最不常访问的元素进行移除</span><br><span class="line">private void trimToSize(int maxSize) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        K key;</span><br><span class="line">        V value;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            &#x2F;&#x2F; 异常状态，一般不会发生这个情况，除非容量计算前后不一致导致，注意 sizeOf 计算结果的一致性</span><br><span class="line">            if (size &lt; 0 || (map.isEmpty() &amp;&amp; size !&#x3D; 0)) &#123;</span><br><span class="line">                throw new IllegalStateException(getClass().getName()</span><br><span class="line">                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 总元素的单元长度小于最大则不需要进行优化，退出</span><br><span class="line">            if (size &lt;&#x3D; maxSize) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 获取最不频繁访问的元素</span><br><span class="line">            Map.Entry&lt;K, V&gt; toEvict &#x3D; map.eldest();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 为空则表示map还未添加任何元素，退出</span><br><span class="line">            if (toEvict &#x3D;&#x3D; null) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 从map移除最不常访问的元素，并减去该元素的单位长度</span><br><span class="line">            key &#x3D; toEvict.getKey();</span><br><span class="line">            value &#x3D; toEvict.getValue();</span><br><span class="line">            map.remove(key);</span><br><span class="line">            size -&#x3D; safeSizeOf(key, value);</span><br><span class="line">            evictionCount++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通知元素删除</span><br><span class="line">        entryRemoved(true, key, value, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是对 map 进行 maxSize 最大容量控制，如果当前记录的size超过maxSize，则从 map 中取出最不常访问的元素（map.eldest()) 进行删除并更新 size。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 提供的LruCache 是针对于有限内存缓存的一种方案，代码篇幅不长，对几个基础行为进行分析下&lt;/p&gt;
&lt;h1 id=&quot;特点&quot;&gt;&lt;a href=&quot;#特点&quot; class=&quot;headerlink&quot; title=&quot;特点&quot;&gt;&lt;/a&gt;特点&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;K
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-LinkedHashMap</title>
    <link href="http://yoursite.com/2018/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LinkedHashMap/"/>
    <id>http://yoursite.com/2018/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-LinkedHashMap/</id>
    <published>2018-04-28T04:29:42.000Z</published>
    <updated>2020-04-23T06:17:35.871Z</updated>
    
    <content type="html"><![CDATA[<p>LinkedHashMap 是基于之前 HashMap 基础上再建立的机制，LinkedHashMap 相比于 HashMap 最重要的是实现了插入元素的有序性，可对顺序进行前后倒置。</p><p>在 HashMap 的容器之外，监控 HashMap 对于节点的创建、添加、访问，额外建立一套双端链表，用于对这些的节点跟踪。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul><li>有序性（包括 Key、Value、Entry）</li><li>支持Lru算法，头部淘汰方式</li><li>非线程安全</li></ul><h2 id="添加变化"><a href="#添加变化" class="headerlink" title="添加变化"></a>添加变化</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/29904/18C78F3DD4FE4AD693C829D7E497E22F"  alt="image"></p><p>LinkedHashMap 实质是在HashMap基础上，在维护了一个双端队列，当HashMap 中的容器发生元素添加，同时该状态也会同步到双端队列中，同时对双端队列中的节点关系进行变更。如果支持Lru则同时在访问创建节点会对队列排序顺序产生影响。</p><h1 id="增加的参数"><a href="#增加的参数" class="headerlink" title="增加的参数"></a>增加的参数</h1><h2 id="构造的变更"><a href="#构造的变更" class="headerlink" title="构造的变更"></a>构造的变更</h2><p>在构造中，除了提供了：</p><ul><li>initialCapacity <code>初始化容量</code></li><li>loadFactor <code>负载因子</code></li></ul><p>还增加了</p><ul><li>accessOrder <code>访问顺序，true为按照访问顺序访问，即为LRU，false为按照插入顺序排序，默认为 false</code></li></ul><p><code>LinkedHashMap</code> 在原来的链表基础上，为<code>Node</code>新增加了<code>before</code>、<code>after</code> 访问入口，变更为双端链表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static class LinkedHashMapEntry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; before, after;</span><br><span class="line">    LinkedHashMapEntry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量增加"><a href="#变量增加" class="headerlink" title="变量增加"></a>变量增加</h2><p>在全局变量上，增加了</p><ul><li>head <code>用于存储头部链表节点</code></li><li>tail <code>用于存储尾部节点，插入过程一般使用尾端插入，当且只有一个元素时 head == tail</code></li></ul><p>提供双端访问入口</p><h1 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h1><p><code>HashMap</code> 为 <code>LinkedHashMap</code> 提供了比较多的重写入口，为它的实现提供了便捷。</p><h2 id="afterNodeAccess"><a href="#afterNodeAccess" class="headerlink" title="afterNodeAccess"></a>afterNodeAccess</h2><p>该方法当对元素进行访问时触发，用于在支持（accessOrder==true）Lru下Map对元素访问时的变更操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; last;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; accessOrder 为 true 才有效，也就说仅对 Lru 要求时才会进行执行</span><br><span class="line">    &#x2F;&#x2F; 如果当前访问的节点不为尾部节点</span><br><span class="line">    &#x2F;&#x2F; Lru 中如果发生访问，在将最近访问的节点添加到链表</span><br><span class="line">    &#x2F;&#x2F; 尾部，从头部移除，头部始终置顶未访问最久的节点</span><br><span class="line">    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMapEntry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        p.after &#x3D; null;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果访问节点为头节点，则变更全局头部变量指向访问节点下一个节点，替换头节点</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">         &#x2F;&#x2F; 访问节点不是头节点，则调整访问节点前一个节点指向访问节点的后一个节点</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F; 如果访问节点不是尾部节点，则将尾部节点前一个节点指向访问节点的前一个节点      </span><br><span class="line">        if (a !&#x3D; null)</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">        &#x2F;&#x2F; 如果访问节点为末端节点，则将全局节点尾部节点指向访问节点前一个节点</span><br><span class="line">            last &#x3D; b;</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F; 处理完前面的初始化后，如果全局尾部节点还未初</span><br><span class="line">        &#x2F;&#x2F; 始化，则将访问节点作为头部节点，否则改变当前</span><br><span class="line">        &#x2F;&#x2F; 全局尾部节点的指向，当前访问节点作为全局尾部</span><br><span class="line">        &#x2F;&#x2F; 节点的下一个节点，访问节点的前一个节点指向全</span><br><span class="line">        &#x2F;&#x2F; 局尾部节点。    </span><br><span class="line">        if (last &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; p;</span><br><span class="line">        else &#123;</span><br><span class="line">            p.before &#x3D; last;</span><br><span class="line">            last.after &#x3D; p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 将访问节点移到最末节点后，将全局尾节点赋值为当前访问节点</span><br><span class="line">        tail &#x3D; p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是为Lru情况的处理，如果发生节点访问，需要将访问节点转移到链表末端，并改变这过程前后的节点关系，为全局首尾节点重新赋值。</p><p>如果需要执行该过程需要满足：</p><ul><li>accessOrder = true</li><li>访问节点非尾部节点，如果是尾部则表示已经是最近访问的节点变化了，不需要在进行调整。</li></ul><h2 id="afterNodeInsertion、removeEldestEntry"><a href="#afterNodeInsertion、removeEldestEntry" class="headerlink" title="afterNodeInsertion、removeEldestEntry"></a>afterNodeInsertion、removeEldestEntry</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; 是否移除最早的元素，默认为false，需要用户自己删除元素</span><br><span class="line">  &#x2F;&#x2F; 的时机，比如 size &gt; maxCapacity</span><br><span class="line">protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;</span><br><span class="line">      return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; evict 表示HashMap触发的该方法是否发生真实的元素添加（有</span><br><span class="line">&#x2F;&#x2F; 可能是作为对旧数据的调整导致的添加行为）。该方法的实现需</span><br><span class="line">&#x2F;&#x2F; 要配合 removeEldestEntry 实现</span><br><span class="line">void afterNodeInsertion(boolean evict) &#123; &#x2F;&#x2F; possibly remove eldest</span><br><span class="line">      LinkedHashMapEntry&lt;K,V&gt; first;</span><br><span class="line">      if (evict &amp;&amp; (first &#x3D; head) !&#x3D; null &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">          K key &#x3D; first.key;</span><br><span class="line">          removeNode(hash(key), key, null, false, true);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>afterNodeInsertion</code> 在Map发生元素添加时触发。</p><p>该方法是为 Lru 所提供的支持，当且<code>removeEldestEntry</code> 返回true才有效，在<code>LinkedHashMap</code> 默认为 false, 需要重实现<code>removeEldestEntry</code>，才能实现 <code>LinkedHashMap``Lru</code>算法</p><h2 id="afterNodeRemoval"><a href="#afterNodeRemoval" class="headerlink" title="afterNodeRemoval"></a>afterNodeRemoval</h2><p>该方法在 <code>HashMap</code> 发生元素真实移除时触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; p &#x3D;</span><br><span class="line">            (LinkedHashMapEntry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;</span><br><span class="line">        &#x2F;&#x2F; 清空当前节点前后索引    </span><br><span class="line">        p.before &#x3D; p.after &#x3D; null;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理删除节点前节点的拼接</span><br><span class="line">        &#x2F;&#x2F; 如果当前节点前节点为空，则表示移除的节点为头部节点</span><br><span class="line">        &#x2F;&#x2F;，更改全局变量头部节点 head 的指向当前移除节点的后节点</span><br><span class="line">        if (b &#x3D;&#x3D; null)</span><br><span class="line">            head &#x3D; a;</span><br><span class="line">        else</span><br><span class="line">        &#x2F;&#x2F; 如果当前删除节点存在前节点，那么将前节点的后节点方法指向删除节点的后节点</span><br><span class="line">            b.after &#x3D; a;</span><br><span class="line">            </span><br><span class="line">        &#x2F;&#x2F; 处理删除节点后节点的拼接</span><br><span class="line">        &#x2F;&#x2F; 如果删除节点后节点为空，则表示该节点即是链表的最</span><br><span class="line">        &#x2F;&#x2F; 后节点，调整全局变量尾节点指向删除节点的前节点</span><br><span class="line">        if (a &#x3D;&#x3D; null)</span><br><span class="line">            tail &#x3D; b;</span><br><span class="line">        else</span><br><span class="line">        &#x2F;&#x2F; 后节点的前节点指向删除节点的前节点</span><br><span class="line">            a.before &#x3D; b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法主要处理被删除节点的前后节点关系拼接重建。</p><h2 id="internalWriteEntries"><a href="#internalWriteEntries" class="headerlink" title="internalWriteEntries"></a>internalWriteEntries</h2><p><code>HashMap</code> 实现 <code>Serializable</code>了接口, 并实现了<code>writeObject</code>，对序列化规则进行重新调整。</p><p><code>internalWriteEntries</code> 在序列化时默认被 writeObject 所调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">    for (LinkedHashMapEntry&lt;K,V&gt; e &#x3D; head; e !&#x3D; null; e &#x3D; e.after) &#123;</span><br><span class="line">        s.writeObject(e.key);</span><br><span class="line">        s.writeObject(e.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节点创建-newNode、newTreeNode、replacementNode、replacementTreeNode"><a href="#节点创建-newNode、newTreeNode、replacementNode、replacementTreeNode" class="headerlink" title="节点创建 newNode、newTreeNode、replacementNode、replacementTreeNode"></a>节点创建 newNode、newTreeNode、replacementNode、replacementTreeNode</h2><p>在前面所有的流程中都没有提及对于双端链表节点的包装，在HashMap中存在两种节点创建方式，分别对应为 <code>newNode</code>方法、<code>newTreeNode</code>方法，因此 <code>LinkedHashMap</code> 同样重写了该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; newNode、(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; p &#x3D;</span><br><span class="line">        new LinkedHashMapEntry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p &#x3D; new TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; q &#x3D; (LinkedHashMapEntry&lt;K,V&gt;)p;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; t &#x3D;</span><br><span class="line">        new LinkedHashMapEntry&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    transferLinks(q, t);</span><br><span class="line">    return t;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; q &#x3D; (LinkedHashMapEntry&lt;K,V&gt;)p;</span><br><span class="line">    TreeNode&lt;K,V&gt; t &#x3D; new TreeNode&lt;K,V&gt;(q.hash, q.key, q.value, next);</span><br><span class="line">    transferLinks(q, t);</span><br><span class="line">    return t;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">private void linkNodeLast(LinkedHashMapEntry&lt;K,V&gt; p) &#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; last &#x3D; tail;</span><br><span class="line">    &#x2F;&#x2F; 添加到尾部</span><br><span class="line">    tail &#x3D; p;</span><br><span class="line">    &#x2F;&#x2F; 如果全局尾节点未记录，则表示链表关系未建立，</span><br><span class="line">    &#x2F;&#x2F; 当前节点初始化为头节点</span><br><span class="line">    if (last &#x3D;&#x3D; null)</span><br><span class="line">        head &#x3D; p;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果已经存在链表，则添加到尾部节点，并将之前的尾部节点下一个节点指向创建的新访问节点</span><br><span class="line">        p.before &#x3D; last;</span><br><span class="line">        last.after &#x3D; p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法的重写都涉及 <code>HashMap</code> 创建 Node 节点，对于所需要创建的节点都使用 <code>LinkedHashMapEntry</code> 进行构造，创建双端链表的条件，并通过<code>linkNodeLast</code>建立链表关系，新创建的节点视为和访问情况一致，向尾部节点之后添加。</p><h1 id="LinkedHashMap中的Lru"><a href="#LinkedHashMap中的Lru" class="headerlink" title="LinkedHashMap中的Lru"></a>LinkedHashMap中的Lru</h1><p>LinkedHashMap LRU 队列采用的是队头淘汰方式（每次淘汰都是淘汰头部节点），即对于最经常访问的节点置于最末端（可见<code>afterNodeAccess</code> 和节点创建。</p><ul><li>当发生新建节点、访问节点，则将这些节点向链表末端添加或移动，保持头部（head）节点始终为访问节点频次最少节点。</li><li>LinkedHashMap 如果需要设置最大容量，对溢出节点进行自动删除，则需要覆盖重写 <code>removeEldestEntry</code>方法（返回true则移除，false则不执行），并且对于每次移除的目标都为 head 头部节点。</li></ul><h1 id="访问的有序性"><a href="#访问的有序性" class="headerlink" title="访问的有序性"></a>访问的有序性</h1><p>所有的集合都可以进行迭代器处理。在<code>LinkedHashMap</code>中为了保持有序性的访问，也重新实现了迭代器。</p><h2 id="Key-的访问"><a href="#Key-的访问" class="headerlink" title="Key 的访问"></a>Key 的访问</h2><p>在Map中我们可以获得<code>Key</code>的结合列表<code>Map.keySet</code>。</p><p>LikedHashMap 重新实现了有序Set</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">       Set&lt;K&gt; ks &#x3D; keySet;</span><br><span class="line">       if (ks &#x3D;&#x3D; null) &#123;</span><br><span class="line">           ks &#x3D; new LinkedKeySet();</span><br><span class="line">           keySet &#x3D; ks;</span><br><span class="line">       &#125;</span><br><span class="line">       return ks;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   final class LinkedKeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">       public final int size()                 &#123; return size; &#125;</span><br><span class="line">       public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;</span><br><span class="line">       public final Iterator&lt;K&gt; iterator() &#123;</span><br><span class="line">           return new LinkedKeyIterator();</span><br><span class="line">       &#125;</span><br><span class="line">       public final boolean contains(Object o) &#123; return containsKey(o); &#125;</span><br><span class="line">       public final boolean remove(Object key) &#123;</span><br><span class="line">           return removeNode(hash(key), key, null, false, true) !&#x3D; null;</span><br><span class="line">       &#125;</span><br><span class="line">       public final Spliterator&lt;K&gt; spliterator()  &#123;</span><br><span class="line">           return Spliterators.spliterator(this, Spliterator.SIZED |</span><br><span class="line">                                           Spliterator.ORDERED |</span><br><span class="line">                                           Spliterator.DISTINCT);</span><br><span class="line">       &#125;</span><br><span class="line">       public final void forEach(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">           if (action &#x3D;&#x3D; null)</span><br><span class="line">               throw new NullPointerException();</span><br><span class="line">           int mc &#x3D; modCount;</span><br><span class="line">           &#x2F;&#x2F; 获取 LinkedHashMap 头部节点 head ，链表遍历</span><br><span class="line">           for (LinkedHashMapEntry&lt;K,V&gt; e &#x3D; head; (e !&#x3D; null &amp;&amp; modCount &#x3D;&#x3D; mc); e &#x3D; e.after)</span><br><span class="line">               action.accept(e.key);</span><br><span class="line">           if (modCount !&#x3D; mc)</span><br><span class="line">               throw new ConcurrentModificationException();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过访问 <code>LinkedHashMap.head</code> 进行链表遍历</p><h2 id="Value-的访问"><a href="#Value-的访问" class="headerlink" title="Value 的访问"></a>Value 的访问</h2><p>同样的，对于 <code>Map.value</code> 也重新实现了 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Collection&lt;V&gt; values() &#123;</span><br><span class="line">    Collection&lt;V&gt; vs &#x3D; values;</span><br><span class="line">    if (vs &#x3D;&#x3D; null) &#123;</span><br><span class="line">        vs &#x3D; new LinkedValues();</span><br><span class="line">        values &#x3D; vs;</span><br><span class="line">    &#125;</span><br><span class="line">    return vs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class LinkedValues extends AbstractCollection&lt;V&gt; &#123;</span><br><span class="line">    public final int size()                 &#123; return size; &#125;</span><br><span class="line">    public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;</span><br><span class="line">    public final Iterator&lt;V&gt; iterator() &#123;</span><br><span class="line">        return new LinkedValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean contains(Object o) &#123; return containsValue(o); &#125;</span><br><span class="line">    public final Spliterator&lt;V&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliterator(this, Spliterator.SIZED |</span><br><span class="line">                                        Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line">    public final void forEach(Consumer&lt;? super V&gt; action) &#123;</span><br><span class="line">        if (action &#x3D;&#x3D; null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int mc &#x3D; modCount;</span><br><span class="line">        &#x2F;&#x2F; 和 Set 一样，从头部节点开始遍历链表</span><br><span class="line">        for (LinkedHashMapEntry&lt;K,V&gt; e &#x3D; head; (e !&#x3D; null &amp;&amp; modCount &#x3D;&#x3D; mc); e &#x3D; e.after)</span><br><span class="line">            action.accept(e.value);</span><br><span class="line">        if (modCount !&#x3D; mc)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他类似 <code>Map.entrySet</code> 都是如此单独实现，不一一列举</p><h2 id="Map的迭代器访问"><a href="#Map的迭代器访问" class="headerlink" title="Map的迭代器访问"></a>Map的迭代器访问</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">abstract class LinkedHashIterator &#123;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; next;</span><br><span class="line">    LinkedHashMapEntry&lt;K,V&gt; current;</span><br><span class="line">    int expectedModCount;</span><br><span class="line"></span><br><span class="line">    LinkedHashIterator() &#123;</span><br><span class="line">        next &#x3D; head;</span><br><span class="line">        expectedModCount &#x3D; modCount;</span><br><span class="line">        current &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final boolean hasNext() &#123;</span><br><span class="line">        return next !&#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final LinkedHashMapEntry&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">        LinkedHashMapEntry&lt;K,V&gt; e &#x3D; next;</span><br><span class="line">        if (modCount !&#x3D; expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        if (e &#x3D;&#x3D; null)</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        current &#x3D; e;</span><br><span class="line">        next &#x3D; e.after;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void remove() &#123;</span><br><span class="line">        Node&lt;K,V&gt; p &#x3D; current;</span><br><span class="line">        if (p &#x3D;&#x3D; null)</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        if (modCount !&#x3D; expectedModCount)</span><br><span class="line">            throw new ConcurrentModificationException();</span><br><span class="line">        current &#x3D; null;</span><br><span class="line">        K key &#x3D; p.key;</span><br><span class="line">        removeNode(hash(key), key, null, false, false);</span><br><span class="line">        expectedModCount &#x3D; modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class LinkedKeyIterator extends LinkedHashIterator</span><br><span class="line">    implements Iterator&lt;K&gt; &#123;</span><br><span class="line">    public final K next() &#123; return nextNode().getKey(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class LinkedValueIterator extends LinkedHashIterator</span><br><span class="line">    implements Iterator&lt;V&gt; &#123;</span><br><span class="line">    public final V next() &#123; return nextNode().value; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final class LinkedEntryIterator extends LinkedHashIterator</span><br><span class="line">    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前访问没什么差别，通过 <code>head</code> 对列表进行访问，实现了对 Key、Value、Entry 迭代器的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LinkedHashMap 是基于之前 HashMap 基础上再建立的机制，LinkedHashMap 相比于 HashMap 最重要的是实现了插入元素的有序性，可对顺序进行前后倒置。&lt;/p&gt;
&lt;p&gt;在 HashMap 的容器之外，监控 HashMap 对于节点的创建、添加
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
