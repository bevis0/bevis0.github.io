<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>View-invalidate流程 | Bevis技术小站</title><meta name="description" content="View-invalidate流程"><meta name="keywords" content="Android,View"><meta name="author" content="Bevis"><meta name="copyright" content="Bevis"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="View-invalidate流程"><meta name="twitter:description" content="View-invalidate流程"><meta name="twitter:image" content="http://yoursite.com/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="View-invalidate流程"><meta property="og:url" content="http://yoursite.com/2019/01/20/View-invalidate%E6%B5%81%E7%A8%8B/"><meta property="og:site_name" content="Bevis技术小站"><meta property="og:description" content="View-invalidate流程"><meta property="og:image" content="http://yoursite.com/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/01/20/View-invalidate%E6%B5%81%E7%A8%8B/"><link rel="prev" title="Jetpack-Lifecycle" href="http://yoursite.com/2019/02/14/Jetpack-Lifecycle/"><link rel="next" title="Android源码编译和阅读" href="http://yoursite.com/2019/01/13/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%98%85%E8%AF%BB/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Bevis技术小站" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">33</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PFLAG"><span class="toc-number">1.</span> <span class="toc-text">PFLAG</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PFLAG-DRAWN"><span class="toc-number">1.1.</span> <span class="toc-text">PFLAG_DRAWN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PFLAG-HAS-BOUNDS"><span class="toc-number">1.2.</span> <span class="toc-text">PFLAG_HAS_BOUNDS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PFLAG-DRAWING-CACHE-VALID"><span class="toc-number">1.3.</span> <span class="toc-text">PFLAG_DRAWING_CACHE_VALID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PFLAG-SKIP-DRAW"><span class="toc-number">1.4.</span> <span class="toc-text">PFLAG_SKIP_DRAW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PFLAG-INVALIDATED"><span class="toc-number">1.5.</span> <span class="toc-text">PFLAG_INVALIDATED</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PFLAG-DRAW-ANIMATION"><span class="toc-number">1.6.</span> <span class="toc-text">PFLAG_DRAW_ANIMATION</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PFLAG-DIRTY"><span class="toc-number">1.7.</span> <span class="toc-text">PFLAG_DIRTY</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#invalidate-相关方法"><span class="toc-number">2.</span> <span class="toc-text">invalidate 相关方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流程触发（invalidateInternal）"><span class="toc-number">3.</span> <span class="toc-text">流程触发（invalidateInternal）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#支持硬件加速处理（onDescendantInvalidated）"><span class="toc-number">3.1.</span> <span class="toc-text">支持硬件加速处理（onDescendantInvalidated）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非硬件加速"><span class="toc-number">3.2.</span> <span class="toc-text">非硬件加速</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ViewRootImpl-performTraversal"><span class="toc-number">4.</span> <span class="toc-text">ViewRootImpl.performTraversal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一次-measure"><span class="toc-number">4.1.</span> <span class="toc-text">第一次 measure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#measureHierarchy"><span class="toc-number">4.1.1.</span> <span class="toc-text">measureHierarchy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二次-measure"><span class="toc-number">4.1.2.</span> <span class="toc-text">二次 measure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Window-measure-及其-Size-变化的处理"><span class="toc-number">4.1.3.</span> <span class="toc-text">Window measure 及其 Size 变化的处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#layout"><span class="toc-number">4.2.</span> <span class="toc-text">layout</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#performLayout"><span class="toc-number">4.2.1.</span> <span class="toc-text">performLayout</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#draw"><span class="toc-number">4.3.</span> <span class="toc-text">draw</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#performDraw"><span class="toc-number">4.3.1.</span> <span class="toc-text">performDraw</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#draw-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">draw</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#drawSoftware"><span class="toc-number">4.3.3.</span> <span class="toc-text">drawSoftware</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#问题"><span class="toc-number">5.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#invalidate-boolean-invalidateCache-参数中-invalidateCache-的影响"><span class="toc-number">5.1.</span> <span class="toc-text">invalidate(boolean invalidateCache) 参数中 invalidateCache 的影响</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bevis技术小站</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">View-invalidate流程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2019-01-20 21:00:57"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-01-20</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>在自定义控件上，我们经常会调用这个方法，声明当前视图失效，并尝试重新绘制。</p>
<p>今天有空研究下这方法的流程，加强下自己的认识，看有没有对自定义控件有优化空间。</p>
<h1 id="PFLAG"><a href="#PFLAG" class="headerlink" title="PFLAG"></a>PFLAG</h1><p>在 View 的流程中，大量应用了 PFLAG 标记，用于处理在事务中的变化。在分析 <code>invalidate</code> 前，需要先记着几个<code>PLAG</code>的作用：</p>
<h2 id="PFLAG-DRAWN"><a href="#PFLAG-DRAWN" class="headerlink" title="PFLAG_DRAWN"></a>PFLAG_DRAWN</h2><p>该标记比较常用，标记了该标记，会在绘制流程中允许进入 draw 流程，对于View内部可能对绘制结果产生影响的动作 都会被加上该标记，比如 设置 View 的 top、bottom等。</p>
<p>invalidateInternal 用于判断是否允许继续进行 invalidate </p>
<h2 id="PFLAG-HAS-BOUNDS"><a href="#PFLAG-HAS-BOUNDS" class="headerlink" title="PFLAG_HAS_BOUNDS"></a>PFLAG_HAS_BOUNDS</h2><p>表示view是否进行过layout，设置了left、top等边界信息，触发 setFrame 也会标记该flag。</p>
<h2 id="PFLAG-DRAWING-CACHE-VALID"><a href="#PFLAG-DRAWING-CACHE-VALID" class="headerlink" title="PFLAG_DRAWING_CACHE_VALID"></a>PFLAG_DRAWING_CACHE_VALID</h2><p>当添加该标记，则表示该<code>View</code>已经构建好DisplayList，</p>
<h2 id="PFLAG-SKIP-DRAW"><a href="#PFLAG-SKIP-DRAW" class="headerlink" title="PFLAG_SKIP_DRAW"></a>PFLAG_SKIP_DRAW</h2><p>如果添加该标记，则表示该 <code>View</code>不会执行 <code>View.draw()</code> 流程，这常见于<code>ViewGroup</code>，如果在<code>ViewGroup</code>中没有设置需要绘制的属性（比如<code>background</code>、<code>foreground</code>），则会通过设置这个标记，跳过绘制环节</p>
<h2 id="PFLAG-INVALIDATED"><a href="#PFLAG-INVALIDATED" class="headerlink" title="PFLAG_INVALIDATED"></a>PFLAG_INVALIDATED</h2><p>用于标记整个图层(子View 无效同时会影响该View)失效，对View整个DisplayList 重新绘制，而不是返回一个旧的 DisplayList 内容。</p>
<p>一般来说View边界发生变化或者绘制内容发生变化都需要通知图层失效。比如执行 requestLayout、invalidate（这个的前提会检查是否设置 PFLAG_DRAWN 或 PFLAG_HAS_BOUNDS 才允许失效）</p>
<p>当然也可以做强制对图层重绘（DisplayList 更新） forceLayout</p>
<blockquote>
<p>flag 直接存在相互影响 ，比如当前这个flog，当触发 setTop 之类的动作，会对当前View flag 设置 PFLAG_HAS_BOUNDS 而在之后的 invalidate 触发中，会将该标记直接升级为 PFLAG_INVALIDATED （增加表示），因此要注意flags 间的传递影响</p>
</blockquote>
<h2 id="PFLAG-DRAW-ANIMATION"><a href="#PFLAG-DRAW-ANIMATION" class="headerlink" title="PFLAG_DRAW_ANIMATION"></a>PFLAG_DRAW_ANIMATION</h2><p>这个标记表示它及其子View正在执行动画，不能取消对 invalidate 的请求（畅通无阻），即使动画的区域超过了当前View的边界（如果是普通View的绘制要求，超出边界则不被计算在 dirty 区域中，则不会被执行绘制）。</p>
<h2 id="PFLAG-DIRTY"><a href="#PFLAG-DIRTY" class="headerlink" title="PFLAG_DIRTY"></a>PFLAG_DIRTY</h2><p>标记当前View 绘制是否失效（无论是全部失效或者局部失效的情况），当view调用了invalidate 时，它子View也同时会被打上该标记</p>
<h1 id="invalidate-相关方法"><a href="#invalidate-相关方法" class="headerlink" title="invalidate 相关方法"></a>invalidate 相关方法</h1><p>在 View 中除了我们常用的 <code>invalidate()</code> 方法其实还存在着不少的其他刷新方法。</p>
<ul>
<li>invalidate(int l, int t, int r, int b) <code>已经过期，在API14后可以启用硬件加速后，已经可以对脏区域进行自动计算，API21后默认忽视，建议调用invalidate()</code></li>
<li>invalidate(Rect dirty) <code>和 invalidate(int l, int t, int r, int b) 一样，只是封装为 Rect</code></li>
<li>invalidate(boolean invalidateCache) <code>如果 invalidateCache 为true则将导致 缓存失效，会导致整个页面进行重新刷新，否则如果View内容或大小没发生变化则不需要整个失效，应该置为false</code></li>
<li>invalidateDrawable(@NonNull Drawable drawable) <code>指定drawable必须为该View的一部分，比如背景之类，该方法实际也是调用 invalidate(int l, int t, int r, int b)，调用 Drawble.getDirtyBounds 进行相对脏区域的失效，会导致 rebuidOutline 的连锁重绘</code></li>
</ul>
<p>在API的注释中，我们可以了解到View除了临时向<code>Canvas</code> 绘制的图层，其实还了一层缓存 DisplayList ，以降低对渲染的压力</p>
<h1 id="流程触发（invalidateInternal）"><a href="#流程触发（invalidateInternal）" class="headerlink" title="流程触发（invalidateInternal）"></a>流程触发（invalidateInternal）</h1><p>忽略前面一些非实质的调用，直接看 <code>invalidateInternal</code> 方法中的处理。</p>
<p>本方法中主要处理：</p>
<ul>
<li>如果该View不可见并且并不正在执行动画和 Transition 动画 ，则该View忽略invalidate 操作</li>
<li>在之前的处理中如果发生 PFLAG_DRAWN（draw要求）或 PFLAG_HAS_BOUNDS（size 变更）则允许执行</li>
<li>判断是否对 invalidateCache 响应，消费PFLAG_DRAWING_CACHE_VALID flag，转为 PFLAG_INVALIDATED</li>
<li>通知子View invalidateChild ，计算 dirty 区域范围</li>
<li>如果背景设置有投影（硬件支持），向上寻找 <code>isProjectionReceiver == true</code> 的 父View（设置了background 就符合条件），进行 <code>damageInParent</code> 响应，在内部中最终触发锁支持View <code>onDescendantInvalidated</code> 的处理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.view.View</span><br><span class="line"></span><br><span class="line">  void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</span><br><span class="line">            boolean fullInvalidate) &#123;</span><br><span class="line">        &#x2F;&#x2F; 目前没发现 GhostView的 实质作用，但是在绘制时它是可以绘制的</span><br><span class="line">        if (mGhostView !&#x3D; null) &#123;</span><br><span class="line">            mGhostView.invalidate(true);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断当前视图是否可见、没有需要执行的动画并且当前View未在执行 Transition 场景动画</span><br><span class="line">        if (skipInvalidate()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Reset content capture caches</span><br><span class="line">        mCachedContentCaptureSession &#x3D; null;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; PFLAG_DRAWN: 用于判断当前View是否需要被 draw, 如果当前View </span><br><span class="line">        &#x2F;&#x2F; 为gone、invisible状态 或者处理边界bottom </span><br><span class="line">        &#x2F;&#x2F; 等导致需要强制绘制，则需要添加该标识，在 setBottom 、setFlags 都有体现</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        &#x2F;&#x2F; PFLAG_HAS_BOUNDS: 该标记用于表示该top bottom </span><br><span class="line">        &#x2F;&#x2F; 等边界值是否发生变化，如果变化则添加该值，强制更新view</span><br><span class="line">        if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) &#x3D;&#x3D; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">        </span><br><span class="line">                &#x2F;&#x2F; 当invalidateCache &#x3D;&#x3D; true 时，检查 PFLAG_DRAWING_CACHE_VALID标记，</span><br><span class="line">                &#x2F;&#x2F; 如果存在则表示已经生成 DisplayList ,则需要进行失效处理</span><br><span class="line">                || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) &#x3D;&#x3D; PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; PFLAG_INVALIDATED 表示当前view绘制过期失效，该标记同时也会导致 DisplayList</span><br><span class="line">                &#x2F;&#x2F; 失效重绘</span><br><span class="line">                || (mPrivateFlags &amp; PFLAG_INVALIDATED) !&#x3D; PFLAG_INVALIDATED</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 图层透明情况检查</span><br><span class="line">                || (fullInvalidate &amp;&amp; isOpaque() !&#x3D; mLastIsOpaque)) &#123;</span><br><span class="line">                </span><br><span class="line">            &#x2F;&#x2F; fullInvalidate 为true 则整个图层进行重绘制请求</span><br><span class="line">            &#x2F;&#x2F; 这里已经进入绘制draw 移除过期标记 PFLAG_DRAWN</span><br><span class="line">            if (fullInvalidate) &#123;</span><br><span class="line">                &#x2F;&#x2F; 记录此次处理时图层透明度状态</span><br><span class="line">                mLastIsOpaque &#x3D; isOpaque();</span><br><span class="line">                mPrivateFlags &amp;&#x3D; ~PFLAG_DRAWN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 进入这则表示肯定会进行图层绘制，则标记该图层为脏图层 PFLAG_DIRTY</span><br><span class="line">            mPrivateFlags |&#x3D; PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果缓存失效，也是进行参数特征转化 PFLAG_DRAWING_CACHE_VALID &#x3D;&gt; </span><br><span class="line">            &#x2F;&#x2F; PFLAG_INVALIDATED 要求</span><br><span class="line">            if (invalidateCache) &#123;</span><br><span class="line">                mPrivateFlags |&#x3D; PFLAG_INVALIDATED;</span><br><span class="line">                mPrivateFlags &amp;&#x3D; ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 向父View传递 invalidate 请求</span><br><span class="line">            final AttachInfo ai &#x3D; mAttachInfo;</span><br><span class="line">            final ViewParent p &#x3D; mParent;</span><br><span class="line">            if (p !&#x3D; null &amp;&amp; ai !&#x3D; null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">                &#x2F;&#x2F; 临时变量 Rect 用于做流程中复用的参数</span><br><span class="line">                &#x2F;&#x2F; draw 过程不建议反复创建对象。</span><br><span class="line">                final Rect damage &#x3D; ai.mTmpInvalRect;</span><br><span class="line">                damage.set(l, t, r, b);</span><br><span class="line">                p.invalidateChild(this, damage);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果背景设置了投影效果，则进行回调</span><br><span class="line">            if (mBackground !&#x3D; null &amp;&amp; mBackground.isProjected()) &#123;</span><br><span class="line">                final View receiver &#x3D; getProjectionReceiver();</span><br><span class="line">                if (receiver !&#x3D; null) &#123;</span><br><span class="line">                    receiver.damageInParent();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>invalidateInternal</code> 中处理：</p>
<ul>
<li>对flag 参数的转化和设置</li>
<li>通知父View 对该View invalidate 做出回应 <code>ViewParent.invalidateChild(View child, final Rect dirty)</code></li>
<li>如果设置投影背景，则回调 <code>View.damageInParent</code></li>
</ul>
<p>从代码中，我们可以看出主要负责处理<code>invalidate</code> 是在<code>invalidateChild</code> 中。</p>
<p>下面看 <code>invalidateChild</code> 部分:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.view.ViewGroup</span><br><span class="line"></span><br><span class="line"> public final void invalidateChild(View child, final Rect dirty) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果支持HW硬件加速的设备，进入该处理流程</span><br><span class="line">        if (attachInfo !&#x3D; null &amp;&amp; attachInfo.mHardwareAccelerated) &#123;</span><br><span class="line">            &#x2F;&#x2F; HW accelerated fast path</span><br><span class="line">            onDescendantInvalidated(child, child);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 非硬件加速的处理</span><br><span class="line"></span><br><span class="line">        ViewParent parent &#x3D; this;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>从代码中，以上流程将处理分为硬件和非硬件加速的处理，这里我们分开看。</p>
<h2 id="支持硬件加速处理（onDescendantInvalidated）"><a href="#支持硬件加速处理（onDescendantInvalidated）" class="headerlink" title="支持硬件加速处理（onDescendantInvalidated）"></a>支持硬件加速处理（onDescendantInvalidated）</h2><p>在之前的 <code>invalidateChild</code> 中，硬件加速自己调用 <code>onDescendantInvalidated</code> 进行处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.view.ViewGroup </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 该方法是对启用HW 渲染设备的处理，目前基本上都启用该模式</span><br><span class="line">    public void onDescendantInvalidated(@NonNull View child, @NonNull View target) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 如果子View需要执行动画，则需要添加 PFLAG_DRAW_ANIMATION 标记</span><br><span class="line">        &#x2F;&#x2F; 该标记会被父类消费，子View的动画需要父View进行配合，比如边界</span><br><span class="line">        </span><br><span class="line">        mPrivateFlags |&#x3D; (target.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 判断子View (target) 除了 invalidated 状态 (全渲染 或者</span><br><span class="line">        &#x2F;&#x2F; 局部要求)，是否还有其他 flag 标记</span><br><span class="line">        </span><br><span class="line">        if ((target.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) !&#x3D; 0) &#123;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 硬件加速渲染对不透明像素提供了优化，不需要进行处理</span><br><span class="line">            </span><br><span class="line">            mPrivateFlags &#x3D; (mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 去除 drawingCache valid 标识，保证安全</span><br><span class="line">            </span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果强制设置了软渲染则强制进行所有渲染，标记PFLAG_INVALIDATED</span><br><span class="line">        &#x2F;&#x2F; 、PFLAG_DIRTY</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        if (mLayerType &#x3D;&#x3D; LAYER_TYPE_SOFTWARE) &#123;</span><br><span class="line">            mPrivateFlags |&#x3D; PFLAG_INVALIDATED | PFLAG_DIRTY;</span><br><span class="line">            target &#x3D; this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 向上再执行父类的处理</span><br><span class="line">        if (mParent !&#x3D; null) &#123;</span><br><span class="line">            mParent.onDescendantInvalidated(this, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码中主要是纠正一些不必要的 flag 操作，以及对于 <code>layerType</code> 的处理。</p>
<ul>
<li>在硬件加速下，如果不只是处理 dirty 计算（硬件加速会自动计算范围），则对flag进行调整，移除 <code>PFLAG_DRAWING_CACHE_VALID</code> 标记，失效缓存。</li>
<li>如果 <code>LayerType</code> 所指定的类型为 <code>LAYER_TYPE_SOFTWARE</code> ，同时标记 <code>PFLAG_INVALIDATED</code>、<code>PFLAG_DIRTY</code>，添加强重绘要求</li>
<li>调用父ViewGroup <code>onDescendantInvalidated</code> 设置父<code>ViewGroup</code> 的调整，直到 <code>ViewRootImpl</code>。在目前<code>onDescendantInvalidated</code> 仅被 <code>ViewGroup</code>、<code>ViewRootImpl</code> 所处理。</li>
</ul>
<p>因此接下来我们看最终<code>ViewRootImpl</code>的处理。</p>
<p>在 <code>ViewRotImpl</code> 中处理动画状态，最终需要触发 <code>ViewRootImpl.performTraversals</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void onDescendantInvalidated(@NonNull View child, @NonNull View descendant) &#123;</span><br><span class="line">       &#x2F;&#x2F; descendant 为上一级 ViewGoup ，标记处于动画执行状态，并处罚下 ViewRootImpl 自身 invalidate 处理</span><br><span class="line">       if ((descendant.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) !&#x3D; 0) &#123;</span><br><span class="line">           mIsAnimating &#x3D; true;</span><br><span class="line">       &#125;</span><br><span class="line">       invalidate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>




<h2 id="非硬件加速"><a href="#非硬件加速" class="headerlink" title="非硬件加速"></a>非硬件加速</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">public final void invalidateChild(View child, final Rect dirty) &#123;</span><br><span class="line">       ...</span><br><span class="line">       &#x2F;&#x2F; 去除前面硬件加速的部分，以下为非硬件加速的处理</span><br><span class="line"></span><br><span class="line">       ViewParent parent &#x3D; this;</span><br><span class="line">       if (attachInfo !&#x3D; null) &#123;</span><br><span class="line">           &#x2F;&#x2F; 检查子View是否正在处理动画</span><br><span class="line">           final boolean drawAnimation &#x3D; (child.mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) !&#x3D; 0;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 子View的处理矩阵要求</span><br><span class="line">           Matrix childMatrix &#x3D; child.getMatrix();</span><br><span class="line">           </span><br><span class="line">           &#x2F;&#x2F; 如果当前设置了图层类型，则将当前View 图层标记 PFLAG_INVALIDATED</span><br><span class="line">           &#x2F;&#x2F; ，移除 PFLAG_DRAWING_CACHE_VALID 标记，表示 DrawingCache 失效</span><br><span class="line"></span><br><span class="line">           if (child.mLayerType !&#x3D; LAYER_TYPE_NONE) &#123;</span><br><span class="line">               mPrivateFlags |&#x3D; PFLAG_INVALIDATED;</span><br><span class="line">               mPrivateFlags &amp;&#x3D; ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 用于支持 Transformation 行为，对于重写 </span><br><span class="line">           &#x2F;&#x2F; getChildStaticTransformation 需要设置  </span><br><span class="line">           &#x2F;&#x2F; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS</span><br><span class="line">           </span><br><span class="line">           final int[] location &#x3D; attachInfo.mInvalidateChildLocation;</span><br><span class="line">           location[CHILD_LEFT_INDEX] &#x3D; child.mLeft;</span><br><span class="line">           location[CHILD_TOP_INDEX] &#x3D; child.mTop;</span><br><span class="line">           if (!childMatrix.isIdentity() ||</span><br><span class="line">                   (mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) !&#x3D; 0) &#123;</span><br><span class="line">               RectF boundingRect &#x3D; attachInfo.mTmpTransformRect;</span><br><span class="line">               boundingRect.set(dirty);</span><br><span class="line">               Matrix transformMatrix;</span><br><span class="line">               if ((mGroupFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) !&#x3D; 0) &#123;</span><br><span class="line">                   Transformation t &#x3D; attachInfo.mTmpTransformation;</span><br><span class="line">                   boolean transformed &#x3D; getChildStaticTransformation(child, t);</span><br><span class="line">                   if (transformed) &#123;</span><br><span class="line">                       transformMatrix &#x3D; attachInfo.mTmpMatrix;</span><br><span class="line">                       transformMatrix.set(t.getMatrix());</span><br><span class="line">                       if (!childMatrix.isIdentity()) &#123;</span><br><span class="line">                           transformMatrix.preConcat(childMatrix);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       transformMatrix &#x3D; childMatrix;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   transformMatrix &#x3D; childMatrix;</span><br><span class="line">               &#125;</span><br><span class="line">               transformMatrix.mapRect(boundingRect);</span><br><span class="line">               dirty.set((int) Math.floor(boundingRect.left),</span><br><span class="line">                       (int) Math.floor(boundingRect.top),</span><br><span class="line">                       (int) Math.ceil(boundingRect.right),</span><br><span class="line">                       (int) Math.ceil(boundingRect.bottom));</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 不断向上寻找父类执行 invalidateChildInParent，传递重绘事件</span><br><span class="line">           do &#123;</span><br><span class="line">               View view &#x3D; null;</span><br><span class="line">               if (parent instanceof View) &#123;</span><br><span class="line">                   view &#x3D; (View) parent;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (drawAnimation) &#123;</span><br><span class="line">                   if (view !&#x3D; null) &#123;</span><br><span class="line">                       view.mPrivateFlags |&#x3D; PFLAG_DRAW_ANIMATION;</span><br><span class="line">                   &#125; else if (parent instanceof ViewRootImpl) &#123;</span><br><span class="line">                       ((ViewRootImpl) parent).mIsAnimating &#x3D; true;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               &#x2F;&#x2F; 子View如果设置 PFLAG_DIRTY_MASK 则替换为 PFLAG_DIRTY</span><br><span class="line">               if (view !&#x3D; null) &#123;</span><br><span class="line">                   if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) !&#x3D; PFLAG_DIRTY) &#123;</span><br><span class="line">                       view.mPrivateFlags &#x3D; (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DIRTY;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               &#x2F;&#x2F; 向上不断的向父类申请计算 dirty 区域(需要重绘的影响区域)，直到 ViewRootImpl</span><br><span class="line">               </span><br><span class="line">               &#x2F;&#x2F; 如果设置有 PFLAG_DRAWING_CACHE_VALID 标记，则</span><br><span class="line">               &#x2F;&#x2F; </span><br><span class="line">               parent &#x3D; parent.invalidateChildInParent(location, dirty);</span><br><span class="line">               </span><br><span class="line">               if (view !&#x3D; null) &#123;</span><br><span class="line">                   &#x2F;&#x2F; Account for transform on current parent</span><br><span class="line">                   Matrix m &#x3D; view.getMatrix();</span><br><span class="line">                   if (!m.isIdentity()) &#123;</span><br><span class="line">                       RectF boundingRect &#x3D; attachInfo.mTmpTransformRect;</span><br><span class="line">                       boundingRect.set(dirty);</span><br><span class="line">                       m.mapRect(boundingRect);</span><br><span class="line">                       dirty.set((int) Math.floor(boundingRect.left),</span><br><span class="line">                               (int) Math.floor(boundingRect.top),</span><br><span class="line">                               (int) Math.ceil(boundingRect.right),</span><br><span class="line">                               (int) Math.ceil(boundingRect.bottom));</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; while (parent !&#x3D; null);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; android.view.ViewGroup</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F; 每层执行，都计算该层 location (left, top） 以及所需要绘制的 dirty 区域 （Rect）    </span><br><span class="line">     public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) &#123;</span><br><span class="line">     </span><br><span class="line">        &#x2F;&#x2F; 如果满足 PFLAG_DRAWN（要求绘制） 或者 PFLAG_DRAWING_CACHE_VALID（DrawingCache 有效） </span><br><span class="line">        &#x2F;&#x2F; 其中一个</span><br><span class="line">        if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID)) !&#x3D; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 如果 没有设置 FLAG_OPTIMIZE_INVALIDATE 或者 设置了 FLAG_OPTIMIZE_INVALIDATE 但是 view </span><br><span class="line">            &#x2F;&#x2F; 没有被设置正在运行或待运行的 animation ，这里表现的行为和 invalidate(Rect) 要求一致</span><br><span class="line">            &#x2F;&#x2F; 如果设置了 FLAG_OPTIMIZE_INVALIDATE 则表现为 invalidate() 一致，差距在于对dirty 测量</span><br><span class="line">            &#x2F;&#x2F; 区域的约束，第一个以申请Rect的边界为准，第二个以父类View边界为准</span><br><span class="line">            </span><br><span class="line">            if ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE))</span><br><span class="line">                    !&#x3D; FLAG_OPTIMIZE_INVALIDATE) &#123;</span><br><span class="line">                dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX,</span><br><span class="line">                        location[CHILD_TOP_INDEX] - mScrollY);</span><br><span class="line">                        </span><br><span class="line">                &#x2F;&#x2F; clipChildren &#x3D;&#x3D; false，则增加该View区域为整个dirty区域  ，申请dirty区域</span><br><span class="line">                &#x2F;&#x2F; 可能会超过父类本身</span><br><span class="line">                </span><br><span class="line">                if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    dirty.union(0, 0, mRight - mLeft, mBottom - mTop);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final int left &#x3D; mLeft;</span><br><span class="line">                final int top &#x3D; mTop;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果设置了 clipChildren &#x3D;&#x3D; true，则只对当前View区域交集的区域标记为 dirty 区域</span><br><span class="line">                &#x2F;&#x2F; 即只对所申请的区域（受到 clipChildren约束，最大不能超过当前ViewGroup的边界）进行申请</span><br><span class="line">                </span><br><span class="line">                if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) &#x3D;&#x3D; FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                    if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) &#123;</span><br><span class="line">                        dirty.setEmpty();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                location[CHILD_LEFT_INDEX] &#x3D; left;</span><br><span class="line">                location[CHILD_TOP_INDEX] &#x3D; top;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果设置有 FLAG_OPTIMIZE_INVALIDATE 或者 设置了 FLAG_OPTIMIZE_INVALIDATE,并且处于动画执行中的情况。</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; FLAG_OPTIMIZE_INVALIDATE标记 意味着使用 invalidate() 代替之前 invalidate(Rect)</span><br><span class="line">                &#x2F;&#x2F; 一旦设置了  clipChildren &#x3D;&#x3D; true 则表示需要对当前View整个边界进行重绘，</span><br><span class="line">                &#x2F;&#x2F; 而不是局部区域，否则只要累加当前View的区域作为dirty 需要重绘的区域即可</span><br><span class="line">            </span><br><span class="line">                &#x2F;&#x2F; clipChildren &#x3D;&#x3D; true ，则以当前View为dirty 区域</span><br><span class="line">                if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) &#x3D;&#x3D; FLAG_CLIP_CHILDREN) &#123;</span><br><span class="line">                    dirty.set(0, 0, mRight - mLeft, mBottom - mTop);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; clipChildren &#x3D; false , 增加当前View的区域为dirty 区域</span><br><span class="line">                    dirty.union(0, 0, mRight - mLeft, mBottom - mTop);</span><br><span class="line">                &#125;</span><br><span class="line">                location[CHILD_LEFT_INDEX] &#x3D; mLeft;</span><br><span class="line">                location[CHILD_TOP_INDEX] &#x3D; mTop;</span><br><span class="line">                &#x2F;&#x2F; 更新完view dirty 范围 移除需要 drawn 标记</span><br><span class="line">                mPrivateFlags &amp;&#x3D; ~PFLAG_DRAWN;</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags &amp;&#x3D; ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 指定了LayerType 的类型，则对图层标记当前  INVALIDATED ，需要被重绘</span><br><span class="line">            if (mLayerType !&#x3D; LAYER_TYPE_NONE) &#123;</span><br><span class="line">                 &#x2F;&#x2F; 更新完 dirty 区域范围则移除需要 invlidated 标记</span><br><span class="line">                mPrivateFlags |&#x3D; PFLAG_INVALIDATED;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 返回当前View的父View，继续测量dirty 区域</span><br><span class="line">            return mParent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>如果当前设备所启用的<code>soft layer</code> 渲染模式，那么最终会向上执行 <code>invalidateChildInParent</code> 直到顶层布局 <code>ViewRootImpl.invalidateChildInParent</code>(ViewRootImpl 对该方法返回为 null 终止向上继续 invalidate 通知要求)，以下看下该类的处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; com.view.ViewRootImpl</span><br><span class="line"></span><br><span class="line">    public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</span><br><span class="line">        &#x2F;&#x2F; invalidate 只能在 ViewRootImpl 所创建线程执行，即 ActivityThread 执行时的主线程</span><br><span class="line">        checkThread();</span><br><span class="line">        if (DEBUG_DRAW) Log.v(mTag, &quot;Invalidate child: &quot; + dirty);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果测量区域未指定，则刷新整个 ViewRootImpl 区域</span><br><span class="line">        if (dirty &#x3D;&#x3D; null) &#123;</span><br><span class="line">            invalidate();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果测量后所得的交叉区域为空，则表示没有dirty </span><br><span class="line">            &#x2F;&#x2F; 区域，并且没有正在执行的动画，则表示不需要进行重绘图层</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 执行到这是需要对dirty 区域进行处理了</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 处理滚动偏移，校正 dirty 计算区域</span><br><span class="line">        if (mCurScrollY !&#x3D; 0 || mTranslator !&#x3D; null) &#123;</span><br><span class="line">            mTempRect.set(dirty);</span><br><span class="line">            dirty &#x3D; mTempRect;</span><br><span class="line">            if (mCurScrollY !&#x3D; 0) &#123;</span><br><span class="line">                dirty.offset(0, -mCurScrollY);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mTranslator !&#x3D; null) &#123;</span><br><span class="line">                mTranslator.translateRectInAppWindowToScreen(dirty);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mAttachInfo.mScalingRequired) &#123;</span><br><span class="line">                dirty.inset(-1, -1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 进入绘制正题</span><br><span class="line">        invalidateRectOnScreen(dirty);</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   private void invalidateRectOnScreen(Rect dirty) &#123;</span><br><span class="line">   </span><br><span class="line">        &#x2F;&#x2F; 在ViewRootImpl 持有的 dirty Rect 记录值，记录最近所绘制的脏区域</span><br><span class="line">        final Rect localDirty &#x3D; mDirty;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 添加当前计算出来的dirty 区域添加到当前 ViewRootImpl dirty 区域中</span><br><span class="line">        localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</span><br><span class="line"></span><br><span class="line">        final float appScale &#x3D; mAttachInfo.mApplicationScale;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 计算dirty区域与当前指定View的区域是否相交</span><br><span class="line">        final boolean intersected &#x3D; localDirty.intersect(0, 0,</span><br><span class="line">                (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));</span><br><span class="line">                </span><br><span class="line">        &#x2F;&#x2F; 不相交则不需要进行绘制        </span><br><span class="line">        if (!intersected) &#123;</span><br><span class="line">            localDirty.setEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; mWillDrawSoon 确保当前没有在执行 performTraversals </span><br><span class="line">        &#x2F;&#x2F; 当前dirty 区域与 当前View存在相交关联，或者 正在执行动画，则进行重新图层绘制</span><br><span class="line">        if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用 Choreographer 进行下一帧同步更新</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>相对于硬件加速的处理，非硬件加速需要额外对dirty 区域进行一层一层计算，根据所传递的参数，比如<code>clipChildren</code>（true 所产生的影响比较小） 以及各个View层的边界情况，计算出一个合理的 dirty 区域，最终需要触发 <code>ViewRootImpl.performTraversals</code> 的处理</p>
<h1 id="ViewRootImpl-performTraversal"><a href="#ViewRootImpl-performTraversal" class="headerlink" title="ViewRootImpl.performTraversal"></a>ViewRootImpl.performTraversal</h1><p><code>pefformTraversal</code> 是系统上用于处理 <code>draw</code>、<code>layout</code>、<code>measure</code>的入口，通过对之前<code>invalidate</code>锁触发的参数计算，最终通过该方法对这些参数进行生效，并绘制新的图层。</p>
<p><code>performTraversal</code> 流程相对比较长，需要分段进行查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    &#x2F;&#x2F; mView 为 ViewRootImpl 下的第一个节点，ViewTree 的开始，一般为DecorView（Activity）</span><br><span class="line">    &#x2F;&#x2F; 需要注意的是 ViewRootImpl 并不是一个 View 而是一个 ViewParent 结构</span><br><span class="line">    &#x2F;&#x2F; 当Activity处于可见期时被维护在 WindowManager.mRoots 列表，</span><br><span class="line">    &#x2F;&#x2F; mView 是在 Activity 被 ActivityThread 创建时，经过 ActivityThread.handleLaunchActivity -&gt;</span><br><span class="line">    &#x2F;&#x2F; ActivityThread.handleResumeActivity 中产生，并执行 WindowManager.addView</span><br><span class="line">    &#x2F;&#x2F; 被添加到 WindowManagerGlobal.roots 中，此时 Activity 已处于 onResumed 状态</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通过 mView 可以索引所有的子View</span><br><span class="line">    final View host &#x3D; mView;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; mAdded 表示是否添加 DecorView 产生 ViewTree</span><br><span class="line">    if (host &#x3D;&#x3D; null || !mAdded)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 标记当前 ViewRootImpl 处于 performTraversals 处理中</span><br><span class="line">    </span><br><span class="line">    mIsInTraversal &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 在 performTraversals 完成 layout、measre 流程导致属性计算完成，</span><br><span class="line">    &#x2F;&#x2F; （未执行 draw 动作前）即标记为 false，当执行 scheduleTraversals</span><br><span class="line">    &#x2F;&#x2F; 之前会判断下该标记是否为 false，如果为 true 表示属性设置生效中</span><br><span class="line">    &#x2F;&#x2F; 不需要重新绘制，如果为true 表示已经完成 layout meaure 计算，需要</span><br><span class="line">    &#x2F;&#x2F; 重新触发刷新计算结果</span><br><span class="line"></span><br><span class="line">    mWillDrawSoon &#x3D; true;</span><br><span class="line">    boolean windowSizeMayChange &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F; 需要了解下 surface - surfaceflinger 机制</span><br><span class="line">    &#x2F;&#x2F; Android 中的View或子类都被呈现在Surface 中，</span><br><span class="line">    &#x2F;&#x2F; 每个Window 对应于一个Surface , 所产生的</span><br><span class="line">    &#x2F;&#x2F; Surface 最终被合成到 FrameBuffer。</span><br><span class="line">    &#x2F;&#x2F; Surface 是一个双缓冲模式，分为 back buffer</span><br><span class="line">    &#x2F;&#x2F; 和 front buffer，每次进行绘制 通过 front buffer</span><br><span class="line">    &#x2F;&#x2F; 进行合成，当完成显示后，则使用另外一个 back buffer</span><br><span class="line">    &#x2F;&#x2F; 作为下次合成的缓冲，如果再次进行则交互wei front buffer</span><br><span class="line">    &#x2F;&#x2F; 进行如此反复腾出 buffer 空间。</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line">    &#x2F;&#x2F; surface 通过 Canvas进行绘制操作代理(即 draw(Canvas) 中的</span><br><span class="line">    &#x2F;&#x2F; Canvas），而 Canvas 映射为一个 bitmap 对象，用于存储绘制</span><br><span class="line">    &#x2F;&#x2F; 数据。当执行 unlockCanvas()，则 buffer 变为可用。</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否为创建新 Surface</span><br><span class="line">    boolean newSurface &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Surface 发生变化标记</span><br><span class="line">    boolean surfaceChanged &#x3D; false;</span><br><span class="line">    WindowManager.LayoutParams lp &#x3D; mWindowAttributes;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 传递给顶层View measure 的原始width height</span><br><span class="line">    int desiredWindowWidth;</span><br><span class="line">    int desiredWindowHeight;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; getHostVisibility 检查当前App是否可见，或者如果被设定强制显示 Window.privateFlags </span><br><span class="line">    &#x2F;&#x2F; &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY !&#x3D; 0</span><br><span class="line">    </span><br><span class="line">    final int viewVisibility &#x3D; getHostVisibility();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; mFirst 表示是否为第一次进行绘制</span><br><span class="line">    &#x2F;&#x2F; mAppVisibilityChanged 用于标记可见性，防止处理过程中变化的可能性</span><br><span class="line">    final boolean viewVisibilityChanged &#x3D; !mFirst</span><br><span class="line">            &amp;&amp; (mViewVisibility !&#x3D; viewVisibility || mNewSurfaceNeeded</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; App 可见性变化</span><br><span class="line">            || mAppVisibilityChanged);</span><br><span class="line">            </span><br><span class="line">    &#x2F;&#x2F; 重置标记        </span><br><span class="line">    mAppVisibilityChanged &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果不是第一次绘制，相对于之前可见性，是否发生变化</span><br><span class="line">    final boolean viewUserVisibilityChanged &#x3D; !mFirst &amp;&amp;</span><br><span class="line">            ((mViewVisibility &#x3D;&#x3D; View.VISIBLE) !&#x3D; (viewVisibility &#x3D;&#x3D; View.VISIBLE));</span><br><span class="line"></span><br><span class="line">    WindowManager.LayoutParams params &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否 window 属性设置产生变化</span><br><span class="line">    </span><br><span class="line">    if (mWindowAttributesChanged) &#123;</span><br><span class="line">        mWindowAttributesChanged &#x3D; false;</span><br><span class="line">        surfaceChanged &#x3D; true;</span><br><span class="line">        params &#x3D; lp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    CompatibilityInfo compatibilityInfo &#x3D;</span><br><span class="line">            mDisplay.getDisplayAdjustments().getCompatibilityInfo();</span><br><span class="line">    if (compatibilityInfo.supportsScreen() &#x3D;&#x3D; mLastInCompatMode) &#123;</span><br><span class="line">        params &#x3D; lp;</span><br><span class="line">        mFullRedrawNeeded &#x3D; true;</span><br><span class="line">        mLayoutRequested &#x3D; true;</span><br><span class="line">        if (mLastInCompatMode) &#123;</span><br><span class="line">            params.privateFlags &amp;&#x3D; ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">            mLastInCompatMode &#x3D; false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            params.privateFlags |&#x3D; WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">            mLastInCompatMode &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindowAttributesChangesFlag &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Window的尺寸测量值，如果之前有计算过，也算是缓存</span><br><span class="line">    Rect frame &#x3D; mWinFrame;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 进入第一次的 绘制（整个ViewTree 来说）</span><br><span class="line">    if (mFirst) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 是否需要重绘全部内容 </span><br><span class="line">        mFullRedrawNeeded &#x3D; true;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 是否需要layout 你让</span><br><span class="line">        mLayoutRequested &#x3D; true;</span><br><span class="line"></span><br><span class="line">        final Configuration config &#x3D; mContext.getResources().getConfiguration();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 判断窗口是不是标准窗口(受到键盘、状态栏尺寸的影响)</span><br><span class="line">        if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">            &#x2F;&#x2F; 通过 Display 计算得到尺寸</span><br><span class="line">            Point size &#x3D; new Point();</span><br><span class="line">            mDisplay.getRealSize(size);</span><br><span class="line">            desiredWindowWidth &#x3D; size.x;</span><br><span class="line">            desiredWindowHeight &#x3D; size.y;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果不是 直接获得整个屏幕尺寸信息</span><br><span class="line">            desiredWindowWidth &#x3D; dipToPx(config.screenWidthDp);</span><br><span class="line">            desiredWindowHeight &#x3D; dipToPx(config.screenHeightDp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 为上下文 AttachInfo 设置基础属性</span><br><span class="line">        &#x2F;&#x2F; 默认使用 32 位 绘图</span><br><span class="line">        mAttachInfo.mUse32BitDrawingCache &#x3D; true;</span><br><span class="line">        mAttachInfo.mHasWindowFocus &#x3D; false;</span><br><span class="line">        mAttachInfo.mWindowVisibility &#x3D; viewVisibility;</span><br><span class="line">        mAttachInfo.mRecomputeGlobalAttributes &#x3D; false;</span><br><span class="line">        mLastConfigurationFromResources.setTo(config);</span><br><span class="line">        mLastSystemUiVisibility &#x3D; mAttachInfo.mSystemUiVisibility;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 为View 设置方向</span><br><span class="line">        </span><br><span class="line">        if (mViewLayoutDirectionInitial &#x3D;&#x3D; View.LAYOUT_DIRECTION_INHERIT) &#123;</span><br><span class="line">            host.setLayoutDirection(config.getLayoutDirection());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 执行 View.dispatchAttachedToWindow</span><br><span class="line">        </span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 执行 ViewTreeObserver.dispatchOnWindowAttachedChange 事件分发</span><br><span class="line">        </span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">        &#x2F;&#x2F;Log.i(mTag, &quot;Screen on initialized: &quot; + attachInfo.mKeepScreenOn);</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果不是第一次绘制，则使用以往的尺寸缓存信息设置</span><br><span class="line">    </span><br><span class="line">        desiredWindowWidth &#x3D; frame.width();</span><br><span class="line">        desiredWindowHeight &#x3D; frame.height();</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果实际的尺寸和当前尺寸预期不匹配，则标记对View进行重新测量和绘制</span><br><span class="line">        </span><br><span class="line">        if (desiredWindowWidth !&#x3D; mWidth || desiredWindowHeight !&#x3D; mHeight) &#123;</span><br><span class="line">            if (DEBUG_ORIENTATION) Log.v(mTag, &quot;View &quot; + host + &quot; resized to: &quot; + frame);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 标记重绘</span><br><span class="line">            mFullRedrawNeeded &#x3D; true;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 标记重新layout  </span><br><span class="line">            mLayoutRequested &#x3D; true;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 标记 window 尺寸发生变化</span><br><span class="line">            windowSizeMayChange &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果之前标记中，Window 可见性前后状态发生变化</span><br><span class="line">    </span><br><span class="line">    if (viewVisibilityChanged) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 重新赋值 AttachInfo 的可见性状态</span><br><span class="line">        mAttachInfo.mWindowVisibility &#x3D; viewVisibility;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 通知 子View 执行 dispatchWindowVisibilityChanged 事件分发</span><br><span class="line">        </span><br><span class="line">        host.dispatchWindowVisibilityChanged(viewVisibility);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 该属性 和 viewVisibilityChanged 相比，仅关注于当前View的可见性变化，对于</span><br><span class="line">        &#x2F;&#x2F; App Window 可见性不关心，发生变化同样通知 View.dispatchVisibilityAggregated</span><br><span class="line">        </span><br><span class="line">        if (viewUserVisibilityChanged) &#123;</span><br><span class="line">            host.dispatchVisibilityAggregated(viewVisibility &#x3D;&#x3D; View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果当前 View 变化为不可见，或者需要重建 Surface</span><br><span class="line">        &#x2F;&#x2F; 通知拖动响应关闭</span><br><span class="line">        &#x2F;&#x2F; 通知硬件层资源释放 ，即通知 ThreadedRenderer 执行 destroy 相关动作</span><br><span class="line">        </span><br><span class="line">        if (viewVisibility !&#x3D; View.VISIBLE || mNewSurfaceNeeded) &#123;</span><br><span class="line">            endDragResizing();</span><br><span class="line">            destroyHardwareResources();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果可见性为GONE 则追加当前窗口Window focus 状态 为false </span><br><span class="line">        if (viewVisibility &#x3D;&#x3D; View.GONE) &#123;</span><br><span class="line">            &#x2F;&#x2F; After making a window gone, we will count it as being</span><br><span class="line">            &#x2F;&#x2F; shown for the first time the next time it gets focus.</span><br><span class="line">            mHasHadWindowFocus &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Window 不可见取消 Accessibility focus</span><br><span class="line">    if (mAttachInfo.mWindowVisibility !&#x3D; View.VISIBLE) &#123;</span><br><span class="line">        host.clearAccessibilityFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将 AttachInfo Handler 代理放置到当前主线程 Queue 处理中，该Handler</span><br><span class="line">    &#x2F;&#x2F; 即为 View.post(Runnable) 常用的执行代理</span><br><span class="line">    </span><br><span class="line">    getRunQueue().executeActions(mAttachInfo.mHandler);</span><br><span class="line"></span><br><span class="line">    boolean insetsChanged &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 开始执行 layout 执行判断，需要满足</span><br><span class="line">    &#x2F;&#x2F; 在之前设置中 mLayoutRequested 为 true</span><br><span class="line">    &#x2F;&#x2F; 当前 Window 处于 active 状态</span><br><span class="line">    &#x2F;&#x2F; 当前没有被强制设置重绘（表示可能由于数据再次变化可能当次计算结果在下次也是无效的）</span><br><span class="line">    </span><br><span class="line">    boolean layoutRequested &#x3D; mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    if (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">        final Resources res &#x3D; mView.getContext().getResources();</span><br><span class="line"></span><br><span class="line">        if (mFirst) &#123;</span><br><span class="line">            &#x2F;&#x2F; 触摸模式支持</span><br><span class="line">            mAttachInfo.mInTouchMode &#x3D; !mAddedTouchMode;</span><br><span class="line">            ensureTouchModeLocally(mAddedTouchMode);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 判断之前设置的范围（比如内容范围位置）是否和当前一致，如果不一致</span><br><span class="line">            &#x2F;&#x2F; 标记 insetsChanged &#x3D; true ，便于后面重新处理</span><br><span class="line">            </span><br><span class="line">            if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) &#123;</span><br><span class="line">                mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                        + mAttachInfo.mVisibleInsets);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPendingAlwaysConsumeNavBar !&#x3D; mAttachInfo.mAlwaysConsumeNavBar) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果 Window 的 width、heigth 为适配内容的模式，</span><br><span class="line">            &#x2F;&#x2F; 则根据普通类型（存在状态栏、键盘占用等情况的）</span><br><span class="line">            &#x2F;&#x2F; 提供不同的 desiredWindowWidth、desiredWindowHeight</span><br><span class="line">            &#x2F;&#x2F; 以提供给后面的测量数据进行measure 的处理</span><br><span class="line">            if (lp.width &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                    || lp.height &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                windowSizeMayChange &#x3D; true;</span><br><span class="line"></span><br><span class="line">                if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Display 提供的尺寸自动扣除对 虚拟按键、键盘占用等的</span><br><span class="line">                    &#x2F;&#x2F; 系统公共占用的尺寸，得到一个可利用的尺寸</span><br><span class="line">                    Point size &#x3D; new Point();</span><br><span class="line">                    mDisplay.getRealSize(size);</span><br><span class="line">                    desiredWindowWidth &#x3D; size.x;</span><br><span class="line">                    desiredWindowHeight &#x3D; size.y;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Configuration config &#x3D; res.getConfiguration();</span><br><span class="line">                    desiredWindowWidth &#x3D; dipToPx(config.screenWidthDp);</span><br><span class="line">                    desiredWindowHeight &#x3D; dipToPx(config.screenHeightDp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 开始进行 measure 的测量询问，需要提供多大的尺寸值</span><br><span class="line">        </span><br><span class="line">        windowSizeMayChange |&#x3D; measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第一次-measure"><a href="#第一次-measure" class="headerlink" title="第一次 measure"></a>第一次 measure</h2><p>当获得 <code>layoutRequested == true</code> ，取决于必要条件<code>mLayoutRequested == true</code> </p>
<p>让 <code>mLayoutRequested == true</code>的情况有：</p>
<ul>
<li>View.requestLayout，触发该动作的同时 View 也会被加上 <code>PFLAG_FORCE_LAYOUT</code>、<code>PFLAG_INVALIDATED</code> 标记</li>
<li>当当前整个ViewTree 属于第一次绘制时，则默认 <code>mLayoutRequested == true</code></li>
<li>如果当前Window 是窗口尺寸发生变化（拖动窗口模式）则也会导致  <code>mLayoutRequested == true</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 开始执行 layout 执行判断，需要满足</span><br><span class="line">    &#x2F;&#x2F; 在之前设置中 mLayoutRequested 为 true</span><br><span class="line">    &#x2F;&#x2F; 当前 Window 处于 active 状态</span><br><span class="line">    &#x2F;&#x2F; 当前没有被强制设置重绘（表示可能由于数据再次变化可能当次计算结果在下次也是无效的）</span><br><span class="line">    </span><br><span class="line">    boolean layoutRequested &#x3D; mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    if (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">        final Resources res &#x3D; mView.getContext().getResources();</span><br><span class="line"></span><br><span class="line">        if (mFirst) &#123;</span><br><span class="line">            &#x2F;&#x2F; 触摸模式支持</span><br><span class="line">            mAttachInfo.mInTouchMode &#x3D; !mAddedTouchMode;</span><br><span class="line">            ensureTouchModeLocally(mAddedTouchMode);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 判断之前设置的范围（比如内容范围位置）是否和当前一致，如果不一致</span><br><span class="line">            &#x2F;&#x2F; 标记 insetsChanged &#x3D; true ，便于后面重新处理</span><br><span class="line">            </span><br><span class="line">            if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) &#123;</span><br><span class="line">                mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                        + mAttachInfo.mVisibleInsets);</span><br><span class="line">            &#125;</span><br><span class="line">            if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mPendingAlwaysConsumeNavBar !&#x3D; mAttachInfo.mAlwaysConsumeNavBar) &#123;</span><br><span class="line">                insetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果 Window 的 width、heigth 为适配内容的模式，</span><br><span class="line">            &#x2F;&#x2F; 则根据普通类型（存在状态栏、键盘占用等情况的）</span><br><span class="line">            &#x2F;&#x2F; 提供不同的 desiredWindowWidth、desiredWindowHeight</span><br><span class="line">            &#x2F;&#x2F; 以提供给后面的测量数据进行measure 的处理</span><br><span class="line">            if (lp.width &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                    || lp.height &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                windowSizeMayChange &#x3D; true;</span><br><span class="line"></span><br><span class="line">                if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                    &#x2F;&#x2F; Display 提供的尺寸自动扣除对 虚拟按键、键盘占用等的</span><br><span class="line">                    &#x2F;&#x2F; 系统公共占用的尺寸，得到一个可利用的尺寸</span><br><span class="line">                    Point size &#x3D; new Point();</span><br><span class="line">                    mDisplay.getRealSize(size);</span><br><span class="line">                    desiredWindowWidth &#x3D; size.x;</span><br><span class="line">                    desiredWindowHeight &#x3D; size.y;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    Configuration config &#x3D; res.getConfiguration();</span><br><span class="line">                    desiredWindowWidth &#x3D; dipToPx(config.screenWidthDp);</span><br><span class="line">                    desiredWindowHeight &#x3D; dipToPx(config.screenHeightDp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 开始进行 measure 的测量询问，需要提供多大的尺寸值</span><br><span class="line">        </span><br><span class="line">        windowSizeMayChange |&#x3D; measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据条件计算出 <code>desiredWindowWidth</code>、<code>desiredWindowHeight</code> 信息后既可以执行<code>measureHierarchy</code></p>
<h3 id="measureHierarchy"><a href="#measureHierarchy" class="headerlink" title="measureHierarchy"></a>measureHierarchy</h3><p><code>measureHierarchy</code> 主要对非全尺寸（MATCH_PARNT）进行处理：</p>
<ul>
<li>尝试使用 config_prefDialogWidth 值进行分配</li>
<li>如果不能满足子View的测量需要，则重新分配 (baseSize+desiredWindowWidth)/2，再次重新测量</li>
<li>如果还不能满足，则使用最终提供的 desiredWindowWidth、desiredWindowHeight 进行测量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp,</span><br><span class="line">        final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) &#123;</span><br><span class="line">        </span><br><span class="line">    int childWidthMeasureSpec;</span><br><span class="line">    int childHeightMeasureSpec;</span><br><span class="line">    boolean windowSizeMayChange &#x3D; false;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">            &quot;Measuring &quot; + host + &quot; in display &quot; + desiredWindowWidth</span><br><span class="line">            + &quot;x&quot; + desiredWindowHeight + &quot;...&quot;);</span><br><span class="line"></span><br><span class="line">    boolean goodMeasure &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Window 的 width 为     WRAP_CONTENT</span><br><span class="line">    </span><br><span class="line">    if (lp.width &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 这里官方不希望直接拉伸到整个屏幕的尺寸作为测量值，使用一个默认的固定值</span><br><span class="line">        &#x2F;&#x2F; config_prefDialogWidth 作为尝试</span><br><span class="line">        </span><br><span class="line">        final DisplayMetrics packageMetrics &#x3D; res.getDisplayMetrics();</span><br><span class="line">        res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, true);</span><br><span class="line">        int baseSize &#x3D; 0;</span><br><span class="line">        if (mTmpValue.type &#x3D;&#x3D; TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">            baseSize &#x3D; (int)mTmpValue.getDimension(packageMetrics);</span><br><span class="line">        &#125;</span><br><span class="line">        if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: baseSize&#x3D;&quot; + baseSize</span><br><span class="line">                + &quot;, desiredWindowWidth&#x3D;&quot; + desiredWindowWidth);</span><br><span class="line">                </span><br><span class="line">        &#x2F;&#x2F; 如果尝试的值不为 0 并且小于 desiredWindowWidth ( 所提供的最大可分配区域的宽 )   则符合</span><br><span class="line">        &#x2F;&#x2F; 尝试条件</span><br><span class="line">        if (baseSize !&#x3D; 0 &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 根据 WRAP_CONTENT、MATCH_PARENT 或绝对尺寸去获得值</span><br><span class="line">            &#x2F;&#x2F; 当为 MATCH_PARENT 时，则使用 baseSize +  MeasureSpec.EXACTLY</span><br><span class="line">            &#x2F;&#x2F; 当为 WRAP_CONTENT 时，则使用 baseSize +  MeasureSpec.AT_MOST</span><br><span class="line">            &#x2F;&#x2F; 当为 固定尺寸时，使用 指定尺寸 + MeasureSpec.EXACTLY</span><br><span class="line">            </span><br><span class="line">            childWidthMeasureSpec &#x3D; getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">            childHeightMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 执行 mView 的 measure 流程</span><br><span class="line">            </span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            </span><br><span class="line">            if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: measured (&quot;</span><br><span class="line">                    + host.getMeasuredWidth() + &quot;,&quot; + host.getMeasuredHeight()</span><br><span class="line">                    + &quot;) from width spec: &quot; + MeasureSpec.toString(childWidthMeasureSpec)</span><br><span class="line">                    + &quot; and height spec: &quot; + MeasureSpec.toString(childHeightMeasureSpec));</span><br><span class="line">                    </span><br><span class="line">            &#x2F;&#x2F; 如果刚好满足分配 则 标记 goodMeasure &#x3D; true        </span><br><span class="line">            if ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL</span><br><span class="line">            ) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                goodMeasure &#x3D; true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果提供的测量尺寸比子View所申请的少，则会返回状态 MEASURED_STATE_TOO_SMALL</span><br><span class="line">            &#x2F;&#x2F; 进入该处理</span><br><span class="line">            </span><br><span class="line">                &#x2F;&#x2F; 尝试在重新分配一个尺寸继续重新进行测量 measue</span><br><span class="line">                </span><br><span class="line">                baseSize &#x3D; (baseSize+desiredWindowWidth)&#x2F;2;</span><br><span class="line">                if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: next baseSize&#x3D;&quot;</span><br><span class="line">                        + baseSize);</span><br><span class="line">                childWidthMeasureSpec &#x3D; getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                if (DEBUG_DIALOG) Log.v(mTag, &quot;Window &quot; + mView + &quot;: measured (&quot;</span><br><span class="line">                        + host.getMeasuredWidth() + &quot;,&quot; + host.getMeasuredHeight() + &quot;)&quot;);</span><br><span class="line">                        </span><br><span class="line">                &#x2F;&#x2F; 对再次测量的结果进行结果校验            </span><br><span class="line">                if ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    if (DEBUG_DIALOG) Log.v(mTag, &quot;Good!&quot;);</span><br><span class="line">                    goodMeasure &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    if (!goodMeasure) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 如果分配的尝试分配的尺寸在测量结果反馈中，无法满足子View的需要</span><br><span class="line">        &#x2F;&#x2F; 则使用系统提供 desiredWindowWidth、desiredWindowHeight 再次重新</span><br><span class="line">        &#x2F;&#x2F; 测量计算</span><br><span class="line">        </span><br><span class="line">        childWidthMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">        childHeightMeasureSpec &#x3D; getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 标记结果也之前不一样的变更</span><br><span class="line">        if (mWidth !&#x3D; host.getMeasuredWidth() || mHeight !&#x3D; host.getMeasuredHeight()) &#123;</span><br><span class="line">            windowSizeMayChange &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DBG) &#123;</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">        System.out.println(&quot;performTraversals -- after measure&quot;);</span><br><span class="line">        host.debug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return windowSizeMayChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二次-measure"><a href="#二次-measure" class="headerlink" title="二次 measure"></a>二次 measure</h3><ul>
<li>设置 软键盘 resizeMode 模式</li>
<li>设置 WindowMananger.LayoutParams 的参数校正<ul>
<li>保持与 mView(DecorView)  PFLAG_REQUEST_TRANSPARENT_REGIONS 透明支持</li>
<li>如果需要支持 Overscan 则同步参数信息到 AttachInfo </li>
</ul>
</li>
<li>如果 requestFitSystemWindows 对于 fitSystemWindows == true, 则调动  dispatchApplyInsets 触发 insets 计算，如果同时 <code>mLayoutRequested == true</code>，则重新进行一次 measure 再次刷新测量值。 </li>
<li>mLayoutRequested 置为 false ，消费完成当次对于 requestLayotu 的要求</li>
<li>处理 Window 窗口拖动及其 Size 变化流程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理 AttachInfo ，如果发生变更，则同时也需要更新WindowMananer.LayoutParam 信息</span><br><span class="line">    if (collectViewAttributes()) &#123;</span><br><span class="line">        params &#x3D; lp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果标记有 mForceReportNewAttributesz 则强制进行更新</span><br><span class="line">    if (mAttachInfo.mForceReportNewAttributesz) &#123;</span><br><span class="line">        mAttachInfo.mForceReportNewAttributes &#x3D; false;</span><br><span class="line">        params &#x3D; lp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 设置软键盘模式</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    if (mFirst || mAttachInfo.mViewVisibilityChanged) &#123;</span><br><span class="line">        mAttachInfo.mViewVisibilityChanged &#x3D; false;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 获取设置的软键盘模式</span><br><span class="line">        int resizeMode &#x3D; mSoftInpu</span><br><span class="line">        tMode &amp;</span><br><span class="line">                WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;</span><br><span class="line">                </span><br><span class="line">        &#x2F;&#x2F; 如果未指定软键盘模式，则根据情况进行自动设置</span><br><span class="line">        </span><br><span class="line">        if (resizeMode &#x3D;&#x3D; WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;</span><br><span class="line">            final int N &#x3D; mAttachInfo.mScrollContainers.size();</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果存在 Scroller 则选择 SOFT_INPUT_ADJUST_RESIZE</span><br><span class="line">        </span><br><span class="line">            </span><br><span class="line">            for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">                if (mAttachInfo.mScrollContainers.get(i).isShown()) &#123;</span><br><span class="line">                    resizeMode &#x3D; WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果没有则设置 SOFT_INPUT_ADJUST_PAN</span><br><span class="line">            </span><br><span class="line">            if (resizeMode &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                resizeMode &#x3D; WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果 WindowManager.LayoutParam.softInputMode 里面设置和当前不一致，</span><br><span class="line">            &#x2F;&#x2F; 则重置为当前匹配的 softInputMode</span><br><span class="line">            </span><br><span class="line">            if ((lp.softInputMode &amp;</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) !&#x3D; resizeMode) &#123;</span><br><span class="line">                lp.softInputMode &#x3D; (lp.softInputMode &amp;</span><br><span class="line">                        ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) |</span><br><span class="line">                        resizeMode;</span><br><span class="line">                params &#x3D; lp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 参数同步</span><br><span class="line">    if (params !&#x3D; null) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 如果窗口不支持透明，但是 mView 设置有 PFLAG_REQUEST_TRANSPARENT_REGIONS 要求，则改变 为 </span><br><span class="line">        &#x2F;&#x2F; PixelFormat.TRANSLUCENT</span><br><span class="line">        </span><br><span class="line">        if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) !&#x3D; 0) &#123;</span><br><span class="line">            if (!PixelFormat.formatHasAlpha(params.format)) &#123;</span><br><span class="line">                params.format &#x3D; PixelFormat.TRANSLUCENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; ovsersacn 的TV模式的一种处理，手机上不必关心</span><br><span class="line">        mAttachInfo.mOverscanRequested &#x3D; (params.flags</span><br><span class="line">                &amp; WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) !&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 响应 requestFitSystemWindows 配置要求 </span><br><span class="line">    </span><br><span class="line">    if (mApplyInsetsRequested) &#123;</span><br><span class="line">        mApplyInsetsRequested &#x3D; false;</span><br><span class="line">        mLastOverscanRequested &#x3D; mAttachInfo.mOverscanRequested;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 将触发 mView 及其子View dispatchApplyWindowInsets 的适配</span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 在执行 dispatchApplyInsets 中检查是否需要对 requestLayout 做出处理，</span><br><span class="line">        &#x2F;&#x2F; 再次重新进行测量</span><br><span class="line">        if (mLayoutRequested) &#123;</span><br><span class="line">            windowSizeMayChange |&#x3D; measureHierarchy(host, lp,</span><br><span class="line">                    mView.getContext().getResources(),</span><br><span class="line">                    desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果已经布局完成，清空布局标记，如果在后面回调中还有需要布局的情况，则通过 mLayoutRequested </span><br><span class="line">    &#x2F;&#x2F; 进行状态查询</span><br><span class="line">    </span><br><span class="line">    if (layoutRequested) &#123;</span><br><span class="line">        mLayoutRequested &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Window-measure-及其-Size-变化的处理"><a href="#Window-measure-及其-Size-变化的处理" class="headerlink" title="Window measure 及其 Size 变化的处理"></a>Window measure 及其 Size 变化的处理</h3><p>measure 之后存在对于 Window 拖动支持（多窗口）以及Size变化的同步更新，<br>这里面涉及到 Surface、RenderedThread 等处理。</p>
<p>在处理过程中，需要重复调用 performMeasure 的流程。</p>
<p>触发该流程的需要满足 Window size 前后发生变化或者第一次进行布局时Window的测量的初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">    &#x2F;&#x2F; 这里之后处理 Window Size 变化，如果 Window 处于 drag 状态，则</span><br><span class="line">    &#x2F;&#x2F; 通过这里进行相关数据变更，以及同步绘制刷新（Surface）</span><br><span class="line">    </span><br><span class="line">    boolean windowShouldResize &#x3D; layoutRequested &amp;&amp; windowSizeMayChange</span><br><span class="line">        &amp;&amp; ((mWidth !&#x3D; host.getMeasuredWidth() || mHeight !&#x3D; host.getMeasuredHeight())</span><br><span class="line">            || (lp.width &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                    frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() !&#x3D; mWidth)</span><br><span class="line">            || (lp.height &#x3D;&#x3D; ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                    frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() !&#x3D; mHeight));</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; mDragResizing 是否处于对Window拖动尺寸变化，并且 resizeMode 是否为 freeform 模式</span><br><span class="line">    &#x2F;&#x2F; Freeform 模式是 Android N Multi-Window 自由窗口模式，自由模式下可以对窗口进行自</span><br><span class="line">    &#x2F;&#x2F; 由缩放、移动</span><br><span class="line">    </span><br><span class="line">    windowShouldResize |&#x3D; mDragResizing &amp;&amp; mResizeMode &#x3D;&#x3D; RESIZE_MODE_FREEFORM;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 Activity 重新被启动，则处于未被分配size的时候，则进行 resize 行为</span><br><span class="line">    </span><br><span class="line">    windowShouldResize |&#x3D; mActivityRelaunched;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ViewTreeObserver 如果有监听，或者在之前旧的 inset 计算中，旧的insets 结果不会为空</span><br><span class="line">    &#x2F;&#x2F; 则需要重新计算更新 inset 内容</span><br><span class="line">    final boolean computesInternalInsets &#x3D;</span><br><span class="line">            mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners()</span><br><span class="line">            || mAttachInfo.mHasNonEmptyGivenInternalInsets;</span><br><span class="line"></span><br><span class="line">    boolean insetsPending &#x3D; false;</span><br><span class="line">    int relayoutResult &#x3D; 0;</span><br><span class="line">    boolean updatedConfiguration &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 获得 surface id</span><br><span class="line">    final int surfaceGenerationId &#x3D; mSurface.getGenerationId();</span><br><span class="line"></span><br><span class="line">    final boolean isViewVisible &#x3D; viewVisibility &#x3D;&#x3D; View.VISIBLE;</span><br><span class="line">    final boolean windowRelayoutWasForced &#x3D; mForceNextWindowRelayout;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第一次绘制也会允许进行</span><br><span class="line">    </span><br><span class="line">    if (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params !&#x3D; null || mForceNextWindowRelayout) &#123;</span><br><span class="line">        mForceNextWindowRelayout &#x3D; false;</span><br><span class="line"></span><br><span class="line">        if (isViewVisible) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 标记 inset 要求</span><br><span class="line">            </span><br><span class="line">            insetsPending &#x3D; computesInternalInsets &amp;&amp; (mFirst || viewVisibilityChanged);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        if (mSurfaceHolder !&#x3D; null) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; ReentrantLock 锁，用于Surface 进行 Canvas 操作的锁</span><br><span class="line">            &#x2F;&#x2F; 标记允许进行 draw</span><br><span class="line">            </span><br><span class="line">            mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">            mDrawingAllowed &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean hwInitialized &#x3D; false;</span><br><span class="line">        boolean contentInsetsChanged &#x3D; false;</span><br><span class="line">        boolean hadSurface &#x3D; mSurface.isValid();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (DEBUG_LAYOUT) &#123;</span><br><span class="line">                Log.i(mTag, &quot;host&#x3D;w:&quot; + host.getMeasuredWidth() + &quot;, h:&quot; +</span><br><span class="line">                        host.getMeasuredHeight() + &quot;, params&#x3D;&quot; + params);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 重置 ThreadRenderer, 如果 ThreadRenderer 绘制的行为，则终止</span><br><span class="line">            </span><br><span class="line">            if (mAttachInfo.mThreadedRenderer !&#x3D; null) &#123;</span><br><span class="line">                (mAttachInfo.mThreadedRenderer.pauseSurface(mSurface)) &#123;</span><br><span class="line">            </span><br><span class="line">                    mDirty.set(0, 0, mWidth, mHeight);</span><br><span class="line">                &#125;</span><br><span class="line">                mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 调用 IBinder 请求 WindowManagerService 进行 relayout 变化，对Window</span><br><span class="line">            &#x2F;&#x2F; 窗口进行变更</span><br><span class="line">            </span><br><span class="line">            relayoutResult &#x3D; relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line"></span><br><span class="line">            if (DEBUG_LAYOUT) Log.v(mTag, &quot;relayout: frame&#x3D;&quot; + frame.toShortString()</span><br><span class="line">                    + &quot; overscan&#x3D;&quot; + mPendingOverscanInsets.toShortString()</span><br><span class="line">                    + &quot; content&#x3D;&quot; + mPendingContentInsets.toShortString()</span><br><span class="line">                    + &quot; visible&#x3D;&quot; + mPendingVisibleInsets.toShortString()</span><br><span class="line">                    + &quot; visible&#x3D;&quot; + mPendingStableInsets.toShortString()</span><br><span class="line">                    + &quot; outsets&#x3D;&quot; + mPendingOutsets.toShortString()</span><br><span class="line">                    + &quot; surface&#x3D;&quot; + mSurface);</span><br><span class="line"></span><br><span class="line">           &#x2F;&#x2F; 检查是否 configuartion 和之前是否变化，更新本地configuration状态</span><br><span class="line">            if (!mPendingMergedConfiguration.equals(mLastReportedMergedConfiguration)) &#123;</span><br><span class="line">                if (DEBUG_CONFIGURATION) Log.v(mTag, &quot;Visible with new config: &quot;</span><br><span class="line">                        + mPendingMergedConfiguration.getMergedConfiguration());</span><br><span class="line">                performConfigurationChange(mPendingMergedConfiguration, !mFirst,</span><br><span class="line">                        INVALID_DISPLAY &#x2F;* same display *&#x2F;);</span><br><span class="line">                updatedConfiguration &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 检查 各个 Inset 和之前是否发生变化 ，并读变化的 inset</span><br><span class="line">            &#x2F;&#x2F; 进行更新（AttachInfo.xxx.set)</span><br><span class="line">            </span><br><span class="line">            final boolean overscanInsetsChanged &#x3D; !mPendingOverscanInsets.equals(</span><br><span class="line">                    mAttachInfo.mOverscanInsets);</span><br><span class="line">            contentInsetsChanged &#x3D; !mPendingContentInsets.equals(</span><br><span class="line">                    mAttachInfo.mContentInsets);</span><br><span class="line">            final boolean visibleInsetsChanged &#x3D; !mPendingVisibleInsets.equals(</span><br><span class="line">                    mAttachInfo.mVisibleInsets);</span><br><span class="line">            final boolean stableInsetsChanged &#x3D; !mPendingStableInsets.equals(</span><br><span class="line">                    mAttachInfo.mStableInsets);</span><br><span class="line">            final boolean outsetsChanged &#x3D; !mPendingOutsets.equals(mAttachInfo.mOutsets);</span><br><span class="line">            final boolean surfaceSizeChanged &#x3D; (relayoutResult</span><br><span class="line">                    &amp; WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) !&#x3D; 0;</span><br><span class="line">            final boolean alwaysConsumeNavBarChanged &#x3D;</span><br><span class="line">                    mPendingAlwaysConsumeNavBar !&#x3D; mAttachInfo.mAlwaysConsumeNavBar;</span><br><span class="line">            if (contentInsetsChanged) &#123;</span><br><span class="line">                mAttachInfo.mContentInsets.set(mPendingContentInsets);</span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Content insets changing to: &quot;</span><br><span class="line">                        + mAttachInfo.mContentInsets);</span><br><span class="line">            &#125;</span><br><span class="line">            if (overscanInsetsChanged) &#123;</span><br><span class="line">                mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);</span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Overscan insets changing to: &quot;</span><br><span class="line">                        + mAttachInfo.mOverscanInsets);</span><br><span class="line">                &#x2F;&#x2F; Need to relayout with content insets.</span><br><span class="line">                contentInsetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (stableInsetsChanged) &#123;</span><br><span class="line">                mAttachInfo.mStableInsets.set(mPendingStableInsets);</span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Decor insets changing to: &quot;</span><br><span class="line">                        + mAttachInfo.mStableInsets);</span><br><span class="line">                &#x2F;&#x2F; Need to relayout with content insets.</span><br><span class="line">                contentInsetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            if (alwaysConsumeNavBarChanged) &#123;</span><br><span class="line">                mAttachInfo.mAlwaysConsumeNavBar &#x3D; mPendingAlwaysConsumeNavBar;</span><br><span class="line">                contentInsetsChanged &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果任意 Inset 产生变化</span><br><span class="line">            if (contentInsetsChanged || mLastSystemUiVisibility !&#x3D;</span><br><span class="line">                    mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested</span><br><span class="line">                    || mLastOverscanRequested !&#x3D; mAttachInfo.mOverscanRequested</span><br><span class="line">                    || outsetsChanged) &#123;</span><br><span class="line">                    </span><br><span class="line">                &#x2F;&#x2F; 更新    mLastSystemUiVisibility</span><br><span class="line">                mLastSystemUiVisibility &#x3D; mAttachInfo.mSystemUiVisibility;</span><br><span class="line">                mLastOverscanRequested &#x3D; mAttachInfo.mOverscanRequested;</span><br><span class="line">                mAttachInfo.mOutsets.set(mPendingOutsets);</span><br><span class="line">                mApplyInsetsRequested &#x3D; false;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 通知 mView 及其子 View dispatchApplyWindowInsets 处理</span><br><span class="line">                dispatchApplyInsets(host);</span><br><span class="line">            &#125;</span><br><span class="line">            if (visibleInsetsChanged) &#123;</span><br><span class="line">                mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                        + mAttachInfo.mVisibleInsets);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 没有可用 surface</span><br><span class="line">            if (!hadSurface) &#123;</span><br><span class="line">                &#x2F;&#x2F; 和之前的判断不一致，可能在绘制过程中产生的，需要重新处理</span><br><span class="line">                if (mSurface.isValid()) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 标记需要新建一个 Surface，并且完全重绘</span><br><span class="line">                    newSurface &#x3D; true;</span><br><span class="line">                    mFullRedrawNeeded &#x3D; true;</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; 清空之前透明区域的请求</span><br><span class="line">                    mPreviousTransparentRegion.setEmpty();</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 重新对 ThreadedRenderer 、Surface 进行清空初始化</span><br><span class="line">                    if (mAttachInfo.mThreadedRenderer !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            hwInitialized &#x3D; mAttachInfo.mThreadedRenderer.initialize(</span><br><span class="line">                                    mSurface);</span><br><span class="line">                            if (hwInitialized &amp;&amp; (host.mPrivateFlags</span><br><span class="line">                                    &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                &#x2F;&#x2F; Don&#39;t pre-allocate if transparent regions</span><br><span class="line">                                &#x2F;&#x2F; are requested as they may not be needed</span><br><span class="line">                                mSurface.allocateBuffers();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                            handleOutOfResourcesException(e);</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!mSurface.isValid()) &#123;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; Surface 已经失效，重置 scroller 相关工作，并且终止 ThreadedRenderer </span><br><span class="line">                if (mLastScrolledFocus !&#x3D; null) &#123;</span><br><span class="line">                    mLastScrolledFocus.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                mScrollY &#x3D; mCurScrollY &#x3D; 0;</span><br><span class="line">                if (mView instanceof RootViewSurfaceTaker) &#123;</span><br><span class="line">                    ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mScroller !&#x3D; null) &#123;</span><br><span class="line">                    mScroller.abortAnimation();</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                if (mAttachInfo.mThreadedRenderer !&#x3D; null &amp;&amp;</span><br><span class="line">                        mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">                    mAttachInfo.mThreadedRenderer.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if ((surfaceGenerationId !&#x3D; mSurface.getGenerationId()</span><br><span class="line">                    || surfaceSizeChanged || windowRelayoutWasForced)</span><br><span class="line">                    &amp;&amp; mSurfaceHolder &#x3D;&#x3D; null</span><br><span class="line">                    &amp;&amp; mAttachInfo.mThreadedRenderer !&#x3D; null) &#123;</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; Surface 已经产生变化，需要重新更新 Surface </span><br><span class="line">                    </span><br><span class="line">                mFullRedrawNeeded &#x3D; true;</span><br><span class="line">                try &#123;</span><br><span class="line">                    mAttachInfo.mThreadedRenderer.updateSurface(mSurface);</span><br><span class="line">                &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                    handleOutOfResourcesException(e);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Window 拖动窗口尺寸的处理</span><br><span class="line">            </span><br><span class="line">            final boolean freeformResizing &#x3D; (relayoutResult</span><br><span class="line">                    &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) !&#x3D; 0;</span><br><span class="line">            final boolean dockedResizing &#x3D; (relayoutResult</span><br><span class="line">                    &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG86_RESIZING_DOCKED) !&#x3D; 0;</span><br><span class="line">            final boolean dragResizing &#x3D; freeformResizing || dockedResizing;</span><br><span class="line">            if (mDragResizing !&#x3D; dragResizing) &#123;</span><br><span class="line">                if (dragResizing) &#123;</span><br><span class="line">                    mResizeMode &#x3D; freeformResizing</span><br><span class="line">                            ? RESIZE_MODE_FREEFORM</span><br><span class="line">                            : RESIZE_MODE_DOCKED_DIVIDER;</span><br><span class="line">                            </span><br><span class="line">                    &#x2F;&#x2F; 开始执行拖动大小调整效果   </span><br><span class="line">                    </span><br><span class="line">                    startDragResizing(mPendingBackDropFrame,</span><br><span class="line">                            mWinFrame.equals(mPendingBackDropFrame), mPendingVisibleInsets,</span><br><span class="line">                            mPendingStableInsets, mResizeMode);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F; 一般不会执行到这，主动执行结束拖动大小调整的效果</span><br><span class="line">                    </span><br><span class="line">                    endDragResizing();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果没有启用多线程渲染</span><br><span class="line">            if (!USE_MT_RENDERER) &#123;</span><br><span class="line">            </span><br><span class="line">                &#x2F;&#x2F; 更新拖动过程中的 CanvasOffset 状态</span><br><span class="line">                if (dragResizing) &#123;</span><br><span class="line">                    mCanvasOffsetX &#x3D; mWinFrame.left;</span><br><span class="line">                    mCanvasOffsetY &#x3D; mWinFrame.top;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mCanvasOffsetX &#x3D; mCanvasOffsetY &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_ORIENTATION) Log.v(</span><br><span class="line">                TAG, &quot;Relayout returned: frame&#x3D;&quot; + frame + &quot;, surface&#x3D;&quot; + mSurface);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 更新 Window 位置信息及尺寸 </span><br><span class="line">        </span><br><span class="line">        mAttachInfo.mWindowLeft &#x3D; frame.left;</span><br><span class="line">        mAttachInfo.mWindowTop &#x3D; frame.top;</span><br><span class="line"></span><br><span class="line">        if (mWidth !&#x3D; frame.width() || mHeight !&#x3D; frame.height()) &#123;</span><br><span class="line">            mWidth &#x3D; frame.width();</span><br><span class="line">            mHeight &#x3D; frame.height();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果 SurfaceHolder 可用</span><br><span class="line">        if (mSurfaceHolder !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 当前 Surface 可用，将更新到当前SurfaceHolder </span><br><span class="line">            if (mSurface.isValid()) &#123;</span><br><span class="line">                mSurfaceHolder.mSurface &#x3D; mSurface;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 更新 Surface 的尺寸信息</span><br><span class="line">            mSurfaceHolder.setSurfaceFrameSize(mWidth, mHeight);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 释放</span><br><span class="line">            mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">            if (mSurface.isValid()) &#123;</span><br><span class="line">                if (!hadSurface) &#123;</span><br><span class="line">                    mSurfaceHolder.ungetCallbacks();</span><br><span class="line"></span><br><span class="line">                    mIsCreating &#x3D; true;</span><br><span class="line">                    SurfaceHolder.Callback callbacks[] &#x3D; mSurfaceHolder.getCallbacks();</span><br><span class="line">                    if (callbacks !&#x3D; null) &#123;</span><br><span class="line">                        for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                            c.surfaceCreated(mSurfaceHolder);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    surfaceChanged &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (surfaceChanged || surfaceGenerationId !&#x3D; mSurface.getGenerationId()) &#123;</span><br><span class="line">                    SurfaceHolder.Callback callbacks[] &#x3D; mSurfaceHolder.getCallbacks();</span><br><span class="line">                    if (callbacks !&#x3D; null) &#123;</span><br><span class="line">                        for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                            c.surfaceChanged(mSurfaceHolder, lp.format,</span><br><span class="line">                                    mWidth, mHeight);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mIsCreating &#x3D; false;</span><br><span class="line">            &#125; else if (hadSurface) &#123;</span><br><span class="line">                mSurfaceHolder.ungetCallbacks();</span><br><span class="line">                SurfaceHolder.Callback callbacks[] &#x3D; mSurfaceHolder.getCallbacks();</span><br><span class="line">                if (callbacks !&#x3D; null) &#123;</span><br><span class="line">                    for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                        c.surfaceDestroyed(mSurfaceHolder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">                try &#123;</span><br><span class="line">                    mSurfaceHolder.mSurface &#x3D; new Surface();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 重新设置 ThreadRenderer </span><br><span class="line">        </span><br><span class="line">        final ThreadedRenderer threadedRenderer &#x3D; mAttachInfo.mThreadedRenderer;</span><br><span class="line">        if (threadedRenderer !&#x3D; null &amp;&amp; threadedRenderer.isEnabled()) &#123;</span><br><span class="line">            if (hwInitialized</span><br><span class="line">                    || mWidth !&#x3D; threadedRenderer.getWidth()</span><br><span class="line">                    || mHeight !&#x3D; threadedRenderer.getHeight()</span><br><span class="line">                    || mNeedsRendererSetup) &#123;</span><br><span class="line">                threadedRenderer.setup(mWidth, mHeight, mAttachInfo,</span><br><span class="line">                        mWindowAttributes.surfaceInsets);</span><br><span class="line">                mNeedsRendererSetup &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对最后的结果重新进行 measure 操作</span><br><span class="line">        if (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">            boolean focusChangedDueToTouchMode &#x3D; ensureTouchModeLocally(</span><br><span class="line">                    (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) !&#x3D; 0);</span><br><span class="line">            if (focusChangedDueToTouchMode || mWidth !&#x3D; host.getMeasuredWidth()</span><br><span class="line">                    || mHeight !&#x3D; host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                    updatedConfiguration) &#123;</span><br><span class="line">                int childWidthMeasureSpec &#x3D; getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                int childHeightMeasureSpec &#x3D; getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;Ooops, something changed!  mWidth&#x3D;&quot;</span><br><span class="line">                        + mWidth + &quot; measuredWidth&#x3D;&quot; + host.getMeasuredWidth()</span><br><span class="line">                        + &quot; mHeight&#x3D;&quot; + mHeight</span><br><span class="line">                        + &quot; measuredHeight&#x3D;&quot; + host.getMeasuredHeight()</span><br><span class="line">                        + &quot; coveredInsetsChanged&#x3D;&quot; + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                 </span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 如果设置了权重分配，则进行权重处理，将 mView 内存置于Window</span><br><span class="line">                &#x2F;&#x2F; 指定权重位置</span><br><span class="line">                </span><br><span class="line">                int width &#x3D; host.getMeasuredWidth();</span><br><span class="line">                int height &#x3D; host.getMeasuredHeight();</span><br><span class="line">                boolean measureAgain &#x3D; false;</span><br><span class="line"></span><br><span class="line">                if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                    width +&#x3D; (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                    childWidthMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                    height +&#x3D; (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                    childHeightMeasureSpec &#x3D; MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 发生权重重新分配后，使用新的尺寸对 mView 及其子View 重新分配</span><br><span class="line">                if (measureAgain) &#123;</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                            &quot;And hey let&#39;s measure once more: width&#x3D;&quot; + width</span><br><span class="line">                            + &quot; height&#x3D;&quot; + height);</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                layoutRequested &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 未产生 window&#x2F;insets&#x2F;visibility  变更的情况，更新其他的信息到AttachInfo，比如WindowLeft、</span><br><span class="line">        &#x2F;&#x2F; WindowTop</span><br><span class="line">        maybeHandleWindowMove(frame);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>在之前 measure 流程中知道，允许执行的条件为<code>mLayoutRequested</code>，对于 layout 流程也一样，如果伴随着 measure 的执行，layout 也会被执行，他们启动条件的一致的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    final boolean didLayout &#x3D; layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    boolean triggerGlobalLayoutListener &#x3D; didLayout</span><br><span class="line">            || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">            </span><br><span class="line">    &#x2F;&#x2F; 和 measure 共享一个状态标记  layoutRequested ,如果执行了 request 一般也需要</span><br><span class="line">    &#x2F;&#x2F; 进行 layout 操作</span><br><span class="line">    if (didLayout) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 执行 layout </span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果设置了要求透明区域（不需要做底色处理），对透明区域进行计算</span><br><span class="line"></span><br><span class="line">        if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) !&#x3D; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 这里将之前的 dirty 区域先并入计算范围</span><br><span class="line">            mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],</span><br><span class="line">                    mTmpLocation[0] + host.mRight - host.mLeft,</span><br><span class="line">                    mTmpLocation[1] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 去除其中不透明的区域</span><br><span class="line">            host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">            if (mTranslator !&#x3D; null) &#123;</span><br><span class="line">                mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果和之前计算的透明区域结构不一致，则更新，并通知</span><br><span class="line">            &#x2F;&#x2F; WindowManagerService setTransparentRegion</span><br><span class="line">            &#x2F;&#x2F; 并且标记重新绘制 setTransparentRegion</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                mFullRedrawNeeded &#x3D; true;</span><br><span class="line">          </span><br><span class="line">                try &#123;</span><br><span class="line">                    mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (DBG) &#123;</span><br><span class="line">            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">            System.out.println(&quot;performTraversals -- after setFrame&quot;);</span><br><span class="line">            host.debug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 触发回调 包括 ViewTreeObserver.dispatchOnGlobalLayout</span><br><span class="line">    if (triggerGlobalLayoutListener) &#123;</span><br><span class="line">        mAttachInfo.mRecomputeGlobalAttributes &#x3D; false;</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 需要计算 inset 区域范围</span><br><span class="line">    </span><br><span class="line">    if (computesInternalInsets) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 监听器</span><br><span class="line">        </span><br><span class="line">        final ViewTreeObserver.InternalInsetsInfo insets &#x3D; mAttachInfo.mGivenInternalInsets;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 清空之前计算得到的 insets </span><br><span class="line">        insets.reset();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 重新进行计算 insets </span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);</span><br><span class="line">        mAttachInfo.mHasNonEmptyGivenInternalInsets &#x3D; !insets.isEmpty();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Tell the window manager.</span><br><span class="line">        if (insetsPending || !mLastGivenInsets.equals(insets)) &#123;</span><br><span class="line">            mLastGivenInsets.set(insets);</span><br><span class="line"></span><br><span class="line">           </span><br><span class="line">            final Rect contentInsets;</span><br><span class="line">            final Rect visibleInsets;</span><br><span class="line">            final Region touchableRegion;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果兼容器不为空，则由兼容器托管处理，否则</span><br><span class="line">            &#x2F;&#x2F; 通过之前计算的 insets 分别计算获取到</span><br><span class="line">            &#x2F;&#x2F; 可见区域、内容区域以及触摸区域</span><br><span class="line">            </span><br><span class="line">            if (mTranslator !&#x3D; null) &#123;</span><br><span class="line">                contentInsets &#x3D; mTranslator.getTranslatedContentInsets(insets.contentInsets);</span><br><span class="line">                visibleInsets &#x3D; mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);</span><br><span class="line">                touchableRegion &#x3D; mTranslator.getTranslatedTouchableArea(insets.touchableRegion);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                contentInsets &#x3D; insets.contentInsets;</span><br><span class="line">                visibleInsets &#x3D; insets.visibleInsets;</span><br><span class="line">                touchableRegion &#x3D; insets.touchableRegion;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 向 WindowManagerService 更新区域信息</span><br><span class="line">            try &#123;</span><br><span class="line">                mWindowSession.setInsets(mWindow, insets.mTouchableInsets,</span><br><span class="line">                        contentInsets, visibleInsets, touchableRegion);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理焦点情况，从mView中去找到一个焦点</span><br><span class="line">    if (mFirst &amp;&amp; sAlwaysAssignFocus) &#123;</span><br><span class="line">        &#x2F;&#x2F; handle first focus request</span><br><span class="line">        if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: mView.hasFocus()&#x3D;&quot;</span><br><span class="line">                + mView.hasFocus());</span><br><span class="line">        if (mView !&#x3D; null) &#123;</span><br><span class="line">            if (!mView.hasFocus()) &#123;</span><br><span class="line">                mView.restoreDefaultFocus();</span><br><span class="line">                if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: requested focused view&#x3D;&quot;</span><br><span class="line">                        + mView.findFocus());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: existing focused view&#x3D;&quot;</span><br><span class="line">                        + mView.findFocus());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理焦点情况</span><br><span class="line">    </span><br><span class="line">    final boolean changedVisibility &#x3D; (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible;</span><br><span class="line">    final boolean hasWindowFocus &#x3D; mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible;</span><br><span class="line">    final boolean regainedFocus &#x3D; hasWindowFocus &amp;&amp; mLostWindowFocus;</span><br><span class="line">    if (regainedFocus) &#123;</span><br><span class="line">        mLostWindowFocus &#x3D; false;</span><br><span class="line">    &#125; else if (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123;</span><br><span class="line">        mLostWindowFocus &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (changedVisibility || regainedFocus) &#123;</span><br><span class="line">        &#x2F;&#x2F; Toasts are presented as notifications - don&#39;t present them as windows as well</span><br><span class="line">        boolean isToast &#x3D; (mWindowAttributes &#x3D;&#x3D; null) ? false</span><br><span class="line">                : (mWindowAttributes.type &#x3D;&#x3D; WindowManager.LayoutParams.TYPE_TOAST);</span><br><span class="line">        if (!isToast) &#123;</span><br><span class="line">            host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 重置状态</span><br><span class="line">    </span><br><span class="line">    mFirst &#x3D; false;</span><br><span class="line">    mWillDrawSoon &#x3D; false;</span><br><span class="line">    mNewSurfaceNeeded &#x3D; false;</span><br><span class="line">    mActivityRelaunched &#x3D; false;</span><br><span class="line">    mViewVisibility &#x3D; viewVisibility;</span><br><span class="line">    mHadWindowFocus &#x3D; hasWindowFocus;</span><br><span class="line"></span><br><span class="line">    if (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 判断该窗口是否为输入目标</span><br><span class="line">        </span><br><span class="line">        final boolean imTarget &#x3D; WindowManager.LayoutParams</span><br><span class="line">                .mayUseInputMethod(mWindowAttributes.flags);</span><br><span class="line">                </span><br><span class="line">        &#x2F;&#x2F; 如果和之前的Im 状态不一致</span><br><span class="line">        </span><br><span class="line">        if (imTarget !&#x3D; mLastWasImTarget) &#123;</span><br><span class="line">            mLastWasImTarget &#x3D; imTarget;</span><br><span class="line">            InputMethodManager imm &#x3D; InputMethodManager.peekInstance();</span><br><span class="line">            if (imm !&#x3D; null &amp;&amp; imTarget) &#123;</span><br><span class="line">                imm.onPreWindowFocus(mView, hasWindowFocus);</span><br><span class="line">                imm.onPostWindowFocus(mView, mView.findFocus(),</span><br><span class="line">                        mWindowAttributes.softInputMode,</span><br><span class="line">                        !mHasHadWindowFocus, mWindowAttributes.flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; RELAYOUT_RES_FIRST_TIME 如果为第一次，则标记在 draw 阶段</span><br><span class="line">    &#x2F;&#x2F; 强制进行 performDraw 处理</span><br><span class="line">    if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) !&#x3D; 0) &#123;</span><br><span class="line">        reportNextDraw();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="performLayout"><a href="#performLayout" class="headerlink" title="performLayout"></a>performLayout</h3><ul>
<li>触发顶层 mView.layout 第一次执行</li>
<li>如果在执行 layout 中仍然触发 requestLayout，则对所触发的 View 进行重新 measure 流程，并重新 layout</li>
<li>如果执行layout 中还存在 requestLayout 的 View，则将这些view的 requestlayout 要求防止大 Looper 中延迟处理，保证不丢失请求状态，留存于下次执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">        int desiredWindowHeight) &#123;</span><br><span class="line">    mLayoutRequested &#x3D; false;</span><br><span class="line">    mScrollMayChange &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 标记当前 ViewTree 处于 layout 流程中，对应在此期间触发的</span><br><span class="line">    &#x2F;&#x2F; requestLayout 行为，则添加到 mLayoutRequesters 中，在执行</span><br><span class="line">    &#x2F;&#x2F; 完成测量后重新处理</span><br><span class="line">    </span><br><span class="line">    mInLayout &#x3D; true;</span><br><span class="line"></span><br><span class="line">    final View host &#x3D; mView;</span><br><span class="line">    if (host &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">        Log.v(mTag, &quot;Laying out &quot; + host + &quot; to (&quot; +</span><br><span class="line">                host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 开始直接调用 mView.layout，通过之前 measure</span><br><span class="line">        &#x2F;&#x2F; mView 已经得到对应的 measuredWidth 和</span><br><span class="line">        &#x2F;&#x2F; measureHeight，将他们作为布局的起点</span><br><span class="line">        </span><br><span class="line">        host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        mInLayout &#x3D; false;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果在 layout 过程中，又有 requestLayout 的请求View,</span><br><span class="line">        &#x2F;&#x2F; 进行处理</span><br><span class="line">        </span><br><span class="line">        int numViewsRequestingLayout &#x3D; mLayoutRequesters.size();</span><br><span class="line">        if (numViewsRequestingLayout &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 筛选掉一些目前无用请求的 View (比如View已经为GONE状态)</span><br><span class="line">            </span><br><span class="line">            ArrayList&lt;View&gt; validLayoutRequesters &#x3D; getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                    false);</span><br><span class="line">                    </span><br><span class="line">            if (validLayoutRequesters !&#x3D; null) &#123;</span><br><span class="line">                mHandlingLayoutInLayoutRequest &#x3D; true;</span><br><span class="line"></span><br><span class="line">                int numValidRequests &#x3D; validLayoutRequesters.size();</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 遍历并触发标记，mLayoutReqested &#x3D; true</span><br><span class="line">                </span><br><span class="line">                for (int i &#x3D; 0; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    final View view &#x3D; validLayoutRequesters.get(i);</span><br><span class="line">                    Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view +</span><br><span class="line">                            &quot; during layout: running second layout pass&quot;);</span><br><span class="line">                    view.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 重新触发整个 measure 流程，消费 mLayoutRequested 请求</span><br><span class="line">                </span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                        </span><br><span class="line">                mInLayout &#x3D; true;</span><br><span class="line">                </span><br><span class="line">                &#x2F;&#x2F; 当发生新的 measure 中，需要重新对 layout 流程</span><br><span class="line">                &#x2F;&#x2F; 进行处理</span><br><span class="line">                </span><br><span class="line">                host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                mHandlingLayoutInLayoutRequest &#x3D; false;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 再次处理 layout 过程中所产生的 requestLayout 要求</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                validLayoutRequesters &#x3D; getValidLayoutRequesters(mLayoutRequesters, true);</span><br><span class="line">                if (validLayoutRequesters !&#x3D; null) &#123;</span><br><span class="line">                    final ArrayList&lt;View&gt; finalRequesters &#x3D; validLayoutRequesters;</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">                    getRunQueue().post(new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            int numValidRequests &#x3D; finalRequesters.size();</span><br><span class="line">                            for (int i &#x3D; 0; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                final View view &#x3D; finalRequesters.get(i);</span><br><span class="line">                                Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view +</span><br><span class="line">                                        &quot; during second layout pass: posting in next frame&quot;);</span><br><span class="line">                                view.requestLayout();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 标记完成 layout 流程</span><br><span class="line">    mInLayout &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="draw"><a href="#draw" class="headerlink" title="draw"></a>draw</h2><p>draw 流程几乎没有条件，在触发 invalidate 后即执行（除了前置条件 dirty 交集区域可被绘制之类），主要处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">private void performTraversals() &#123;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据 ViewTreeObserver dispatchOnPreDraw 结果或如果View</span><br><span class="line">    &#x2F;&#x2F; 未展示时则取消 draw 行为</span><br><span class="line">    </span><br><span class="line">    boolean cancelDraw &#x3D; mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据之前的结果判断是否需要进行draw行为</span><br><span class="line">    &#x2F;&#x2F; 未取消 draw 行为，以及 newSurface &#x3D;&#x3D; false</span><br><span class="line">    </span><br><span class="line">    if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 如果设置有 Transition 动画，则处理 mPendingTransitions 中每一个</span><br><span class="line">        &#x2F;&#x2F; LayoutTransition.startChangingAnimations() </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        if (mPendingTransitions !&#x3D; null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingTransitions.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 执行 peformDraw()</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 当次如果不需要进行 draw，如果View还是可见，则尝试进行</span><br><span class="line">        &#x2F;&#x2F; 再次 peformTraversal 操作</span><br><span class="line">        if (isViewVisible) &#123;</span><br><span class="line">            &#x2F;&#x2F; Try again</span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125; else if (mPendingTransitions !&#x3D; null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 由于 无法 draw 将所有 LayoutTransition 动画进行</span><br><span class="line">            &#x2F;&#x2F; 终止</span><br><span class="line">            for (int i &#x3D; 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingTransitions.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsInTraversal &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="performDraw"><a href="#performDraw" class="headerlink" title="performDraw"></a>performDraw</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">private void performDraw() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 mReportNextDraw 被设置为 true 则会强制进行绘制</span><br><span class="line">    &#x2F;&#x2F; 如果屏幕关闭状态 或者 mView 未设置则忽略执行</span><br><span class="line">    </span><br><span class="line">    if (mAttachInfo.mDisplayState &#x3D;&#x3D; Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if (mView &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否需要进行全绘制</span><br><span class="line">    </span><br><span class="line">    final boolean fullRedrawNeeded &#x3D; mFullRedrawNeeded || mReportNextDraw;</span><br><span class="line">    mFullRedrawNeeded &#x3D; false;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 标记正在处理 draw 内容</span><br><span class="line">    </span><br><span class="line">    mIsDrawing &#x3D; true;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;draw&quot;);</span><br><span class="line"></span><br><span class="line">    boolean usingAsyncReport &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ThreadedRenderer 如果可用，则使用硬件加速</span><br><span class="line">    </span><br><span class="line">    if (mAttachInfo.mThreadedRenderer !&#x3D; null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 获得 栈渲染回调，对于window的渲染结束</span><br><span class="line">        &#x2F;&#x2F; 需要通知这些回调</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Runnable&gt; commitCallbacks &#x3D; mAttachInfo.mTreeObserver</span><br><span class="line">                .captureFrameCommitCallbacks();</span><br><span class="line">                </span><br><span class="line">        if (mReportNextDraw) &#123;</span><br><span class="line">            usingAsyncReport &#x3D; true;</span><br><span class="line">            final Handler handler &#x3D; mAttachInfo.mHandler;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 设置 ThreadedRenderer 帧渲染回调</span><br><span class="line">            </span><br><span class="line">            mAttachInfo.mThreadedRenderer.setFrameCompleteCallback((long frameNr) -&gt;</span><br><span class="line">                    handler.postAtFrontOfQueue(() -&gt; &#123;</span><br><span class="line">                        </span><br><span class="line">                        &#x2F;&#x2F; 对该次绘制完成进行计数器递减</span><br><span class="line">                        &#x2F;&#x2F; 如果完成所有绘制请求（计算</span><br><span class="line">                        &#x2F;&#x2F; 为 0）则通知 WMS finishDrawing</span><br><span class="line">                        </span><br><span class="line">                        pendingDrawFinished();</span><br><span class="line">                        </span><br><span class="line">                        &#x2F;&#x2F; 如果存在 commitCallbacks 则一一进行回调</span><br><span class="line">                        if (commitCallbacks !&#x3D; null) &#123;</span><br><span class="line">                            for (int i &#x3D; 0; i &lt; commitCallbacks.size(); i++) &#123;</span><br><span class="line">                                commitCallbacks.get(i).run();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">        &#125; else if (commitCallbacks !&#x3D; null &amp;&amp; commitCallbacks.size() &gt; 0) &#123;</span><br><span class="line">        </span><br><span class="line">            &#x2F;&#x2F; 注册所需要的 commitCallbacks，因为不需要进行硬件加速绘制</span><br><span class="line">            &#x2F;&#x2F; 不需要进行 finishDrawing 处理</span><br><span class="line">            </span><br><span class="line">            final Handler handler &#x3D; mAttachInfo.mHandler;</span><br><span class="line">            mAttachInfo.mThreadedRenderer.setFrameCompleteCallback((long frameNr) -&gt;</span><br><span class="line">                    handler.postAtFrontOfQueue(() -&gt; &#123;</span><br><span class="line">                        for (int i &#x3D; 0; i &lt; commitCallbacks.size(); i++) &#123;</span><br><span class="line">                            commitCallbacks.get(i).run();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">    </span><br><span class="line">        &#x2F;&#x2F; 执行 draw 流程</span><br><span class="line">        </span><br><span class="line">        boolean canUseAsync &#x3D; draw(fullRedrawNeeded);</span><br><span class="line">        if (usingAsyncReport &amp;&amp; !canUseAsync) &#123;</span><br><span class="line">            mAttachInfo.mThreadedRenderer.setFrameCompleteCallback(null);</span><br><span class="line">            usingAsyncReport &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mIsDrawing &#x3D; false;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果有需要待处理的动画绘制内容，则结束这些动画 </span><br><span class="line">    </span><br><span class="line">    if (mAttachInfo.mPendingAnimatingRenderNodes !&#x3D; null) &#123;</span><br><span class="line">        final int count &#x3D; mAttachInfo.mPendingAnimatingRenderNodes.size();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            mAttachInfo.mPendingAnimatingRenderNodes.get(i).endAllAnimators();</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mPendingAnimatingRenderNodes.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mReportNextDraw) &#123;</span><br><span class="line">        mReportNextDraw &#x3D; false;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; mWindowDrawCountDown 为 CountDownLatch 锁，用于多线程</span><br><span class="line">        &#x2F;&#x2F; 渲染，等待其他线程处理完成</span><br><span class="line">        </span><br><span class="line">        if (mWindowDrawCountDown !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mWindowDrawCountDown.await();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                Log.e(mTag, &quot;Window redraw count down interrupted!&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            mWindowDrawCountDown &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果当前 Window 关闭则同步状态给 ThreadedRenderer</span><br><span class="line">        &#x2F;&#x2F; 同时关闭渲染线程</span><br><span class="line">        if (mAttachInfo.mThreadedRenderer !&#x3D; null) &#123;</span><br><span class="line">            mAttachInfo.mThreadedRenderer.setStopped(mStopped);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (LOCAL_LOGV) &#123;</span><br><span class="line">            Log.v(mTag, &quot;FINISHED DRAWING: &quot; + mWindowAttributes.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mSurfaceHolder !&#x3D; null &amp;&amp; mSurface.isValid()) &#123;</span><br><span class="line">            SurfaceCallbackHelper sch &#x3D; new SurfaceCallbackHelper(this::postDrawFinished);</span><br><span class="line">            SurfaceHolder.Callback callbacks[] &#x3D; mSurfaceHolder.getCallbacks();</span><br><span class="line"></span><br><span class="line">            sch.dispatchSurfaceRedrawNeededAsync(mSurfaceHolder, callbacks);</span><br><span class="line">        &#125; else if (!usingAsyncReport) &#123;</span><br><span class="line">            if (mAttachInfo.mThreadedRenderer !&#x3D; null) &#123;</span><br><span class="line">                mAttachInfo.mThreadedRenderer.fence();</span><br><span class="line">            &#125;</span><br><span class="line">            pendingDrawFinished();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="draw-1"><a href="#draw-1" class="headerlink" title="draw"></a>draw</h3><ul>
<li>当整个进程触发第一次 draw 会被触发 startJitCompilation JIT的优化</li>
<li>处于滚动状态则进行 ViewTreeObserver.dispatchOnScrollChanged 回调</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">private boolean draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果  Surface 未建立则退出绘制</span><br><span class="line">    Surface surface &#x3D; mSurface;</span><br><span class="line">    if (!surface.isValid()) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (DEBUG_FPS) &#123;</span><br><span class="line">        trackFPS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; sFirstDrawComplete 全局只会被触发一次，首次绘制后将置为 true</span><br><span class="line">    &#x2F;&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 整个APP进程中，只允许执行一次 sFirstDrawHandlers 调用</span><br><span class="line">    &#x2F;&#x2F; 目前在 ActivityThread 向 sFirstDrawHandlers 添加了</span><br><span class="line">    &#x2F;&#x2F; JIT 编译任务 dalvik.system.VMRuntime.getRuntime().startJitCompilation();</span><br><span class="line">    if (!sFirstDrawComplete) &#123;</span><br><span class="line">        synchronized (sFirstDrawHandlers) &#123;</span><br><span class="line">            sFirstDrawComplete &#x3D; true;</span><br><span class="line">            final int count &#x3D; sFirstDrawHandlers.size();</span><br><span class="line">            for (int i &#x3D; 0; i&lt; count; i++) &#123;</span><br><span class="line">                mHandler.post(sFirstDrawHandlers.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 滚动到内容位置</span><br><span class="line">    scrollToRectOrFocus(null, false);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果需要监听滚动事件，当且处于滚动状态（scrollToRectOrFocus &#x3D;&#x3D; true）则进行 ViewTreeObserver </span><br><span class="line">    &#x2F;&#x2F; dispatchOnScrollChanged 的分发</span><br><span class="line">    if (mAttachInfo.mViewScrollChanged) &#123;</span><br><span class="line">        mAttachInfo.mViewScrollChanged &#x3D; false;</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnScrollChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 是否需要进行滚动动画</span><br><span class="line">    boolean animating &#x3D; mScroller !&#x3D; null &amp;&amp; mScroller.computeScrollOffset();</span><br><span class="line">    final int curScrollY;</span><br><span class="line">    if (animating) &#123;</span><br><span class="line">        curScrollY &#x3D; mScroller.getCurrY();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        curScrollY &#x3D; mScrollY;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mCurScrollY !&#x3D; curScrollY) &#123;</span><br><span class="line">        mCurScrollY &#x3D; curScrollY;</span><br><span class="line">        fullRedrawNeeded &#x3D; true;</span><br><span class="line">        if (mView instanceof RootViewSurfaceTaker) &#123;</span><br><span class="line">            ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final float appScale &#x3D; mAttachInfo.mApplicationScale;</span><br><span class="line">    final boolean scalingRequired &#x3D; mAttachInfo.mScalingRequired;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果支持硬件加速，则忽略 dirty 并且停止滚动动画（硬件加速</span><br><span class="line">    &#x2F;&#x2F; 不需要处理）</span><br><span class="line">    </span><br><span class="line">    final Rect dirty &#x3D; mDirty;</span><br><span class="line">    if (mSurfaceHolder !&#x3D; null) &#123;</span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        if (animating &amp;&amp; mScroller !&#x3D; null) &#123;</span><br><span class="line">            mScroller.abortAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果需要进行全量绘制，则设置 dirty区域为全屏区域</span><br><span class="line">    </span><br><span class="line">    if (fullRedrawNeeded) &#123;</span><br><span class="line">        dirty.set(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通知 ViewTreeObserver 执行绘制事件 dispatchOnDraw</span><br><span class="line">    </span><br><span class="line">    mAttachInfo.mTreeObserver.dispatchOnDraw();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理画布偏移，这数据根据之前对 Window measure width 、heigt 得到</span><br><span class="line">    int xOffset &#x3D; -mCanvasOffsetX;</span><br><span class="line">    int yOffset &#x3D; -mCanvasOffsetY + curScrollY;</span><br><span class="line">    final WindowManager.LayoutParams params &#x3D; mWindowAttributes;</span><br><span class="line">    final Rect surfaceInsets &#x3D; params !&#x3D; null ? params.surfaceInsets : null;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 如果Surface 需要设置  Inset，则将 Inset</span><br><span class="line">    &#x2F;&#x2F; 附加到 dirty 中</span><br><span class="line">    </span><br><span class="line">    if (surfaceInsets !&#x3D; null) &#123;</span><br><span class="line">        xOffset -&#x3D; surfaceInsets.left;</span><br><span class="line">        yOffset -&#x3D; surfaceInsets.top;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Offset dirty rect for surface insets.</span><br><span class="line">        dirty.offset(surfaceInsets.left, surfaceInsets.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean accessibilityFocusDirty &#x3D; false;</span><br><span class="line">    final Drawable drawable &#x3D; mAttachInfo.mAccessibilityFocusDrawable;</span><br><span class="line">    if (drawable !&#x3D; null) &#123;</span><br><span class="line">        final Rect bounds &#x3D; mAttachInfo.mTmpInvalRect;</span><br><span class="line">        final boolean hasFocus &#x3D; getAccessibilityFocusedRect(bounds);</span><br><span class="line">        if (!hasFocus) &#123;</span><br><span class="line">            bounds.setEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!bounds.equals(drawable.getBounds())) &#123;</span><br><span class="line">            accessibilityFocusDirty &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 计算绘制时间</span><br><span class="line">    </span><br><span class="line">    mAttachInfo.mDrawingTime &#x3D;</span><br><span class="line">            mChoreographer.getFrameTimeNanos() &#x2F; TimeUtils.NANOS_PER_MS;</span><br><span class="line"></span><br><span class="line">    boolean useAsyncReport &#x3D; false;</span><br><span class="line">    if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 如果支持 DiaplayList 缓存</span><br><span class="line">        </span><br><span class="line">        if (mAttachInfo.mThreadedRenderer !&#x3D; null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">            </span><br><span class="line">            boolean invalidateRoot &#x3D; accessibilityFocusDirty || mInvalidateRootRequested;</span><br><span class="line">            mInvalidateRootRequested &#x3D; false;</span><br><span class="line"></span><br><span class="line">            mIsAnimating &#x3D; false;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 同步offset 信息</span><br><span class="line">            </span><br><span class="line">            if (mHardwareYOffset !&#x3D; yOffset || mHardwareXOffset !&#x3D; xOffset) &#123;</span><br><span class="line">                mHardwareYOffset &#x3D; yOffset;</span><br><span class="line">                mHardwareXOffset &#x3D; xOffset;</span><br><span class="line">                invalidateRoot &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 要求重绘整个 RenderNode</span><br><span class="line"></span><br><span class="line">            if (invalidateRoot) &#123;</span><br><span class="line">                mAttachInfo.mThreadedRenderer.invalidateRoot();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 通知进行内容更新，用于多线程更新</span><br><span class="line">            final boolean updated &#x3D; updateContentDrawBounds();</span><br><span class="line"></span><br><span class="line">            if (mReportNextDraw) &#123;</span><br><span class="line">                mAttachInfo.mThreadedRenderer.setStopped(false);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 如果允许进行多线程更新，启动 CountDownLaunch 并</span><br><span class="line">            &#x2F;&#x2F; 触发每个 WindowCallback.onRequestDraw 执行</span><br><span class="line">            &#x2F;&#x2F; 实际上也就是触发 DecorView.onRequestDraw 中 </span><br><span class="line">            &#x2F;&#x2F; BackdropFrameRenderer.onRequestDraw 的处理</span><br><span class="line">            </span><br><span class="line">            if (updated) &#123;</span><br><span class="line">                requestDrawWindow();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            useAsyncReport &#x3D; true;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 触发 Renderer 执行缓存绘制</span><br><span class="line">            mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 对于Surface 不可用的情况，尝试进行重置初始化，</span><br><span class="line">            &#x2F;&#x2F; 如果还是无法执行，则中断绘制，否则重新进入 </span><br><span class="line">            &#x2F;&#x2F; scheduleTraversals 进行绘制</span><br><span class="line">            if (mAttachInfo.mThreadedRenderer !&#x3D; null &amp;&amp;</span><br><span class="line">                    !mAttachInfo.mThreadedRenderer.isEnabled() &amp;&amp;</span><br><span class="line">                    mAttachInfo.mThreadedRenderer.isRequested() &amp;&amp;</span><br><span class="line">                    mSurface.isValid()) &#123;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 重新初始化 Surface </span><br><span class="line">                try &#123;</span><br><span class="line">                    mAttachInfo.mThreadedRenderer.initializeIfNeeded(</span><br><span class="line">                            mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);</span><br><span class="line">                &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                    handleOutOfResourcesException(e);</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mFullRedrawNeeded &#x3D; true;</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 如果缓存不可用，但是还是需要显示界面内容到屏幕上</span><br><span class="line">            if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                    scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果在执行动画，则调用下一次绘制 scheduleTraversals</span><br><span class="line">    if (animating) &#123;</span><br><span class="line">        mFullRedrawNeeded &#x3D; true;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">    return useAsyncReport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="drawSoftware"><a href="#drawSoftware" class="headerlink" title="drawSoftware"></a>drawSoftware</h3><p>该方法主要是将绘制内容进行 <code>Surface</code> 的输出</p>
<ul>
<li>通过 dirty 获取   canvas = mSurface.lockCanvas(dirty) 中 Canvas</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">        boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line"></span><br><span class="line">    final Canvas canvas;</span><br><span class="line">    try &#123;</span><br><span class="line">        final int left &#x3D; dirty.left;</span><br><span class="line">        final int top &#x3D; dirty.top;</span><br><span class="line">        final int right &#x3D; dirty.right;</span><br><span class="line">        final int bottom &#x3D; dirty.bottom;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取 Surface Canvas 提供于draw 处理</span><br><span class="line">        canvas &#x3D; mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 标记忽视绘制区域和dirty 区域不一致的情况</span><br><span class="line">        if (left !&#x3D; dirty.left || top !&#x3D; dirty.top || right !&#x3D; dirty.right</span><br><span class="line">                || bottom !&#x3D; dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置 canvas density 参数，该参数来源于 </span><br><span class="line">        &#x2F;&#x2F;  context.getResources().getDisplayMetrics().densityDpi</span><br><span class="line">        &#x2F;&#x2F; 和canvas 所绑定的 bitmap 相关</span><br><span class="line">        </span><br><span class="line">        canvas.setDensity(mDensity);</span><br><span class="line">    &#125; catch (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        return false;</span><br><span class="line">    &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">        mLayoutRequested &#x3D; true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">  </span><br><span class="line">        &#x2F;&#x2F; 如果画布要求为透明，将画布的底色置为透明</span><br><span class="line">        if (!canvas.isOpaque() || yoff !&#x3D; 0 || xoff !&#x3D; 0) &#123;</span><br><span class="line">            canvas.drawColor(0, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        mIsAnimating &#x3D; false;</span><br><span class="line">        mView.mPrivateFlags |&#x3D; View.PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        if (DEBUG_DRAW) &#123;</span><br><span class="line">            Context cxt &#x3D; mView.getContext();</span><br><span class="line">            Log.i(mTag, &quot;Drawing: package:&quot; + cxt.getPackageName() +</span><br><span class="line">                    &quot;, metrics&#x3D;&quot; + cxt.getResources().getDisplayMetrics() +</span><br><span class="line">                    &quot;, compatibilityInfo&#x3D;&quot; + cxt.getResources().getCompatibilityInfo());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 对画布起始进行校正（0，0）</span><br><span class="line">        try &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            if (mTranslator !&#x3D; null) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState &#x3D; false;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 执行对Canvas 内容的添加</span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                &#x2F;&#x2F; Only clear the flag if it was not set during the mView.draw() call</span><br><span class="line">                attachInfo.mIgnoreDirtyState &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 解锁画布并显示</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            Log.e(mTag, &quot;Could not unlock surface&quot;, e);</span><br><span class="line">            mLayoutRequested &#x3D; true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="invalidate-boolean-invalidateCache-参数中-invalidateCache-的影响"><a href="#invalidate-boolean-invalidateCache-参数中-invalidateCache-的影响" class="headerlink" title="invalidate(boolean invalidateCache) 参数中 invalidateCache 的影响"></a>invalidate(boolean invalidateCache) 参数中 invalidateCache 的影响</h2><p>最主要的影响是在对 dirty 测量上的区别。</p>
<p>当 invalidateCache == true 时，将被移除 PFLAG_DRAWING_CACHE_VALID 标记，表示当前 DisplayList 缓存已经失效，在计算 dirty 区域时，在不在进行计算（没意义了），在对View.draw 的绘制中，将触发<br><code>updateDisplayListIfDirty</code> DisplayList 的更新。</p>
<p>提到 DisplayList 则会联系到 RenderNode ，RenderNode 为 DisplayList 在View 中的一层图层缓存（如果支持硬件加速 则 draw 中的 Canvas 为 DisplayListCanvas，与Surface 类型一致，当发生绘制时，同时也会更新），当我们需要对View进行属性动画，属性变化 translation，实际是对 RenderNode 的属性操作，通过当方面的 RenderNode 属性变化，即可决定 Canvas 的最终成效。</p>
<p>触发 invalidateCache = true 将重建 RenderNode。在实际操作中，如修改的View的内容范围影响小，则不需要将整个DisplayList 进行重建。</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/View/">View</a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/02/14/Jetpack-Lifecycle/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Jetpack-Lifecycle</div></div></a></div><div class="next-post pull_right"><a href="/2019/01/13/Android%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%92%8C%E9%98%85%E8%AF%BB/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android源码编译和阅读</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/01/13/Android源码编译和阅读/" title="Android源码编译和阅读"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-01-13</div><div class="relatedPosts_title">Android源码编译和阅读</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/15/Android未捕获异常处理/" title="Android 未捕获异常处理"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-15</div><div class="relatedPosts_title">Android 未捕获异常处理</div></div></a></div><div class="relatedPosts_item"><a href="/2019/02/14/Jetpack-Lifecycle/" title="Jetpack-Lifecycle"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-02-14</div><div class="relatedPosts_title">Jetpack-Lifecycle</div></div></a></div><div class="relatedPosts_item"><a href="/2018/03/03/Repo操作/" title="Repo操作"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-03-03</div><div class="relatedPosts_title">Repo操作</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/10/Handler学习小记/" title="Handler学习小记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-10</div><div class="relatedPosts_title">Handler学习小记</div></div></a></div><div class="relatedPosts_item"><a href="/2018/06/09/Transform的基本应用/" title="Transform的基本应用"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-06-09</div><div class="relatedPosts_title">Transform的基本应用</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2014 - 2020 By Bevis</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>