<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OkHttp | Bevis技术小站</title><meta name="description" content="OkHttp"><meta name="keywords" content="Android,网络,OkHttp"><meta name="author" content="Bevis"><meta name="copyright" content="Bevis"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="OkHttp"><meta name="twitter:description" content="OkHttp"><meta name="twitter:image" content="http://yoursite.com/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="OkHttp"><meta property="og:url" content="http://yoursite.com/2019/05/01/OkHttp/"><meta property="og:site_name" content="Bevis技术小站"><meta property="og:description" content="OkHttp"><meta property="og:image" content="http://yoursite.com/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/05/01/OkHttp/"><link rel="prev" title="Android Q适配" href="http://yoursite.com/2019/05/14/AndroidQ%E9%80%82%E9%85%8D/"><link rel="next" title="Jetpack-ViewModel" href="http://yoursite.com/2019/02/21/Jetpack-ViewModel/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Bevis技术小站" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">27</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、主要构件"><span class="toc-number">1.</span> <span class="toc-text">一、主要构件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、基本使用"><span class="toc-number">2.</span> <span class="toc-text">二、基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖引入"><span class="toc-number">2.1.</span> <span class="toc-text">依赖引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求流程"><span class="toc-number">2.2.</span> <span class="toc-text">请求流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步请求"><span class="toc-number">2.3.</span> <span class="toc-text">同步请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步请求"><span class="toc-number">2.4.</span> <span class="toc-text">异步请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Builder-配置"><span class="toc-number">2.5.</span> <span class="toc-text">Builder 配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、请求流程分析"><span class="toc-number">3.</span> <span class="toc-text">三、请求流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#同步请求-1"><span class="toc-number">3.1.</span> <span class="toc-text">同步请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RealCalll-execute"><span class="toc-number">3.1.1.</span> <span class="toc-text">RealCalll.execute()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatcher-executed-call-RealCall"><span class="toc-number">3.1.2.</span> <span class="toc-text">Dispatcher.executed(call:RealCall)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getResponseWithInterceptorChain-触发拦截器处理"><span class="toc-number">3.1.3.</span> <span class="toc-text">getResponseWithInterceptorChain 触发拦截器处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步请求-1"><span class="toc-number">3.2.</span> <span class="toc-text">异步请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Call-enqueue-responseCallback-Callback"><span class="toc-number">3.2.1.</span> <span class="toc-text">Call.enqueue(responseCallback: Callback)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatcher-enqueue-call-AsyncCall"><span class="toc-number">3.2.2.</span> <span class="toc-text">Dispatcher.enqueue(call: AsyncCall)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dispatcher-promoteAndExecute"><span class="toc-number">3.2.3.</span> <span class="toc-text">Dispatcher.promoteAndExecute()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RealCall-executeOn-executorService-ExecutorService"><span class="toc-number">3.2.4.</span> <span class="toc-text">RealCall.executeOn(executorService: ExecutorService)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dispatcher-finished"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">Dispatcher.finished()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、拦截器"><span class="toc-number">4.</span> <span class="toc-text">四、拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RetryAndFollowUpInterceptor"><span class="toc-number">4.1.</span> <span class="toc-text">RetryAndFollowUpInterceptor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BridgeInterceptor"><span class="toc-number">4.2.</span> <span class="toc-text">BridgeInterceptor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CacheInterceptor"><span class="toc-number">4.3.</span> <span class="toc-text">CacheInterceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存"><span class="toc-number">4.3.1.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DiskLruCache"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">DiskLruCache</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#缓存溢出处理"><span class="toc-number">4.3.1.1.1.</span> <span class="toc-text">缓存溢出处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#产生-Edit"><span class="toc-number">4.3.1.1.2.</span> <span class="toc-text">产生 Edit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#初始化与备份"><span class="toc-number">4.3.1.1.3.</span> <span class="toc-text">初始化与备份</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConnectInterceptor"><span class="toc-number">4.4.</span> <span class="toc-text">ConnectInterceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RouteSelector、Route-与-Proxy"><span class="toc-number">4.4.1.</span> <span class="toc-text">RouteSelector、Route 与 Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#预处理Proxy"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">预处理Proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RouteSelector的使用"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">RouteSelector的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConnectionSpec-与-ConnectionSpecSelector"><span class="toc-number">4.4.2.</span> <span class="toc-text">ConnectionSpec 与 ConnectionSpecSelector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConnectionSpec-apply-配置"><span class="toc-number">4.4.2.1.</span> <span class="toc-text">ConnectionSpec.apply 配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RealConnection中的连接"><span class="toc-number">4.4.3.</span> <span class="toc-text">RealConnection中的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回归findConnection"><span class="toc-number">4.4.4.</span> <span class="toc-text">回归findConnection</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConnectionPool-连接复用"><span class="toc-number">4.4.4.1.</span> <span class="toc-text">ConnectionPool 连接复用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CallServerInterceptor"><span class="toc-number">4.5.</span> <span class="toc-text">CallServerInterceptor</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bevis技术小站</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">OkHttp</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2019-05-01 18:20:10"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-05-01</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="一、主要构件"><a href="#一、主要构件" class="headerlink" title="一、主要构件"></a>一、主要构件</h1><ul>
<li>OkhttpClient 请求总引擎代理</li>
<li>Request 请求体信息，通过Request.Builder构造，请求头、请求体信息</li>
<li>Call 请求连接代理，通过Call可以决定是同步还异步请求处理</li>
<li>Dispatcher 接收同步/异步请求要求，根据要求对请求进行同步/异步分发</li>
<li>Interceptor</li>
</ul>
<h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation &#39;com.squareup.okhttp3:okhttp:4.4.0&#39;</span><br><span class="line">&#x2F;&#x2F; 单元测试依赖</span><br><span class="line">testImplementation &#39;com.squareup.okhttp3:mockwebserver:4.4.0&#39;</span><br></pre></td></tr></table></figure>


<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22726/32DF5E930CAC4F18990DCC8E5E18F7D6"  alt="image"></p>
<h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><ul>
<li>创建OkHttpClient和Request（Request.Builder）对象</li>
<li>将Request封装Call对象</li>
<li>调用Call.execute()发起同步请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client &#x3D; new OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build();</span><br><span class="line">Request request &#x3D; new Request.Builder().url(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;).get().build();</span><br><span class="line">Call call &#x3D; client.newCall(request);</span><br><span class="line">try &#123;</span><br><span class="line">    Response response &#x3D; call.execute(); &#x2F;&#x2F; 发送同步请求后将进入阻塞状态</span><br><span class="line">    System.out.println(response.body().string())</span><br><span class="line">&#125; catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><ul>
<li>创建OkHttpClient和Request（Request.Builder）对象</li>
<li>将Request封装Call对象</li>
<li>调用Call.enqueue()发起同步请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client &#x3D; new OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build();</span><br><span class="line">Request request &#x3D; new Request.Builder().url(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;).get().build();</span><br><span class="line">Call call &#x3D; client.newCall(request);</span><br><span class="line">call.enqueue(new Callback()&#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void onFailure(Call call, IOException e) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理异常，注意该处理都是在子线程里面处理的</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  @Override</span><br><span class="line">  public void onResponse(Call call, Response response) throw IOException&#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 成功 Response，该处理是在子线程里面处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">try &#123;</span><br><span class="line">    Response response &#x3D; call.execute(); &#x2F;&#x2F; 发送同步请求后将进入阻塞状态</span><br><span class="line">    System.out.println(response.body().string())</span><br><span class="line">&#125; catch(IOException e) &#123;</span><br><span class="line">    e.printStackTrace()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Builder-配置"><a href="#Builder-配置" class="headerlink" title="Builder 配置"></a>Builder 配置</h2><p>Builder 提供了大量的配置内容，可以根据自己的需求进行对应的配置生成 Client</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"> public static final class Builder &#123;</span><br><span class="line">        Dispatcher dispatcher; &#x2F;&#x2F;调度器</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 代理类，默认有三种代理模式DIRECT(直连),HTTP（http代理）,SOCKS（socks代理）</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable Proxy proxy;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 协议集合，协议类，用来表示使用的协议版本，比如&#96;http&#x2F;1.0,&#96;http&#x2F;1.1,&#96;spdy&#x2F;3.1,&#96;h2等</span><br><span class="line">         *&#x2F;</span><br><span class="line">        List&lt;Protocol&gt; protocols;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 连接规范，用于配置Socket连接层。对于HTTPS，还能配置安全传输层协议（TLS）版本和密码套件</span><br><span class="line">         *&#x2F;</span><br><span class="line">        List&lt;ConnectionSpec&gt; connectionSpecs;</span><br><span class="line">        &#x2F;&#x2F;拦截器，可以监听、重写和重试请求等</span><br><span class="line">        &#x2F;&#x2F; interceptors 针对所有连接情况，包括websocket</span><br><span class="line">        final List&lt;Interceptor&gt; interceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F; 针对非websocket的连接</span><br><span class="line">        final List&lt;Interceptor&gt; networkInterceptors &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        EventListener.Factory eventListenerFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 代理选择类，默认不使用代理，即使用直连方式，当然，我们可以自定义配置，</span><br><span class="line">         * 以指定URI使用某种代理，类似代理软件的PAC功能</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ProxySelector proxySelector;</span><br><span class="line">        &#x2F;&#x2F;Cookie的保存获取</span><br><span class="line">        CookieJar cookieJar;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 缓存类，内部使用了DiskLruCache来进行管理缓存，匹配缓存的机制不仅仅是根据url，</span><br><span class="line">         * 而且会根据请求方法和请求头来验证是否可以响应缓存。此外，仅支持GET请求的缓存</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable Cache cache;</span><br><span class="line">        &#x2F;&#x2F;内置缓存</span><br><span class="line">        @Nullable InternalCache internalCache;</span><br><span class="line">        &#x2F;&#x2F;Socket的抽象创建工厂，通过createSocket来创建Socket</span><br><span class="line">        SocketFactory socketFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 安全套接层工厂，HTTPS相关，用于创建SSLSocket。一般配置HTTPS证书信任问题都需要从这里着手。</span><br><span class="line">         * 对于不受信任的证书一般会提示</span><br><span class="line">         * javax.net.ssl.SSLHandshakeException异常。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable SSLSocketFactory sslSocketFactory;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 证书链清洁器，HTTPS相关，用于从[Java]的TLS API构建的原始数组中统计有效的证书链，</span><br><span class="line">         * 然后清除跟TLS握手不相关的证书，提取可信任的证书以便可以受益于证书锁机制。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        @Nullable CertificateChainCleaner certificateChainCleaner;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 主机名验证器，与HTTPS中的SSL相关，当握手时如果URL的主机名</span><br><span class="line">         * 不是可识别的主机，就会要求进行主机名验证</span><br><span class="line">         *&#x2F;</span><br><span class="line">        HostnameVerifier hostnameVerifier;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 证书锁，HTTPS相关，用于约束哪些证书可以被信任，可以防止一些已知或未知</span><br><span class="line">         * 的中间证书机构带来的攻击行为。如果所有证书都不被信任将抛出SSLPeerUnverifiedException异常。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        CertificatePinner certificatePinner;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 身份认证器，当连接提示未授权时，可以通过重新设置请求头来响应一个</span><br><span class="line">         * 新的Request。状态码401表示远程服务器请求授权，407表示代理服务器请求授权。</span><br><span class="line">         * 该认证器在需要时会被RetryAndFollowUpInterceptor触发。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Authenticator proxyAuthenticator;</span><br><span class="line">        Authenticator authenticator;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 连接池</span><br><span class="line">         *</span><br><span class="line">         * 我们通常将一个客户端和服务端和连接抽象为一个 connection，</span><br><span class="line">         * 而每一个 connection 都会被存放在 connectionPool 中，由它进行统一的管理，</span><br><span class="line">         * 例如有一个相同的 http 请求产生时，connection 就可以得到复用</span><br><span class="line">         *&#x2F;</span><br><span class="line">        ConnectionPool connectionPool;</span><br><span class="line">        &#x2F;&#x2F;域名解析系统</span><br><span class="line">        Dns dns;</span><br><span class="line">        &#x2F;&#x2F;是否遵循SSL重定向</span><br><span class="line">        boolean followSslRedirects;</span><br><span class="line">        &#x2F;&#x2F;是否重定向</span><br><span class="line">        boolean followRedirects;</span><br><span class="line">        &#x2F;&#x2F;失败是否重新连接 hhhhhh6****** 3tn</span><br><span class="line">        boolean retryOnConnectionFailure;</span><br><span class="line">        &#x2F;&#x2F;回调超时</span><br><span class="line">        int callTimeout;</span><br><span class="line">        &#x2F;&#x2F;连接超时</span><br><span class="line">        int connectTimeout;</span><br><span class="line">        &#x2F;&#x2F;读取超时</span><br><span class="line">        int readTimeout;</span><br><span class="line">        &#x2F;&#x2F;写入超时</span><br><span class="line">        int writeTimeout;</span><br><span class="line">        &#x2F;&#x2F;与WebSocket有关，为了保持长连接，我们必须间隔一段时间发送一个ping指令进行保；</span><br><span class="line">        int pingInterval;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、请求流程分析"><a href="#三、请求流程分析" class="headerlink" title="三、请求流程分析"></a>三、请求流程分析</h1><p>大体全貌图</p>
<p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23957/040003B90E114920918B8C1053C0194C"  alt="image"></p>
<h2 id="同步请求-1"><a href="#同步请求-1" class="headerlink" title="同步请求"></a>同步请求</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/22746/E59131FA16C1481E97D46E456075BB1D"  alt="image"></p>
<h3 id="RealCalll-execute"><a href="#RealCalll-execute" class="headerlink" title="RealCalll.execute()"></a>RealCalll.execute()</h3><p>这方法主要处理：</p>
<ul>
<li>校验任务是否被执行过</li>
<li>将任务加入同步队列</li>
<li>触发拦截器处理Request队列内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">override fun execute(): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; 如果Call已经被执行过，则不允许被重复执行</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">     executed &#x3D; true</span><br><span class="line">   &#125;</span><br><span class="line">   timeout.enter()</span><br><span class="line">   callStart()</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; Dispatcher 只是将该同步任务加入 runnigSyncCalls 队列中</span><br><span class="line">     client.dispatcher.executed(this)</span><br><span class="line">     &#x2F;&#x2F; 拦截器</span><br><span class="line">     return getResponseWithInterceptorChain()</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     client.dispatcher.finished(this)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dispatcher-executed-call-RealCall"><a href="#Dispatcher-executed-call-RealCall" class="headerlink" title="Dispatcher.executed(call:RealCall)"></a>Dispatcher.executed(call:RealCall)</h3><p>在Dispatcher 维护着多种队列<code>runningAsyncCalls</code>、<code>runningSyncCalls</code>、‘<code>readyAsyncCalls</code>，这里触发的同步任务，是将任务添加到 <code>runningSyncCalls</code> 中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#x2F;&#x2F; ArrayDeque 是Deque的实现类，同样是使用一个数组维护，是线程不安全的集合对象，效率高于栈和LinkeList，可以作为双端队列也可以作为栈</span><br><span class="line">private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">...</span><br><span class="line">@Synchronized internal fun executed(call: RealCall) &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="getResponseWithInterceptorChain-触发拦截器处理"><a href="#getResponseWithInterceptorChain-触发拦截器处理" class="headerlink" title="getResponseWithInterceptorChain 触发拦截器处理"></a>getResponseWithInterceptorChain 触发拦截器处理</h3><p>在Okhttp所有请求中最终都将进入对拦截器的处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line"> internal fun getResponseWithInterceptorChain(): Response &#123;</span><br><span class="line">   &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">   val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 添加所有应用拦截器</span><br><span class="line">   interceptors +&#x3D; client.interceptors</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 重试拦截器</span><br><span class="line">   interceptors +&#x3D; RetryAndFollowUpInterceptor(client)</span><br><span class="line">   interceptors +&#x3D; BridgeInterceptor(client.cookieJar)</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 缓存专用拦截器</span><br><span class="line">   interceptors +&#x3D; CacheInterceptor(client.cache)</span><br><span class="line">   interceptors +&#x3D; ConnectInterceptor</span><br><span class="line">   </span><br><span class="line">   if (!forWebSocket) &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果不是websocket 则添加Network拦截器</span><br><span class="line">     interceptors +&#x3D; client.networkInterceptors</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F; 最后一个才是真正调用服务器请求入口，因此需要保证是最后一个</span><br><span class="line">   interceptors +&#x3D; CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 开始组建责任链，建立包装类，index指向拦截器队列的头部</span><br><span class="line">   val chain &#x3D; RealInterceptorChain(interceptors, this, null, 0, originalRequest,</span><br><span class="line">       client.connectTimeoutMillis,</span><br><span class="line">       client.readTimeoutMillis, client.writeTimeoutMillis)</span><br><span class="line"></span><br><span class="line">   var calledNoMoreExchanges &#x3D; false</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 责任链开始，在每一级的Interceptor都要求调用chain的process方法，这样构成了一级一级向下的责任</span><br><span class="line">     val response &#x3D; chain.proceed(originalRequest)</span><br><span class="line">     if (isCanceled()) &#123;</span><br><span class="line">       response.closeQuietly()</span><br><span class="line">       throw IOException(&quot;Canceled&quot;)</span><br><span class="line">     &#125;</span><br><span class="line">     return response</span><br><span class="line">   &#125; catch (e: IOException) &#123;</span><br><span class="line">     calledNoMoreExchanges &#x3D; true</span><br><span class="line">     throw noMoreExchanges(e) as Throwable</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     if (!calledNoMoreExchanges) &#123;</span><br><span class="line">       noMoreExchanges(null)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>RealInterceptorChain.proceed(request: Request, exchange: Exchange?)</li>
</ul>
<p>proceed(request: Requst) 最终由 proceed(request: Request, exchange: Exchange?) 代理执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line">  fun proceed(request: Request, exchange: Exchange?): Response &#123;</span><br><span class="line">    if (index &gt;&#x3D; interceptors.size) throw AssertionError()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录调用proceed次数</span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果有 Exchange，</span><br><span class="line">    check(this.exchange &#x3D;&#x3D; null || this.exchange.connection()!!.supportsUrl(request.url)) &#123;</span><br><span class="line">      &quot;network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 确保每个chain.proceed 只能被调用一次</span><br><span class="line">    check(this.exchange &#x3D;&#x3D; null || calls &lt;&#x3D; 1) &#123;</span><br><span class="line">      &quot;network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里产生指向下一个拦截器（index + 1）的处理链，并将这个作为参数传入给当前的拦截器(index)</span><br><span class="line">    val next &#x3D; RealInterceptorChain(interceptors, call, exchange,</span><br><span class="line">        index + 1, request, connectTimeout, readTimeout, writeTimeout)</span><br><span class="line">    val interceptor &#x3D; interceptors[index]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 执行当前所指向的拦截器的intercept方法</span><br><span class="line">    @Suppress(&quot;USELESS_ELVIS&quot;)</span><br><span class="line">    val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">        &quot;interceptor $interceptor returned null&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 确保 procceed() 只能被调用一次</span><br><span class="line">    check(exchange &#x3D;&#x3D; null || index + 1 &gt;&#x3D; interceptors.size || next.calls &#x3D;&#x3D; 1) &#123;</span><br><span class="line">      &quot;network interceptor $interceptor must call proceed() exactly once&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 校验Response</span><br><span class="line">    check(response.body !&#x3D; null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125;</span><br><span class="line"></span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Chain 提供的是将interceptor 进行串联 并以以递归的形式向下传递（要求子intercptor 必须调用 intercept(chain: Interceptor.Chain) 参数 chain.process() 方法），最终进行网络请求的是最后的拦截器类 <code>CallServerInterceptor</code></p>
<ul>
<li>CallServerInterceptor.intercept(chain: Interceptor.Chain) 处理网络请求</li>
</ul>
<p>在 proceed 的方法处理中，提到了 Exchange 类，这里 Exchange 是对 HTTP 事务的包装(实际指向 ExchangeCodec)，因此在这里面最重要的是使用该类进行处理的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val exchange &#x3D; realChain.exchange()</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    val requestBody &#x3D; request.body</span><br><span class="line">    val sentRequestMillis &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对头部数据进行写入</span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    var invokeStartEvent &#x3D; true</span><br><span class="line">    var responseBuilder: Response.Builder? &#x3D; null</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 处理非 GET 和 HEAD 方式的请求，对body进行处理</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; HTTP&#x2F;1.1 协议里设计100 (Continue) HTTP 状态码的的目的是，在客户端发送 Request Message 之前，HTTP&#x2F;1.1 协议允许客户端先判定服务器是否愿意接受客户端发来的消息主体（基于 Request Headers）。即， 客户端 在 Post（较大）数据到服务端之前，允许双方“握手”，如果匹配上了，Client 才开始发送（较大）数据，如果 client 预期等待“100-continue”的应答，那么它发的请求必须包含一个 &quot; Expect: 100-continue&quot;  的头域！</span><br><span class="line"></span><br><span class="line">      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果头部域包含 Expect:100-continue 则进行预请求，判断服务器是否允许body传递，防止服务器拒收</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; true)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; HTTP&#x2F;2 的全双工，暂时忽略，需要客户端和服务端的支持</span><br><span class="line">        if (requestBody.isDuplex()) &#123;</span><br><span class="line">          &#x2F;&#x2F; Prepare a duplex body so that the application can send a request body later.</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, true).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, false).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 使用了 Expect: 100-continue 情况</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        &#x2F;&#x2F; 如果不是多路复用的情况</span><br><span class="line">        if (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          &#x2F;&#x2F; If the &quot;Expect: 100-continue&quot; expectation wasn&#39;t met, prevent the HTTP&#x2F;1 connection</span><br><span class="line">          &#x2F;&#x2F; from being reused. Otherwise we&#39;re still obligated to transmit the request body to</span><br><span class="line">          &#x2F;&#x2F; leave the connection in a consistent state.</span><br><span class="line">          &#x2F;&#x2F; 执行了该动作，会导致不会有进一步的数据事务发生，</span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 因为不存在 body 体，释放request body资源释放</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 结束请求（返回Response），实际也调用了 Sink.flush()</span><br><span class="line">    if (requestBody &#x3D;&#x3D; null || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 读取 Response 信息（如果还未产生 Response 构建的情况）</span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    var code &#x3D; response.code</span><br><span class="line">    if (code &#x3D;&#x3D; 100) &#123;</span><br><span class="line">      &#x2F;&#x2F; Server sent a 100-continue even though we did not request one. Try again to read the actual</span><br><span class="line">      &#x2F;&#x2F; response status.</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response &#x3D; responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code &#x3D; response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response &#x3D; if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">      &#x2F;&#x2F; Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">      &#x2F;&#x2F; 对于 websocket 和 100-continue 情况</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 普通请求</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase &#x3D; true) ||</span><br><span class="line">        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    if ((code &#x3D;&#x3D; 204 || code &#x3D;&#x3D; 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123;</span><br><span class="line">      throw ProtocolException(</span><br><span class="line">          &quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步请求-1"><a href="#异步请求-1" class="headerlink" title="异步请求"></a>异步请求</h2><p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23141/42B3A1AC46224242AD49DFB2FE684D5C"  alt="image"></p>
<h3 id="Call-enqueue-responseCallback-Callback"><a href="#Call-enqueue-responseCallback-Callback" class="headerlink" title="Call.enqueue(responseCallback: Callback)"></a>Call.enqueue(responseCallback: Callback)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">    executed &#x3D; true</span><br><span class="line">  &#125;</span><br><span class="line">  callStart()</span><br><span class="line">  client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同样需要对Call进行是否执行过的校验</li>
<li>对RealCall使用AsyncCall进行包装</li>
<li>将AsynCall添加Dispatcher的异步队列中</li>
</ul>
<h3 id="Dispatcher-enqueue-call-AsyncCall"><a href="#Dispatcher-enqueue-call-AsyncCall" class="headerlink" title="Dispatcher.enqueue(call: AsyncCall)"></a>Dispatcher.enqueue(call: AsyncCall)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">internal fun enqueue(call: AsyncCall) &#123;</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加异步任务的就绪异步执行队列    </span><br><span class="line">    readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span><br><span class="line">    &#x2F;&#x2F; the same host.</span><br><span class="line">    if (!call.get().forWebSocket) &#123;</span><br><span class="line">      val existingCall &#x3D; findExistingCallWithHost(call.host())</span><br><span class="line">      if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 触发执行异步内容</span><br><span class="line">  promoteAndExecute()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Dispatcher-promoteAndExecute"><a href="#Dispatcher-promoteAndExecute" class="headerlink" title="Dispatcher.promoteAndExecute()"></a>Dispatcher.promoteAndExecute()</h3><ul>
<li>检查正在请求总数是否超限、检查单个Host正在请求数是否超限</li>
<li>自增当前可请求Host计数器</li>
<li>开始执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提供线程池用于异步请求任务执行</span><br><span class="line">@get:Synchronized</span><br><span class="line">@get:JvmName(&quot;executorService&quot;) val executorService: ExecutorService</span><br><span class="line">  get() &#123;</span><br><span class="line">    if (executorServiceOrNull &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 无核心线程，并且不限制所启动的线程数量，保留60即退出线程</span><br><span class="line">      executorServiceOrNull &#x3D; ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,</span><br><span class="line">          SynchronousQueue(), threadFactory(&quot;$okHttpName Dispatcher&quot;, false))</span><br><span class="line">    &#125;</span><br><span class="line">    return executorServiceOrNull!!</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">private fun promoteAndExecute(): Boolean &#123;</span><br><span class="line">  this.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">  val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">  val isRunning: Boolean</span><br><span class="line">  synchronized(this) &#123;</span><br><span class="line">    val i &#x3D; readyAsyncCalls.iterator()</span><br><span class="line">    while (i.hasNext()) &#123;</span><br><span class="line">      val asyncCall &#x3D; i.next()</span><br><span class="line">      &#x2F;&#x2F; 当前执行的异步认为大于最大数量则终止</span><br><span class="line">      if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity.</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 当前所调用的host请求数量大于最大限制，跳过当前请求</span><br><span class="line">      if (asyncCall.callsPerHost().get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity.</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 将允许执行的任务从就绪队列中移除</span><br><span class="line">      i.remove()</span><br><span class="line">      &#x2F;&#x2F; 记录当前请求host数量计数器</span><br><span class="line">      asyncCall.callsPerHost().incrementAndGet()</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 将允许执行的任务添加到正在执行队列中</span><br><span class="line">      executableCalls.add(asyncCall)</span><br><span class="line">      runningAsyncCalls.add(asyncCall)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 是否有正在执行的任务（包括异步和同步任务）</span><br><span class="line">    isRunning &#x3D; runningCallsCount() &gt; 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 开始执行允许执行的队列，executorService 为线程池</span><br><span class="line">  for (i in 0 until executableCalls.size) &#123;</span><br><span class="line">    val asyncCall &#x3D; executableCalls[i]</span><br><span class="line">    asyncCall.executeOn(executorService)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return isRunning</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RealCall-executeOn-executorService-ExecutorService"><a href="#RealCall-executeOn-executorService-ExecutorService" class="headerlink" title="RealCall.executeOn(executorService: ExecutorService)"></a>RealCall.executeOn(executorService: ExecutorService)</h3><ul>
<li>执行任务并且处理启动过程中（非执行）发生的异常捕获</li>
<li>对于异常启动的情况，需要回调给Dispatcher通知结束状态</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fun executeOn(executorService: ExecutorService) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查当前线程是否持有 Dispatcher 锁</span><br><span class="line">      client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">      var success &#x3D; false</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 线程池执行该内容，</span><br><span class="line">        executorService.execute(this)</span><br><span class="line">        success &#x3D; true</span><br><span class="line">      &#125; catch (e: RejectedExecutionException) &#123;</span><br><span class="line">        val ioException &#x3D; InterruptedIOException(&quot;executor rejected&quot;)</span><br><span class="line">        ioException.initCause(e)</span><br><span class="line">        &#x2F;&#x2F; 对于异常情况，会在 noMoreExchanges中根据情况释放连接</span><br><span class="line">        noMoreExchanges(ioException)</span><br><span class="line">        &#x2F;&#x2F; 回调给之前传入的Callback失败信息</span><br><span class="line">        responseCallback.onFailure(this@RealCall, ioException)</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; 通知Dispatcher结束请求</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">          client.dispatcher.finished(this) &#x2F;&#x2F; This call is no longer running!</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从以上线程池执行可以看出<code>AsyncCall</code>本身是一个<code>Runnable</code>对象，因此具体的执行内容需要从<code>AsyncCall.run()</code> 入手。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  override fun run() &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里只是命名线程名，并且对闭包内容在内部进行执行</span><br><span class="line">    threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 标记是否需要进行回调结果，由于异常可能发生在 onResponse 的时候，所以为了避免两次callback回调，进行标记处理</span><br><span class="line">      var signalledCallback &#x3D; false</span><br><span class="line">      timeout.enter()</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 在这里又重新进入了 getResponseWithInterceptorChain 的分析，参照同步请求的流程</span><br><span class="line">        val response &#x3D; getResponseWithInterceptorChain()</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 为下面的回调进行标记，以及被回调过，防止再次发生异常时，重复执行回调（异常的回调）</span><br><span class="line">        signalledCallback &#x3D; true</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 对之前传入的 callback 进行成功回调</span><br><span class="line">        responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">      &#125; catch (e: IOException) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          &#x2F;&#x2F; Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(this@RealCall, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (t: Throwable) &#123;</span><br><span class="line">      </span><br><span class="line">        &#x2F;&#x2F; 异常发生时，对请求进行一些取消行为</span><br><span class="line">        cancel()</span><br><span class="line">        if (!signalledCallback) &#123;</span><br><span class="line">        </span><br><span class="line">          &#x2F;&#x2F; 同样是对失败时的处理，包装异常类，通知之前的回调callback</span><br><span class="line">          val canceledException &#x3D; IOException(&quot;canceled due to $t&quot;)</span><br><span class="line">          canceledException.addSuppressed(t)</span><br><span class="line">          responseCallback.onFailure(this@RealCall, canceledException)</span><br><span class="line">        &#125;</span><br><span class="line">        throw t</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;  结束通知</span><br><span class="line">        client.dispatcher.finished(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Dispatcher-finished"><a href="#Dispatcher-finished" class="headerlink" title="Dispatcher.finished()"></a>Dispatcher.finished()</h4><p>无论是在成功或失败请求后，都需要在最后通知Dispatcher进行finished()动作。</p>
<ul>
<li>在结束任务通知后 继续调用promoteAndExecute()尝试启动新一轮任务（如果还有异步任务的话）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123;</span><br><span class="line">   &#x2F;&#x2F; 单元测试时用到</span><br><span class="line">   val idleCallback: Runnable?</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     if (!calls.remove(call)) throw AssertionError(&quot;Call wasn&#39;t in-flight!&quot;)</span><br><span class="line">     idleCallback &#x3D; this.idleCallback</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val isRunning &#x3D; promoteAndExecute()</span><br><span class="line"></span><br><span class="line">   if (!isRunning &amp;&amp; idleCallback !&#x3D; null) &#123;</span><br><span class="line">     idleCallback.run()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>在每次结束后都持续检测是否仍然有需要进行处理的任务。</p>
<h1 id="四、拦截器"><a href="#四、拦截器" class="headerlink" title="四、拦截器"></a>四、拦截器</h1><p>在以上的流程中，我们不难看出，Okhttp 在具体请求优化方面会体现在拦截器中，通过责任链模式，下面解析下各个拦截器的能力。</p>
<p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/23954/5D1289AAEE5549BFA22870B476842CF1"  alt="image"></p>
<h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><p>该拦截器主要负责：</p>
<ul>
<li>创建连接ExchangeFinder 用于连接要求</li>
<li>当发生异常，对可进行恢复重试的连接进行恢复请求</li>
<li>当发生多次连接情况（重定向、授权要求），自动进行二次或多次连接</li>
<li>连接资源释放</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  var request &#x3D; chain.request()</span><br><span class="line">  val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">  val call &#x3D; realChain.call()</span><br><span class="line">  &#x2F;&#x2F; 用于计数循环请求（重定向）次数，该次数不能超过20次，否则抛出异常</span><br><span class="line">  var followUpCount &#x3D; 0</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 用于存储上个循环中所获得的Response，用于下次循环产生的Response对之前Response的追溯，可以跟踪重定向的来源等信息</span><br><span class="line">  var priorResponse: Response? &#x3D; null</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化ExchangeFinder ，为后面连接使用</span><br><span class="line">    call.prepareExchangeFinder(request)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断是否发生取消</span><br><span class="line">    if (call.isCanceled()) &#123;</span><br><span class="line">      throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对于异常情况，根据异常信息进行重试处理</span><br><span class="line">    var response: Response</span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取请求后的 Response</span><br><span class="line">      response &#x3D; realChain.proceed(request, null)</span><br><span class="line">      success &#x3D; true</span><br><span class="line">    &#125; catch (e: RouteException) &#123;</span><br><span class="line">      &#x2F;&#x2F; RouteException发生于请求开始，因此requestSendStarted为false，如果该连接不可恢复则抛出异常，否则继续循环</span><br><span class="line">      if (!recover(e.lastConnectException, call, false, request)) &#123;</span><br><span class="line">        throw e.firstConnectException</span><br><span class="line">      &#125;</span><br><span class="line">      continue</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      &#x2F;&#x2F; IOException 可能发生于连接过程中，可能已发送部分请求或全部成功，如果是在连接后发生的异常，则请求可能是以及被发送出去了，标记requestSendStarted为true</span><br><span class="line">      val requestSendStarted &#x3D; e !is ConnectionShutdownException</span><br><span class="line">      if (!recover(e, call, requestSendStarted, request)) throw e</span><br><span class="line">      continue</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; 不成功时强制关闭资源</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        call.exchangeDoneDueToException()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果上一个请求有返回Response，并且进入二次请求要求的话，则进行重新包装，用于之后的再次请求，</span><br><span class="line">    if (priorResponse !&#x3D; null) &#123;</span><br><span class="line">      response &#x3D; response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">              .body(null)</span><br><span class="line">              .build())</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val exchange &#x3D; response.exchange</span><br><span class="line">    val route &#x3D; exchange?.connection()?.route()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据Response结果要求产生新的Request，比如重定向、授权要求等</span><br><span class="line">    val followUp &#x3D; followUpRequest(response, route)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有进一步请求要求则直接返回当前的Response</span><br><span class="line">    if (followUp &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (exchange !&#x3D; null &amp;&amp; exchange.isDuplex) &#123;</span><br><span class="line">        call.timeoutEarlyExit()</span><br><span class="line">      &#125;</span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果有多次请求要求，但是设置只允许请求一次的情况，只能返回Response</span><br><span class="line">    val followUpBody &#x3D; followUp.body</span><br><span class="line">    if (followUpBody !&#x3D; null &amp;&amp; followUpBody.isOneShot()) &#123;</span><br><span class="line">      return response</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 处理只有关闭的连接和资源的动作</span><br><span class="line">    response.body?.closeQuietly()</span><br><span class="line">    if (call.hasExchange()) &#123;</span><br><span class="line">      exchange?.detachWithViolence()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 限制最大重定向（重新请求）次数不能超过20次</span><br><span class="line">    if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">      throw ProtocolException(&quot;Too many follow-up requests: $followUpCount&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 将请求信息预留给下次循环的请求</span><br><span class="line">    request &#x3D; followUp</span><br><span class="line">    priorResponse &#x3D; response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  private fun recover(</span><br><span class="line">  e: IOException,</span><br><span class="line">  call: RealCall,</span><br><span class="line">  requestSendStarted: Boolean,</span><br><span class="line">  userRequest: Request</span><br><span class="line">): Boolean &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果设置了禁止重试（OkHttpClient.Builder.retryOnConnectionFailure(Boolean)），则不进行重试</span><br><span class="line">  if (!client.retryOnConnectionFailure) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 对于 设置有body的 Request 的 RequestBody.isOneShot 的方法返回trues时，则只允许发送一次，不允许重试请求</span><br><span class="line">  if (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 根据异常信息判断该连接是否可以进行恢复重试</span><br><span class="line">  &#x2F;&#x2F; 1. 如果是协议异常则不进行重试</span><br><span class="line">  &#x2F;&#x2F; 2. 如果为中断异常但是不是连接超时的情况也不允许</span><br><span class="line">  &#x2F;&#x2F; 3. 如果是SSL握手异常并且是证书相关异常则不允许</span><br><span class="line">  &#x2F;&#x2F; 4. 如果是SSL验证结果不可信异常则不允许</span><br><span class="line">  if (!isRecoverable(e, requestSendStarted)) return false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 检测如果不是流传输异常或者没有Route可以尝试的话，则不进行重试</span><br><span class="line">  if (!call.canRetry()) return false</span><br><span class="line">  return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><p>该拦截器用于处理:</p>
<ul>
<li>头部信息修正或者默认值处理，具体修改参考下面注释</li>
<li>Cookie支持，对服务器返回的Cookie信息回传给CookieJar处理</li>
<li>Gzip支持，对支持Gzip的请求结果Response进行解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 主要进行头部信息填充</span><br><span class="line">   * Content-Type:  来源于 RequestBody.contentType() （覆盖设置）</span><br><span class="line">   * Content-Length: 来源于 RequestBody.contentLength()，如果length &#x3D; -1 则进行 Transfer-Encoding: chunked 头部填充 （覆盖设置）</span><br><span class="line">   * Host: 来源于 Request.url.toHostHeader() （没有才进行填充）</span><br><span class="line">   * Connection: 默认设置 Keep-Alive (如果没有的话才设置，有的话则不继续替换)</span><br><span class="line">   * Accept-Encoding: 如果没设置 Accept-Encoding 并且没有设置Range(断点) 则默认设置 Accept-Encoding: gzip</span><br><span class="line">   * Cookie：这里的 Cookie 来源于 OkHttpClient.Builder.cookieJar(cookieJar: CookieJar)的设置，默认OkHttpClient为 CookieJar.NoCookies，没有Cookie 信息 (覆盖设置)</span><br><span class="line">   * User-Agent: 如果没设置，默认 okhttp&#x2F;4.4.0-SNAPSHOT</span><br><span class="line">   *&#x2F;</span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val userRequest &#x3D; chain.request()</span><br><span class="line">    val requestBuilder &#x3D; userRequest.newBuilder()</span><br><span class="line"></span><br><span class="line">    val body &#x3D; userRequest.body</span><br><span class="line">    if (body !&#x3D; null) &#123;</span><br><span class="line">      val contentType &#x3D; body.contentType()</span><br><span class="line">      if (contentType !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 根据body的contentType 信息进行 mime 内容头部信息填充</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      val contentLength &#x3D; body.contentLength()</span><br><span class="line">      if (contentLength !&#x3D; -1L) &#123;</span><br><span class="line">        </span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, contentLength.toString())</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;)</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, userRequest.url.toHostHeader())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 标记gzip是否设置，用于后面解析Response判断</span><br><span class="line">    var transparentGzip &#x3D; false</span><br><span class="line">    &#x2F;&#x2F; 如果没设置 Accept-Encoding 并且没有设置Range(断点) 则默认设置 Accept-Encoding: gzip</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) &#x3D;&#x3D; null &amp;&amp; userRequest.header(&quot;Range&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      transparentGzip &#x3D; true</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这里的 cookieJar 来源于 OkHttpClient.Builder.cookieJar(cookieJar: CookieJar)的设置，默认OkHttpClient为 CookieJar.NoCookies </span><br><span class="line">    &#x2F;&#x2F; 不设置Cookie 支持（Cookies 为空非null）,如果有则生成头部 Cookie 段</span><br><span class="line">    val cookies &#x3D; cookieJar.loadForRequest(userRequest.url)</span><br><span class="line">    if (cookies.isNotEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) &#x3D;&#x3D; null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, userAgent)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val networkResponse &#x3D; chain.proceed(requestBuilder.build())</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 解析Cookie 并回传给 CookieJar 进行处理</span><br><span class="line">    cookieJar.receiveHeaders(userRequest.url, networkResponse.headers)</span><br><span class="line"></span><br><span class="line">    val responseBuilder &#x3D; networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 处理gzip内容，如果之前设置了 gzip 支持，并且所返回的服务器 Response 同样 Content-Encoding 支持 gzip，则对返回的Response</span><br><span class="line">    &#x2F;&#x2F; 进行 gzip 解析并添加到新的Reponse 中</span><br><span class="line">    if (transparentGzip &amp;&amp;</span><br><span class="line">        &quot;gzip&quot;.equals(networkResponse.header(&quot;Content-Encoding&quot;), ignoreCase &#x3D; true) &amp;&amp;</span><br><span class="line">        networkResponse.promisesBody()) &#123;</span><br><span class="line">      val responseBody &#x3D; networkResponse.body</span><br><span class="line">      if (responseBody !&#x3D; null) &#123;</span><br><span class="line">        val gzipSource &#x3D; GzipSource(responseBody.source())</span><br><span class="line">        val strippedHeaders &#x3D; networkResponse.headers.newBuilder()</span><br><span class="line">            .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">            .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">            .build()</span><br><span class="line">        responseBuilder.headers(strippedHeaders)</span><br><span class="line">        val contentType &#x3D; networkResponse.header(&quot;Content-Type&quot;)</span><br><span class="line">        responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer()))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><p>前面提到OkHttp 缓存拦截器 CacheInterceptor，在该拦截器中实现了网络缓存的绝大逻辑。</p>
<p>在intercept 工作中主要处理：</p>
<ul>
<li>根据 HTTP的缓存规则（比如根据头部信息、Tag等缓存条件）判断当前所进行的请求，以及在缓存中缓存的内容是否能命中该次请求（通过CacheStrategy进行构造处理）</li>
<li>对Request是否满足和Response是否满足进行分别处理：<ul>
<li>如果Request不满足条件（策略会校验是否有网络等情况，如果不满足则返回null) 而缓存Response 满足，则返回缓存Response</li>
<li>如果Request 和缓存Response 都不满足，则返回504 Response</li>
<li>如果Request 满足 而 缓存Response不满足，则使用请求后的Respnse</li>
<li>对于304结果，更新缓存并且返回缓存Response </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">  &#x2F;&#x2F; cache 来源于 OkHttpClient.Builder.cache(cache: Cache?)，默认为null</span><br><span class="line">  val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">  val now &#x3D; System.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 传入当前请求信息和获得的候选缓存Response，根据一些HTTP缓存规则，判断当前候选Reponse是否可用，对Request也会进行一些判断，比如当前网络是否可用</span><br><span class="line">  val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  val networkRequest &#x3D; strategy.networkRequest &#x2F;&#x2F; 如果网络不可用，则默认这里会为null</span><br><span class="line">  val cacheResponse &#x3D; strategy.cacheResponse &#x2F;&#x2F; 如果cacheCandidate可用，则这里会返回一致，如果不可用则返回null（缓存过期之类的）</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 单元测试使用</span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当前从缓存中获得的缓存候选和实际计算出的缓存Response不匹配（不符合条件，为空），则抛弃候选缓存Cache</span><br><span class="line">  if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果返回的网络请求为空，则说明网络当前不可用，并且允许缓存Response也为空，则默认返回504即可</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-1L)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果仅是网络不可用导致Request不能请求，那么直接返回命中的Response缓存即可，复用结果</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 执行网络请求</span><br><span class="line">  var networkResponse: Response? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">    networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">    if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果缓存存在，并且服务器返回304则更新下缓存信息并返回</span><br><span class="line">  if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">    if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line"></span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">      &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)</span><br><span class="line">      return response</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果有缓存器，并且缓存策略允许被缓存，则添加到缓存中</span><br><span class="line">  if (cache !&#x3D; null) &#123;</span><br><span class="line">    if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">      val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">      return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;  目前缓存只缓存GET请求内容，官方解释说，如果所有的形式都缓存，复杂度高但是收效低，则对于非法的缓存进行移除（GET不需要？)</span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; catch (_: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>在CacheInterceptor 中比较重要的是 <code>Cache</code> 类，它提供了整个缓存下的功能。这里分析下该类的主要构成。</p>
<p>从 Cache 中，我们不难发现，它所有的缓存行为都是通过 <code>DiskLruCache</code>进行代理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"> internal val cache &#x3D; DiskLruCache(</span><br><span class="line">     fileSystem &#x3D; fileSystem,</span><br><span class="line">     directory &#x3D; directory,</span><br><span class="line">     appVersion &#x3D; VERSION,</span><br><span class="line">     valueCount &#x3D; ENTRY_COUNT,</span><br><span class="line">     maxSize &#x3D; maxSize,</span><br><span class="line">     taskRunner &#x3D; TaskRunner.INSTANCE</span><br><span class="line"> )</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> internal fun get(request: Request): Response? &#123;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; Okhttp 都是简单用Url作为索引</span><br><span class="line">   val key &#x3D; key(request.url)</span><br><span class="line">   val snapshot: DiskLruCache.Snapshot &#x3D; try &#123;</span><br><span class="line">       &#x2F;&#x2F; 通过DiskLruCache 获取缓存中的对象，如果没有则直接异常返回null</span><br><span class="line">     cache[key] ?: return null</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     return null &#x2F;&#x2F; Give up because the cache cannot be read.</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 包装为Cache.Entry 对象，在Entry 中对 Snapshot对象进行解析，并对Entry中的字段进行赋值，转化为业务含义的的信息</span><br><span class="line">   val entry: Entry &#x3D; try &#123;</span><br><span class="line">     Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">   &#125; catch (_: IOException) &#123;</span><br><span class="line">     snapshot.closeQuietly()</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 解析Snaphost中的 Reponse缓存信息，并转化为 Reponse 业务对象</span><br><span class="line">   val response &#x3D; entry.response(snapshot)</span><br><span class="line">   if (!entry.matches(request, response)) &#123;</span><br><span class="line">     response.body?.closeQuietly()</span><br><span class="line">     return null</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return response</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">  fun response(snapshot: DiskLruCache.Snapshot): Response &#123;</span><br><span class="line">     val contentType &#x3D; responseHeaders[&quot;Content-Type&quot;]</span><br><span class="line">     val contentLength &#x3D; responseHeaders[&quot;Content-Length&quot;]</span><br><span class="line">     val cacheRequest &#x3D; Request.Builder()</span><br><span class="line">         .url(url)</span><br><span class="line">         .method(requestMethod, null)</span><br><span class="line">         .headers(varyHeaders)</span><br><span class="line">         .build()</span><br><span class="line">     return Response.Builder()</span><br><span class="line">         .request(cacheRequest)</span><br><span class="line">         .protocol(protocol)</span><br><span class="line">         .code(code)</span><br><span class="line">         .message(message)</span><br><span class="line">         .headers(responseHeaders)</span><br><span class="line">         .body(CacheResponseBody(snapshot, contentType, contentLength))</span><br><span class="line">         .handshake(handshake)</span><br><span class="line">         .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">         .receivedResponseAtMillis(receivedResponseMillis)</span><br><span class="line">         .build()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Cache</code>中更多的是对DiskLruCache 所需要处理的信息进行拆包和包装，因此这里我们直接看 <code>DiskLruCache</code>。</p>
<h4 id="DiskLruCache"><a href="#DiskLruCache" class="headerlink" title="DiskLruCache"></a>DiskLruCache</h4><p>在 DiskLruCache 主要分成几种对象结构：</p>
<ul>
<li>Entry 单个缓存数据的代理对象，用于在 LinkHashMap 中的存储，规定了缓存文件（cleanFiles）、临时文件（dirtyFiles）以及提供了 Snapshot 对象入口，Entry 不对数据有写入能力。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">internal inner class Entry internal constructor(</span><br><span class="line">    internal val key: String</span><br><span class="line">  ) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 数据长度</span><br><span class="line">    internal val lengths: LongArray &#x3D; LongArray(valueCount)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于正式写入的文件</span><br><span class="line">    internal val cleanFiles &#x3D; mutableListOf&lt;File&gt;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于临时数据写入的文件，目前默认都是2个，最终需要调用Edit.commit 才能写入正式文件</span><br><span class="line">    internal val dirtyFiles &#x3D; mutableListOf&lt;File&gt;()</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 文件是否可读取</span><br><span class="line">    internal var readable: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 记录当前被编辑的对象，有且只能有一个在编辑</span><br><span class="line">    internal var currentEditor: Editor? &#x3D; null</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 每一个Snapshot 会产生一个序列号，每次发生Edit.commit后 序列号都会发生变化</span><br><span class="line">    internal var sequenceNumber: Long &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 产生当前Entry对应的Snapshot对象</span><br><span class="line">    internal fun snapshot(): Snapshot?</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Snapshot 负责对缓存数据的详细源记录，包括值信息、磁盘缓存数据源（File Source)、数据长度等。提供给外部获取具体缓存内容使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inner class Snapshot internal constructor(</span><br><span class="line">  private val key: String, </span><br><span class="line">  private val sequenceNumber: Long, &#x2F;&#x2F; 每个独立提交都对应一个</span><br><span class="line">  private val sources: List&lt;Source&gt;, &#x2F;&#x2F; 缓存文件目前只有两个 0 index 为头文件 1 为 body 文件</span><br><span class="line">  private val lengths: LongArray &#x2F;&#x2F; 数据长度信息</span><br><span class="line">) : Closeable &#123;</span><br><span class="line">  fun key(): String &#x3D; key</span><br><span class="line">  &#x2F;&#x2F; 获得一个Edit 对象，对内容进行编辑事务处理。</span><br><span class="line">  fun edit(): Editor? &#x3D; this@DiskLruCache.edit(key, sequenceNumber)</span><br><span class="line">  fun getSource(index: Int): Source &#x3D; sources[index]</span><br><span class="line">  override fun close() &#123;</span><br><span class="line">    for (source in sources) &#123;</span><br><span class="line">      source.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Edit 负责对数据的写入事务处理，在完成事务有需要进行 commit 提交<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Edits the values for an entry. *&#x2F;</span><br><span class="line"> inner class Editor internal constructor(internal val entry: Entry) &#123;</span><br><span class="line">   &#x2F;&#x2F; 用来标记开启几个写入文件</span><br><span class="line">   internal val written: BooleanArray? &#x3D; if (entry.readable) null else BooleanArray(valueCount)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 检查 edit事务是否完成 commit 和 abort 可以触发 done &#x3D; true 动作</span><br><span class="line">   private var done: Boolean &#x3D; false</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 移除临时目录下所有文件</span><br><span class="line">   internal fun detach()</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 返回指定的数据源（正式数据）（目前index &#x3D; 0 为头文件  index &#x3D; 1 为body文件）</span><br><span class="line">   fun newSource(index: Int): Source?</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建临时文件的写入代理</span><br><span class="line">   fun newSink(index: Int): Sink </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 提交修改的数据，将临时文件转为正式缓存文件</span><br><span class="line">   fun commit() </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 放弃修改，会将所有临时文件删除</span><br><span class="line">   fun abort() </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="缓存溢出处理"><a href="#缓存溢出处理" class="headerlink" title="缓存溢出处理"></a>缓存溢出处理</h5><p>在每次发生修改、提交都将对内容进行队列内容进行检测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F; 一个包装的线程池</span><br><span class="line"> private val cleanupQueue &#x3D; taskRunner.newQueue()</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 清理任务</span><br><span class="line"> private val cleanupTask &#x3D; object : Task(&quot;$okHttpName Cache&quot;) &#123;</span><br><span class="line">   override fun runOnce(): Long &#123;</span><br><span class="line">     synchronized(this@DiskLruCache) &#123;</span><br><span class="line">       if (!initialized || closed) &#123;</span><br><span class="line">         return -1L &#x2F;&#x2F; Nothing to do.</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">        &#x2F;&#x2F; LinkHashMap 容量检测</span><br><span class="line">         trimToSize()</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         mostRecentTrimFailed &#x3D; true</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">        &#x2F;&#x2F; 日志清除</span><br><span class="line">         if (journalRebuildRequired()) &#123;</span><br><span class="line">           rebuildJournal()</span><br><span class="line">           redundantOpCount &#x3D; 0</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; catch (_: IOException) &#123;</span><br><span class="line">         mostRecentRebuildFailed &#x3D; true</span><br><span class="line">         journalWriter &#x3D; blackholeSink().buffer()</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return -1L</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line">  @get:Synchronized @set:Synchronized var maxSize: Long &#x3D; maxSize</span><br><span class="line">  set(value) &#123;</span><br><span class="line">     field &#x3D; value</span><br><span class="line">     if (initialized) &#123;</span><br><span class="line">       cleanupQueue.schedule(cleanupTask) &#x2F;&#x2F; 初始化缓存容量时对当前缓存进行一次清理</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> fun trimToSize() &#123;</span><br><span class="line">   while (size &gt; maxSize) &#123;</span><br><span class="line">     val toEvict &#x3D; lruEntries.values.iterator().next()</span><br><span class="line">     removeEntry(toEvict)</span><br><span class="line">   &#125;</span><br><span class="line">   mostRecentTrimFailed &#x3D; false</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> internal fun removeEntry(entry: Entry): Boolean &#123;</span><br><span class="line">   entry.currentEditor?.detach() &#x2F;&#x2F; Prevent the edit from completing normally.</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 移除Entry文件，目前为两个</span><br><span class="line">   for (i in 0 until valueCount) &#123;</span><br><span class="line">     fileSystem.delete(entry.cleanFiles[i])</span><br><span class="line">     size -&#x3D; entry.lengths[i]</span><br><span class="line">     entry.lengths[i] &#x3D; 0</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   redundantOpCount++</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 日志记录</span><br><span class="line">   journalWriter!!.writeUtf8(REMOVE)</span><br><span class="line">       .writeByte(&#39; &#39;.toInt())</span><br><span class="line">       .writeUtf8(entry.key)</span><br><span class="line">       .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">   lruEntries.remove(entry.key)</span><br><span class="line"></span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 获取时清理</span><br><span class="line"> operator fun get(key: String): Snapshot? &#123;</span><br><span class="line">   ...</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     &#x2F;&#x2F; 执行清理</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return snapshot</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 删除时清理 </span><br><span class="line">internal fun removeEntry(entry: Entry): Boolean &#123;</span><br><span class="line">   ....</span><br><span class="line">   if (journalRebuildRequired()) &#123;</span><br><span class="line">     cleanupQueue.schedule(cleanupTask)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return true</span><br><span class="line"> &#125;  </span><br><span class="line"> </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<h5 id="产生-Edit"><a href="#产生-Edit" class="headerlink" title="产生 Edit"></a>产生 Edit</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">@Synchronized @Throws(IOException::class)</span><br><span class="line">@JvmOverloads</span><br><span class="line">fun edit(key: String, expectedSequenceNumber: Long &#x3D; ANY_SEQUENCE_NUMBER): Editor? &#123;</span><br><span class="line">  initialize()</span><br><span class="line"></span><br><span class="line">  checkNotClosed()</span><br><span class="line">  &#x2F;&#x2F; 正则命名验证</span><br><span class="line">  validateKey(key)</span><br><span class="line">  var entry: Entry? &#x3D; lruEntries[key]</span><br><span class="line">  &#x2F;&#x2F; 如果指定了序列话数值 expectedSequenceeNumber , 那么就是为了找到之前存入Entry的内容，找不到返回null</span><br><span class="line">  if (expectedSequenceNumber !&#x3D; ANY_SEQUENCE_NUMBER &amp;&amp;</span><br><span class="line">      (entry &#x3D;&#x3D; null || entry.sequenceNumber !&#x3D; expectedSequenceNumber)) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Snapshot is stale.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 正在编辑中的Entry 不被允许重复编辑</span><br><span class="line">  if (entry?.currentEditor !&#x3D; null) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Another edit is in progress.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 保险丝机制，mostRecentTrimFailed 标记对最近移除溢出数据时发生失败的情况，mostRecentRebuildFailed 日志写入失败的情况</span><br><span class="line">  &#x2F;&#x2F; 如果发生该情况，表示当前该工具存储状态异常，因此执行重新清理的任务，拒绝进行编辑</span><br><span class="line">  if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</span><br><span class="line">    cleanupQueue.schedule(cleanupTask)</span><br><span class="line">    return null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Flush the journal before creating files to prevent file leaks.</span><br><span class="line">  val journalWriter &#x3D; this.journalWriter!!</span><br><span class="line">  journalWriter.writeUtf8(DIRTY)</span><br><span class="line">      .writeByte(&#39; &#39;.toInt())</span><br><span class="line">      .writeUtf8(key)</span><br><span class="line">      .writeByte(&#39;\n&#39;.toInt())</span><br><span class="line">  journalWriter.flush()</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 日志写入发生异常，不允许进行编辑</span><br><span class="line">  if (hasJournalErrors) &#123;</span><br><span class="line">    return null &#x2F;&#x2F; Don&#39;t edit; the journal can&#39;t be written.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (entry &#x3D;&#x3D; null) &#123;</span><br><span class="line">    entry &#x3D; Entry(key)</span><br><span class="line">    lruEntries[key] &#x3D; entry</span><br><span class="line">  &#125;</span><br><span class="line">  val editor &#x3D; Editor(entry)</span><br><span class="line">  entry.currentEditor &#x3D; editor</span><br><span class="line">  return editor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="初始化与备份"><a href="#初始化与备份" class="headerlink" title="初始化与备份"></a>初始化与备份</h5><p>初始化包括几个流程：</p>
<ul>
<li>校验文件系统情况，如果丢失则用备份进行还原</li>
<li>正常初始化，读取目录下所有缓存文件信息</li>
<li>如果初始化失败，则移除整个缓存文件夹，并重新建立整个缓存文件夹。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">fun initialize() &#123;</span><br><span class="line">    this.assertThreadHoldsLock()</span><br><span class="line"></span><br><span class="line">    if (initialized) &#123;</span><br><span class="line">      return &#x2F;&#x2F; Already initialized.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 验证文件是否正常，如果丢失日志则进行备份还原</span><br><span class="line">    if (fileSystem.exists(journalFileBackup)) &#123;</span><br><span class="line">      if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果正常则删除备份文件，否则使用备份文件</span><br><span class="line">        fileSystem.delete(journalFileBackup)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        fileSystem.rename(journalFileBackup, journalFile)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Prefer to pick up where we left off.</span><br><span class="line">    if (fileSystem.exists(journalFile)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        readJournal()</span><br><span class="line">        processJournal()</span><br><span class="line">        initialized &#x3D; true</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 到此初始化完成</span><br><span class="line">        return</span><br><span class="line">      &#125; catch (journalIsCorrupt: IOException) &#123;</span><br><span class="line">        Platform.get().log(</span><br><span class="line">            &quot;DiskLruCache $directory is corrupt: $&#123;journalIsCorrupt.message&#125;, removing&quot;,</span><br><span class="line">            WARN,</span><br><span class="line">            journalIsCorrupt)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 如果初始化失败则删除整个缓存文件夹，重建整个缓存，维持正常的执行（保险丝机制）</span><br><span class="line">      try &#123;</span><br><span class="line">        delete()</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        closed &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rebuildJournal()</span><br><span class="line"></span><br><span class="line">    initialized &#x3D; true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p><code>ConnectInterceptor</code> 主要负责在执行内容传输前的连接建立流程，比如TCP、TLS等连接的建立，以及授权、验证等。并且在产生连接通道后（RealConnection）将对连接进行缓存（RealConnectionPool），以便于在后面中进行连接复用。在该连接中不涉及数据交互。</p>
<p>OkHttp对连接做了比较多的优化，在结构上比较复杂，需要先对数据结构熟悉：</p>
<ul>
<li>ConnectionSpec <code>描述在HTTP进行连接通道时所需要的配置内容，目前仅涉及HTTPS在TLS版本、加密套件</code></li>
<li>ConnectionSpecSelector <code>根据提供的ConnectionSpec列表，对SSLSocket进行配置</code></li>
<li>Route <code>用来描述网络数据包的传输路径，主要描述出和TCP建立的目标点，包括代理的描述。路由信息通过RouteSelector产生，在一个host下可能存在多个链接点，因此可能产生多个Route信息。</code></li>
<li>RouteDatabase <code>记录失败的Route信息，避免下次使用无效Route，配合RouteSelector使用</code></li>
<li>RouteSelector <code>根据Proxie代理信息和Address进行合适的Route选择，在RouteSelector 中会将URL、Port信息转化为Proxy，并通过DNS进行查询，将多个连接点封装为所有Route</code></li>
<li>Protocol <code>连接所使用的协议信息</code></li>
<li>Address <code>用于存储所有连接前置信息，包含连接所需要的主机名host、端口号port，Dns、代理服务器Proxy、对于包含Https要求，则提供 SSLSocketFactory、HostnameVerifier、CertificatePinner、Authenticator等授权信息，</code></li>
<li>RealConnection <code>代表着socket链路，每一个RealConnection代表一条跟服务器的通信链路，在该类中完成主要的连接流程（TCP握手、TLS连接验证、协议连接）</code></li>
</ul>
<h3 id="RouteSelector、Route-与-Proxy"><a href="#RouteSelector、Route-与-Proxy" class="headerlink" title="RouteSelector、Route 与 Proxy"></a>RouteSelector、Route 与 Proxy</h3><p>在OkHttp 中，同一个域名host下可能存在多个连接点(或者多个代理连接点)，对于这些连接点，OkHttp 抽象成 Route 信息以方便进行连接。</p>
<h4 id="预处理Proxy"><a href="#预处理Proxy" class="headerlink" title="预处理Proxy"></a>预处理Proxy</h4><p>RouteSelector 初始化中，对Proxy进行预处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">init &#123;</span><br><span class="line">   &#x2F;&#x2F; 初始化 proxy 信息</span><br><span class="line">   resetNextProxy(address.url, address.proxy)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 如果在OkHttpClient.Builder.proxy 定义了则使用该定义内容，否则判断是否设置了 proxySelector(目前只有单元测试用到）</span><br><span class="line"> &#x2F;&#x2F; 如果 ProxySelector.select 返回为null 则返回 默认 Proxy.NO_PROXY 兜底 proxy 。</span><br><span class="line"> private fun resetNextProxy(url: HttpUrl, proxy: Proxy?) &#123;</span><br><span class="line">   eventListener.proxySelectStart(call, url)</span><br><span class="line">   proxies &#x3D; if (proxy !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 OkHttpClient.Builder.proxy 主动设置了代理信息，那么只记录该代理</span><br><span class="line">     listOf(proxy)</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果在OkHttpClient 中设置了 proxy 则proxySelector 为 NullProxySelector，否则这里</span><br><span class="line">     &#x2F;&#x2F; proxySelector 返回的是系统（平台）的ProxySelector 否则还是为 NullProxySelector</span><br><span class="line">     &#x2F;&#x2F; NullProxySelector 默认 select 返回一个空集合，因此如果到空集合的话最红返回的是只有一个 NO_PROXY的集合</span><br><span class="line">     &#x2F;&#x2F; 作为兜底，NO_PROXY 默认 type &#x3D; Proxy.Type.DIRECT</span><br><span class="line">     val proxiesOrNull &#x3D; address.proxySelector.select(url.toUri())</span><br><span class="line">     if (proxiesOrNull !&#x3D; null &amp;&amp; proxiesOrNull.isNotEmpty()) &#123;</span><br><span class="line">       proxiesOrNull.toImmutableList()</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       immutableListOf(Proxy.NO_PROXY)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   nextProxyIndex &#x3D; 0</span><br><span class="line">   eventListener.proxySelectEnd(call, url, proxies)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="RouteSelector的使用"><a href="#RouteSelector的使用" class="headerlink" title="RouteSelector的使用"></a>RouteSelector的使用</h4><p>RouteSelector 关键方法为 <code>next</code>，执行该方法将产生一个 <code>Selection</code>对象，用于存储所产生的<code>Route</code>候选集合内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nextProxyIndex 用来标记当前所处理的代理集合的位置，在next和nextProxy中开始进行解析</span><br><span class="line">private fun hasNextProxy(): Boolean &#x3D; nextProxyIndex &lt; proxies.size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Throws(IOException::class)</span><br><span class="line">private fun nextProxy(): Proxy &#123;</span><br><span class="line">  &#x2F;&#x2F; proxy一定会有一个值，至少存在一个 NO_PROXY</span><br><span class="line">  if (!hasNextProxy()) &#123;</span><br><span class="line">    throw SocketException(</span><br><span class="line">        &quot;No route to $&#123;address.url.host&#125;; exhausted proxy configurations: $proxies&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">   val result &#x3D; proxies[nextProxyIndex++]</span><br><span class="line">   resetNextInetSocketAddress(result)</span><br><span class="line">   return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 根据Proxy和host dns解析所有可用的 InetSocketAddress 并存在 inetSocketAddresses 字段中</span><br><span class="line"> private fun resetNextInetSocketAddress(proxy: Proxy) &#123;</span><br><span class="line">    val mutableInetSocketAddresses &#x3D; mutableListOf&lt;InetSocketAddress&gt;()</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化RouteSelector.inetSocketAddresses 属性，将解析的结果存储在该列表中</span><br><span class="line">    inetSocketAddresses &#x3D; mutableInetSocketAddresses</span><br><span class="line"></span><br><span class="line">    val socketHost: String</span><br><span class="line">    val socketPort: Int</span><br><span class="line">    &#x2F;&#x2F; 如果代理类型为直连或者Socket类型，则可以直接用他们提供的host port ，否则通过InetSocketAddress获取真实地址</span><br><span class="line">    if (proxy.type() &#x3D;&#x3D; Proxy.Type.DIRECT || proxy.type() &#x3D;&#x3D; Proxy.Type.SOCKS) &#123;</span><br><span class="line">      socketHost &#x3D; address.url.host</span><br><span class="line">      socketPort &#x3D; address.url.port</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      val proxyAddress &#x3D; proxy.address()</span><br><span class="line">      require(proxyAddress is InetSocketAddress) &#123;</span><br><span class="line">        &quot;Proxy.address() is not an InetSocketAddress: $&#123;proxyAddress.javaClass&#125;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      socketHost &#x3D; proxyAddress.socketHost</span><br><span class="line">      socketPort &#x3D; proxyAddress.port</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检查端口设置是否超过范围</span><br><span class="line">    if (socketPort !in 1..65535) &#123;</span><br><span class="line">      throw SocketException(&quot;No route to $socketHost:$socketPort; port is out of range&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 proxy 为 SOCKTS 代理则不需要处理 host dns，否则预处理host 的dns解析结果</span><br><span class="line">    if (proxy.type() &#x3D;&#x3D; Proxy.Type.SOCKS) &#123;</span><br><span class="line">     &#x2F;&#x2F; SOCKS 代理不需要解析host ip, 根据主机名和端口号创建未解析的套接字地址</span><br><span class="line">      mutableInetSocketAddresses +&#x3D; InetSocketAddress.createUnresolved(socketHost, socketPort)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      eventListener.dnsStart(call, socketHost)</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 根据提供的host查询到支持的所有ip地址信息</span><br><span class="line">      val addresses &#x3D; address.dns.lookup(socketHost)</span><br><span class="line">      if (addresses.isEmpty()) &#123;</span><br><span class="line">        throw UnknownHostException(&quot;$&#123;address.dns&#125; returned no addresses for $socketHost&quot;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      eventListener.dnsEnd(call, socketHost, addresses)</span><br><span class="line">      &#x2F;&#x2F; 将所解析出来的所有地址封装套接字地址</span><br><span class="line">      for (inetAddress in addresses) &#123;</span><br><span class="line">        mutableInetSocketAddresses +&#x3D; InetSocketAddress(inetAddress, socketPort)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">operator fun next(): Selection &#123;</span><br><span class="line">    if (!hasNext()) throw NoSuchElementException()</span><br><span class="line"></span><br><span class="line">    val routes &#x3D; mutableListOf&lt;Route&gt;()</span><br><span class="line">    while (hasNextProxy()) &#123;</span><br><span class="line">      &#x2F;&#x2F; nextProxy() 读取一个Proxy信息，并对inetSocketAddresses 连接点进行预处理</span><br><span class="line">      val proxy &#x3D; nextProxy()</span><br><span class="line">      for (inetSocketAddress in inetSocketAddresses) &#123;</span><br><span class="line">      &#x2F;&#x2F;  将 inetSocketAddress 包装成 Route</span><br><span class="line">        val route &#x3D; Route(address, proxy, inetSocketAddress)</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 该Route是否在黑名单中，否则添加到候选routes中</span><br><span class="line">        if (routeDatabase.shouldPostpone(route)) &#123;</span><br><span class="line">          postponedRoutes +&#x3D; route</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          routes +&#x3D; route</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (routes.isNotEmpty()) &#123;</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果没有可用的 Route 就将之前不可用的 Route拿来尽可能尝试下</span><br><span class="line">    if (routes.isEmpty()) &#123;</span><br><span class="line">      routes +&#x3D; postponedRoutes</span><br><span class="line">      postponedRoutes.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return Selection(routes)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在next中主要处理：</p>
<ul>
<li>读取Proxy信息，如果非Socket代理则对host提前进行dns解析，得到ip</li>
<li>对Proxy和所解析出所有结果进行Route包装</li>
<li>将所获得的Route包装集合封装到Selection中，提供给使用方选择连接点</li>
</ul>
<h3 id="ConnectionSpec-与-ConnectionSpecSelector"><a href="#ConnectionSpec-与-ConnectionSpecSelector" class="headerlink" title="ConnectionSpec 与 ConnectionSpecSelector"></a>ConnectionSpec 与 ConnectionSpecSelector</h3><p>ConnectionSpec 主要是对连接时对Socket的配置，这里面包括TLS所需要进行的版本和密码套件协商信息，而ConnectionSpecSelector 则对最终选择的ConnectionSpec 进行筛选，目前仅对SSLSocket进行配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主要对Socket所支持的协议和加密配套进行交集判断</span><br><span class="line">  fun isCompatible(socket: SSLSocket): Boolean &#123;</span><br><span class="line">    if (!isTls) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tlsVersionsAsString !&#x3D; null &amp;&amp;</span><br><span class="line">        !tlsVersionsAsString.hasIntersection(socket.enabledProtocols, naturalOrder())) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (cipherSuitesAsString !&#x3D; null &amp;&amp;</span><br><span class="line">        !cipherSuitesAsString.hasIntersection(</span><br><span class="line">            socket.enabledCipherSuites, CipherSuite.ORDER_BY_NAME)) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fun configureSecureSocket(sslSocket: SSLSocket): ConnectionSpec &#123;</span><br><span class="line">    var tlsConfiguration: ConnectionSpec? &#x3D; null</span><br><span class="line">    for (i in nextModeIndex until connectionSpecs.size) &#123;</span><br><span class="line">      val connectionSpec &#x3D; connectionSpecs[i]</span><br><span class="line">      &#x2F;&#x2F; 判断该配置是否和当前连接兼容</span><br><span class="line">      if (connectionSpec.isCompatible(sslSocket)) &#123;</span><br><span class="line">        tlsConfiguration &#x3D; connectionSpec</span><br><span class="line">        nextModeIndex &#x3D; i + 1</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tlsConfiguration &#x3D;&#x3D; null) &#123;</span><br><span class="line">      throw UnknownServiceException(&quot;Unable to find acceptable protocols. isFallback&#x3D;$isFallback,&quot; +</span><br><span class="line">          &quot; modes&#x3D;$connectionSpecs,&quot; +</span><br><span class="line">          &quot; supported protocols&#x3D;$&#123;sslSocket.enabledProtocols!!.contentToString()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isFallbackPossible &#x3D; isFallbackPossible(sslSocket)</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 对SSLSocket进行配置应用</span><br><span class="line">    tlsConfiguration.apply(sslSocket, isFallback)</span><br><span class="line"></span><br><span class="line">    return tlsConfiguration</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>OkHttp 中配置了几个基本的默认配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;通用加密套件</span><br><span class="line">private val RESTRICTED_CIPHER_SUITES &#x3D; arrayOf(</span><br><span class="line">    &#x2F;&#x2F; TLSv1.3.</span><br><span class="line">    CipherSuite.TLS_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TLSv1.0, TLSv1.1, TLSv1.2.</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 所有支持的加密套件，包括后面可能不被支持的加密，用于兼容一些老平台</span><br><span class="line">private val APPROVED_CIPHER_SUITES &#x3D; arrayOf(</span><br><span class="line">    &#x2F;&#x2F; TLSv1.3.</span><br><span class="line">    CipherSuite.TLS_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; TLSv1.0, TLSv1.1, TLSv1.2.</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 以下加密套在Http2.0可能被废弃</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA,</span><br><span class="line">    CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA)</span><br><span class="line"></span><br><span class="line">&#x2F;** 目前主流的配置方案 *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val RESTRICTED_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*RESTRICTED_CIPHER_SUITES) &#x2F;&#x2F; 密码套件</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2) &#x2F;&#x2F; TLS 支持版本</span><br><span class="line">    .supportsTlsExtensions(true) &#x2F;&#x2F; TLS异常</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 适配大部分平台的配置方案(扩大加密套件的支持，以兼容一些平台)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val MODERN_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)</span><br><span class="line">    .supportsTlsExtensions(true)</span><br><span class="line">    .build()</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 向后大部分兼容的的配置方案，包含 TLS1.3、TLS1.2、TLS1.1、TLS1.0</span><br><span class="line"> *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val COMPATIBLE_TLS &#x3D; Builder(true)</span><br><span class="line">    .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">    .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)</span><br><span class="line">    .supportsTlsExtensions(true)</span><br><span class="line">    .build()</span><br><span class="line">    </span><br><span class="line">&#x2F;** 明文配置，用于Http，不进行TLS *&#x2F;</span><br><span class="line">@JvmField</span><br><span class="line">val CLEARTEXT &#x3D; Builder(false).build()</span><br></pre></td></tr></table></figure>

<p>通过<code>OkHttpClient.Builder.connectionSpecs</code>可以对候选配置内容进行配置，默认情况下使用 <code>DEFAULT_CONNECTION_SPECS</code> 组合</p>
<h4 id="ConnectionSpec-apply-配置"><a href="#ConnectionSpec-apply-配置" class="headerlink" title="ConnectionSpec.apply 配置"></a>ConnectionSpec.apply 配置</h4><p>apply 主要对最终连接的 SSLSocket 的加密配套和 TLS版本根据 SSLSocket支持的情况和 OkHttp 配置要求的情况进行交集配置。</p>
<p><code>如果需要对OkHttp TLS 版本或者加密配套相关调整，需要注意改动不仅仅是OkHttp的配置还需要对SSLSocket.setEnableCipherSuites 进行处理，这些内容都可以在 OkHttpClient.Build.sslSocketFactory 进行配置</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">internal fun apply(sslSocket: SSLSocket, isFallback: Boolean) &#123;</span><br><span class="line">  val specToApply &#x3D; supportedSpec(sslSocket, isFallback)</span><br><span class="line">  </span><br><span class="line">  if (specToApply.tlsVersions !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledProtocols &#x3D; specToApply.tlsVersionsAsString</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (specToApply.cipherSuites !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites &#x3D; specToApply.cipherSuitesAsString</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 主要对SSLSocket 一些支持信息（TLS版本、加密套）和 所配置的内容进行匹配，取交集得到最终要求的TLS版本和配件套</span><br><span class="line">private fun supportedSpec(sslSocket: SSLSocket, isFallback: Boolean): ConnectionSpec &#123;</span><br><span class="line">  &#x2F;&#x2F; 所配置的加密配件和SSLSocket.enabledCipherSuites所支持的配件套交集</span><br><span class="line">  var cipherSuitesIntersection &#x3D; if (cipherSuitesAsString !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites.intersect(cipherSuitesAsString, CipherSuite.ORDER_BY_NAME)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sslSocket.enabledCipherSuites</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 所配置的TLS版本和SSLSocket.enabledProtocols所支持交集结果</span><br><span class="line">  val tlsVersionsIntersection &#x3D; if (tlsVersionsAsString !&#x3D; null) &#123;</span><br><span class="line">    sslSocket.enabledProtocols.intersect(tlsVersionsAsString, naturalOrder())</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    sslSocket.enabledProtocols</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; TLS_FALLBACK_SCSV 支持</span><br><span class="line">  val supportedCipherSuites &#x3D; sslSocket.supportedCipherSuites</span><br><span class="line">  val indexOfFallbackScsv &#x3D; supportedCipherSuites.indexOf(</span><br><span class="line">      &quot;TLS_FALLBACK_SCSV&quot;, CipherSuite.ORDER_BY_NAME)</span><br><span class="line">  if (isFallback &amp;&amp; indexOfFallbackScsv !&#x3D; -1) &#123;</span><br><span class="line">    cipherSuitesIntersection &#x3D; cipherSuitesIntersection.concat(</span><br><span class="line">        supportedCipherSuites[indexOfFallbackScsv])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Builder(this)</span><br><span class="line">      .cipherSuites(*cipherSuitesIntersection)</span><br><span class="line">      .tlsVersions(*tlsVersionsIntersection)</span><br><span class="line">      .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="RealConnection中的连接"><a href="#RealConnection中的连接" class="headerlink" title="RealConnection中的连接"></a>RealConnection中的连接</h3><p>真正通道连接发生在 RealConnect.connet 。</p>
<p>connet 主要分为几个流程：</p>
<ul>
<li>获取Socket配置（ConnectionSpec、ConnectionSpecSelector）</li>
<li>校验如果没有配置SSLSocketFactory，是否支持明文配置（ConnectionSpec.CLEARTEXT），平台是否支持明文传输</li>
<li>根据Route连接要求，是否只是建立 TCP连接或者隧道连接，在建立连接后进行协议连接（TLS连接、HTTP2.0连接）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">fun connect(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   pingIntervalMillis: Int,</span><br><span class="line">   connectionRetryEnabled: Boolean,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   &#x2F;&#x2F; 要求 protocol 必须为null , 没有连接过</span><br><span class="line">   check(protocol &#x3D;&#x3D; null) &#123; &quot;already connected&quot; &#125;</span><br><span class="line"></span><br><span class="line">   var routeException: RouteException? &#x3D; null</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 获取连接配套配置</span><br><span class="line">   val connectionSpecs &#x3D; route.address.connectionSpecs</span><br><span class="line">   &#x2F;&#x2F; 获得配置选择器</span><br><span class="line">   val connectionSpecSelector &#x3D; ConnectionSpecSelector(connectionSpecs)</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果 OkHttpClient.Builder 没有配置 SSLSocketFactory 则表示协议使用明文传输（不适用HTTPS)</span><br><span class="line">   if (route.address.sslSocketFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 检查明文配置是否在配置列表中</span><br><span class="line">     if (ConnectionSpec.CLEARTEXT !in connectionSpecs) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;CLEARTEXT communication not enabled for client&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">     &#x2F;&#x2F; 检查平台是否支持该域名的明文传输（9.0 默认不支持Http明文传输）</span><br><span class="line">     val host &#x3D; route.address.url.host</span><br><span class="line">     if (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;CLEARTEXT communication to $host not permitted by network security policy&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; 如果设置了SSL 则不允许 H2_PRIOR_KNOWLEDGE 协议（需要明文传输）</span><br><span class="line">     if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) &#123;</span><br><span class="line">       throw RouteException(UnknownServiceException(</span><br><span class="line">           &quot;H2_PRIOR_KNOWLEDGE cannot be used with HTTPS&quot;))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   while (true) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       &#x2F;&#x2F; 是否要求隧道连接</span><br><span class="line">       if (route.requiresTunnel()) &#123;</span><br><span class="line">         connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)</span><br><span class="line">         if (rawSocket &#x3D;&#x3D; null) &#123;</span><br><span class="line">           &#x2F;&#x2F; We were unable to connect the tunnel but properly closed down our resources.</span><br><span class="line">           break</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         &#x2F;&#x2F; 建立Socket连接</span><br><span class="line">         connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 确定协议和TLS连接，如果为HTTP2.0 则直接建立连接</span><br><span class="line">       establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)</span><br><span class="line">       eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)</span><br><span class="line">       break</span><br><span class="line">     &#125; catch (e: IOException) &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立TCP Socket连接</span><br><span class="line"> private fun connectSocket(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   val proxy &#x3D; route.proxy</span><br><span class="line">   val address &#x3D; route.address</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 如果是直连或者HTTP代理，都需要建立Socket，否则直接创建proxy的Socket代理</span><br><span class="line">   val rawSocket &#x3D; when (proxy.type()) &#123;</span><br><span class="line">     Proxy.Type.DIRECT, Proxy.Type.HTTP -&gt; address.socketFactory.createSocket()!!</span><br><span class="line">     else -&gt; Socket(proxy)</span><br><span class="line">   &#125;</span><br><span class="line">   this.rawSocket &#x3D; rawSocket</span><br><span class="line"></span><br><span class="line">   eventListener.connectStart(call, route.socketAddress, proxy)</span><br><span class="line">   rawSocket.soTimeout &#x3D; readTimeout</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 调用平台创建连接Socket的方法</span><br><span class="line">     Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)</span><br><span class="line">   &#125; catch (e: ConnectException) &#123;</span><br><span class="line">     throw ConnectException(&quot;Failed to connect to $&#123;route.socketAddress&#125;&quot;).apply &#123;</span><br><span class="line">       initCause(e)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 建立TCP连接后的流控制</span><br><span class="line">     source &#x3D; rawSocket.source().buffer()</span><br><span class="line">     sink &#x3D; rawSocket.sink().buffer()</span><br><span class="line">   &#125; catch (npe: NullPointerException) &#123;</span><br><span class="line">     if (npe.message &#x3D;&#x3D; NPE_THROW_WITH_NULL) &#123;</span><br><span class="line">       throw IOException(npe)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立TLS连接</span><br><span class="line"> private fun connectTls(connectionSpecSelector: ConnectionSpecSelector) &#123;</span><br><span class="line">   val address &#x3D; route.address</span><br><span class="line">   val sslSocketFactory &#x3D; address.sslSocketFactory</span><br><span class="line">   var success &#x3D; false</span><br><span class="line">   var sslSocket: SSLSocket? &#x3D; null</span><br><span class="line">   try &#123;</span><br><span class="line">     &#x2F;&#x2F; 调用 OkHttpClient.Build.sslSocketFactory 构造 SSLSocket</span><br><span class="line">     &#x2F;&#x2F; Create the wrapper over the connected socket.</span><br><span class="line">     sslSocket &#x3D; sslSocketFactory!!.createSocket(</span><br><span class="line">         rawSocket, address.url.host, address.url.port, true &#x2F;* autoClose *&#x2F;) as SSLSocket</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 定义TLS版本和加密配套及其扩展</span><br><span class="line">     val connectionSpec &#x3D; connectionSpecSelector.configureSecureSocket(sslSocket)</span><br><span class="line">     &#x2F;&#x2F; 如果支持TLS扩展，调用平台扩展</span><br><span class="line">     if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">       Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 进行握手</span><br><span class="line">     &#x2F;&#x2F; Force handshake. This can throw!</span><br><span class="line">     sslSocket.startHandshake()</span><br><span class="line">     &#x2F;&#x2F; block for session establishment</span><br><span class="line">     val sslSocketSession &#x3D; sslSocket.session</span><br><span class="line">     val unverifiedHandshake &#x3D; sslSocketSession.handshake()</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 证书验证（OkHostnameVerifier），验证地址和目标地址ip，如果不通过则抛出</span><br><span class="line">     if (!address.hostnameVerifier!!.verify(address.url.host, sslSocketSession)) &#123;</span><br><span class="line">       &#x2F;&#x2F; 验证不通过则抛出异常</span><br><span class="line">       val peerCertificates &#x3D; unverifiedHandshake.peerCertificates</span><br><span class="line">       if (peerCertificates.isNotEmpty()) &#123;</span><br><span class="line">         val cert &#x3D; peerCertificates[0] as X509Certificate</span><br><span class="line">         throw SSLPeerUnverifiedException(&quot;&quot;&quot;</span><br><span class="line">             |Hostname $&#123;address.url.host&#125; not verified:</span><br><span class="line">             |    certificate: $&#123;CertificatePinner.pin(cert)&#125;</span><br><span class="line">             |    DN: $&#123;cert.subjectDN.name&#125;</span><br><span class="line">             |    subjectAltNames: $&#123;OkHostnameVerifier.allSubjectAltNames(cert)&#125;</span><br><span class="line">             &quot;&quot;&quot;.trimMargin())</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         throw SSLPeerUnverifiedException(</span><br><span class="line">             &quot;Hostname $&#123;address.url.host&#125; not verified (no certificates)&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 证书锁定器，用来抵抗CA攻击、中间人攻击</span><br><span class="line">     val certificatePinner &#x3D; address.certificatePinner!!</span><br><span class="line"></span><br><span class="line">     handshake &#x3D; Handshake(unverifiedHandshake.tlsVersion, unverifiedHandshake.cipherSuite,</span><br><span class="line">         unverifiedHandshake.localCertificates) &#123;</span><br><span class="line">       &#x2F;&#x2F; certificateChainCleaner 用来验证证书链，并且排除一些和TLS握手无关的证书，返回可用的CA证书链</span><br><span class="line">       certificatePinner.certificateChainCleaner!!.clean(unverifiedHandshake.peerCertificates,</span><br><span class="line">           address.url.host)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; 验证该host的证书支持的 hash 类型</span><br><span class="line">     certificatePinner.check(address.url.host) &#123;</span><br><span class="line">       handshake!!.peerCertificates.map &#123; it as X509Certificate &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; ALPN 扩展协议处理</span><br><span class="line">     val maybeProtocol &#x3D; if (connectionSpec.supportsTlsExtensions) &#123;</span><br><span class="line">       Platform.get().getSelectedProtocol(sslSocket)</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       null</span><br><span class="line">     &#125;</span><br><span class="line">     socket &#x3D; sslSocket</span><br><span class="line">     source &#x3D; sslSocket.source().buffer()</span><br><span class="line">     sink &#x3D; sslSocket.sink().buffer()</span><br><span class="line">     protocol &#x3D; if (maybeProtocol !&#x3D; null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1</span><br><span class="line">     success &#x3D; true</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">     &#x2F;&#x2F; 握手后操作</span><br><span class="line">     if (sslSocket !&#x3D; null) &#123;</span><br><span class="line">       Platform.get().afterHandshake(sslSocket)</span><br><span class="line">     &#125;</span><br><span class="line">     if (!success) &#123;</span><br><span class="line">       sslSocket?.closeQuietly()</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F; 建立隧道连接</span><br><span class="line"> private fun connectTunnel(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   call: Call,</span><br><span class="line">   eventListener: EventListener</span><br><span class="line"> ) &#123;</span><br><span class="line">   &#x2F;&#x2F; 封装请求头</span><br><span class="line">   var tunnelRequest: Request &#x3D; createTunnelRequest()</span><br><span class="line">   val url &#x3D; tunnelRequest.url</span><br><span class="line">   &#x2F;&#x2F; 做多尝试21次建立</span><br><span class="line">   for (i in 0 until MAX_TUNNEL_ATTEMPTS) &#123;</span><br><span class="line">     &#x2F;&#x2F; 先建立TCP连接</span><br><span class="line">     connectSocket(connectTimeout, readTimeout, call, eventListener)</span><br><span class="line">     </span><br><span class="line">     &#x2F;&#x2F; 创建隧道连接</span><br><span class="line">     tunnelRequest &#x3D; createTunnel(readTimeout, writeTimeout, tunnelRequest, url)</span><br><span class="line">         ?: break </span><br><span class="line"></span><br><span class="line">     rawSocket?.closeQuietly()</span><br><span class="line">     rawSocket &#x3D; null</span><br><span class="line">     sink &#x3D; null</span><br><span class="line">     source &#x3D; null</span><br><span class="line">     eventListener.connectEnd(call, route.socketAddress, route.proxy, null)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="回归findConnection"><a href="#回归findConnection" class="headerlink" title="回归findConnection"></a>回归findConnection</h3><p>回归到 <code>ConnectInterceptor.intercept</code> 方法，在该方法中，主要对调用 <code>RealCall.newExchange</code> 获取 <code>Exchange</code> 代理对象，通过 <code>Exchange</code> 可以建立的连接上进行数据交互。</p>
<p>在 <code>newExchange</code> 中主要经历几个流程：</p>
<p><code>RealCall.newExchange（返回 Exchange） -&gt; ExchangeFinder.find (返回 ExchangeCodec) -&gt; ExchangeFinder.findHealthyConnection （返回 RealConnection ）-&gt; ExchangeFinder.findConnection （返回 RealConnection）</code></p>
<p>在 findConnection 中获得主要负责连接的代理对象 <code>RealConnection</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">private fun findConnection(</span><br><span class="line">  connectTimeout: Int,</span><br><span class="line">  readTimeout: Int,</span><br><span class="line">  writeTimeout: Int,</span><br><span class="line">  pingIntervalMillis: Int,</span><br><span class="line">  connectionRetryEnabled: Boolean</span><br><span class="line">): RealConnection &#123;</span><br><span class="line">  var foundPooledConnection &#x3D; false</span><br><span class="line">  var result: RealConnection? &#x3D; null</span><br><span class="line">  var selectedRoute: Route? &#x3D; null</span><br><span class="line">  var releasedConnection: RealConnection?</span><br><span class="line">  val toClose: Socket?</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用被取消则直接退出</span><br><span class="line">    if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)</span><br><span class="line">    hasStreamFailure &#x3D; false &#x2F;&#x2F; This is a fresh attempt.</span><br><span class="line"></span><br><span class="line">    releasedConnection &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果call.connection的连接不允许创建新的传输（noNewExcahnges)，则返回当前连接的Socket，以用于释放连接</span><br><span class="line">    toClose &#x3D; if (call.connection !&#x3D; null &amp;&amp; call.connection!!.noNewExchanges) &#123;</span><br><span class="line">      call.releaseConnectionNoEvents()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果call 以及存在 connection 则复用结果</span><br><span class="line">    if (call.connection !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 使用以及存在连接代替</span><br><span class="line">      &#x2F;&#x2F; We had an already-allocated connection and it&#39;s good.</span><br><span class="line">      result &#x3D; call.connection</span><br><span class="line">      releasedConnection &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果为null ，代表当前call 不存在使用中的连接，从之前的连接池中查询</span><br><span class="line">    if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断连接池中是否存在符合条件的连接（已经被回收）</span><br><span class="line">      if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; call.connection</span><br><span class="line">      &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果未找到合适复用连接 则查看是否有需要优先选择的路由路线</span><br><span class="line">        selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">        nextRouteToTry &#x3D; null</span><br><span class="line">      &#125; else if (retryCurrentRoute()) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果没有，则直接重新计算路由</span><br><span class="line">        selectedRoute &#x3D; call.connection!!.route()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">  if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">    eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">  &#125;</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 在之前中已经找到已经可使用的连接</span><br><span class="line">  if (result !&#x3D; null) &#123;</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var newRouteSelection &#x3D; false</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果还没有Route选定并且 RouteSelection 还未初始化，则进行初始化，以备下面使用</span><br><span class="line">  if (selectedRoute &#x3D;&#x3D; null &amp;&amp; (routeSelection &#x3D;&#x3D; null || !routeSelection!!.hasNext())) &#123;</span><br><span class="line">    newRouteSelection &#x3D; true</span><br><span class="line">    routeSelection &#x3D; routeSelector.next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var routes: List&lt;Route&gt;? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查调用是否被取消</span><br><span class="line">    if (call.isCanceled()) throw IOException(&quot;Canceled&quot;)</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果新建 RouteSelection 则进行重新Route的获取</span><br><span class="line">    if (newRouteSelection) &#123;</span><br><span class="line">      routes &#x3D; routeSelection!!.routes</span><br><span class="line">      &#x2F;&#x2F; 获取连接池中适合call所使用的连接，如果返回true在表示已有合适的连接和call绑定（call.acquireConnectionNoEvents）</span><br><span class="line">      if (connectionPool.callAcquirePooledConnection(address, call, routes, false)) &#123;</span><br><span class="line">        foundPooledConnection &#x3D; true</span><br><span class="line">        result &#x3D; call.connection &#x2F;&#x2F; 获取当前所获得的复用的连接</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没在连接池中获得复用连接，则从路由节点中获得新的路由点（尝试在接下来中进行连接）</span><br><span class="line">    if (!foundPooledConnection) &#123;</span><br><span class="line">      if (selectedRoute &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果之前还没对Route路线进行选择，则进行路由选择</span><br><span class="line">        selectedRoute &#x3D; routeSelection!!.next()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 创建连接</span><br><span class="line">      result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">      connectingConnection &#x3D; result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果在连接池中找到则返回结果</span><br><span class="line">  if (foundPooledConnection) &#123;</span><br><span class="line">    eventListener.connectionAcquired(call, result!!)</span><br><span class="line">    return result!!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 开执TCP TLS 连接</span><br><span class="line">  result!!.connect(</span><br><span class="line">      connectTimeout,</span><br><span class="line">      readTimeout,</span><br><span class="line">      writeTimeout,</span><br><span class="line">      pingIntervalMillis,</span><br><span class="line">      connectionRetryEnabled,</span><br><span class="line">      call,</span><br><span class="line">      eventListener</span><br><span class="line">  )</span><br><span class="line">  &#x2F;&#x2F; 连接成功后，如果routeDatabase列表中（失败节点）存在该Route则从黑名单中移除</span><br><span class="line">  call.client.routeDatabase.connected(result!!.route())</span><br><span class="line"></span><br><span class="line">  var socket: Socket? &#x3D; null</span><br><span class="line">  synchronized(connectionPool) &#123;</span><br><span class="line">    connectingConnection &#x3D; null</span><br><span class="line">    if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123;</span><br><span class="line">      result!!.noNewExchanges &#x3D; true</span><br><span class="line">      socket &#x3D; result!!.socket()</span><br><span class="line">      result &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">      nextRouteToTry &#x3D; selectedRoute</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      connectionPool.put(result!!)</span><br><span class="line">      call.acquireConnectionNoEvents(result!!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">  eventListener.connectionAcquired(call, result!!)</span><br><span class="line">  return result!!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在流程中 findConnection 是比较重要的一个流程。这里实现了OkHttp 连接复用流程。对于连接成功后的连接 通过 <code>RealConnectionPool.put</code> 进行缓存。</p>
<h4 id="ConnectionPool-连接复用"><a href="#ConnectionPool-连接复用" class="headerlink" title="ConnectionPool 连接复用"></a>ConnectionPool 连接复用</h4><p>ConnectionPool 在整个连接过程中，记录着连接的变化</p>
<h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p><code>CallServerInterceptor</code> 负责在数据传输上的处理，包括在HTTP上传递头部和Body信息（应用层数据传输）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"> override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">    val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">    val exchange &#x3D; realChain.exchange()</span><br><span class="line">    val request &#x3D; realChain.request()</span><br><span class="line">    val requestBody &#x3D; request.body</span><br><span class="line">    val sentRequestMillis &#x3D; System.currentTimeMillis()</span><br><span class="line">    &#x2F;&#x2F; 向 Exchange 写入头部信息</span><br><span class="line">    exchange.writeRequestHeaders(request)</span><br><span class="line"></span><br><span class="line">    var invokeStartEvent &#x3D; true</span><br><span class="line">    var responseBuilder: Response.Builder? &#x3D; null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组装RequestBody，如果该次事务不需要则 exchange.noRequestBody()</span><br><span class="line">    if (HttpMethod.permitsRequestBody(request.method) &amp;&amp; requestBody !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理 100-continue 状况，表示需要多次传输</span><br><span class="line">      if (&quot;100-continue&quot;.equals(request.header(&quot;Expect&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行请求</span><br><span class="line">        exchange.flushRequest()</span><br><span class="line">        responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; true)</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">      if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否支持二进制body（HTTP2.0）</span><br><span class="line">        if (requestBody.isDuplex()) &#123;</span><br><span class="line">          &#x2F;&#x2F; 创建二进制RequestBody</span><br><span class="line">          exchange.flushRequest()</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, true).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 直接发送body内容</span><br><span class="line">          val bufferedRequestBody &#x3D; exchange.createRequestBody(request, false).buffer()</span><br><span class="line">          requestBody.writeTo(bufferedRequestBody)</span><br><span class="line">          bufferedRequestBody.close()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        exchange.noRequestBody()</span><br><span class="line">        &#x2F;&#x2F; 不支持多路，关闭事务</span><br><span class="line">        if (!exchange.connection()!!.isMultiplexed) &#123;</span><br><span class="line">          exchange.noNewExchangesOnConnection()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 执行不带body的请求</span><br><span class="line">      exchange.noRequestBody()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 到这里如果不支持二进制body HTTP2.0 则完成该次请求</span><br><span class="line">    if (requestBody &#x3D;&#x3D; null || !requestBody.isDuplex()) &#123;</span><br><span class="line">      exchange.finishRequest()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取请求结果</span><br><span class="line">    if (responseBuilder &#x3D;&#x3D; null) &#123;</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">        invokeStartEvent &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var response &#x3D; responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection()!!.handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">    var code &#x3D; response.code</span><br><span class="line">    if (code &#x3D;&#x3D; 100) &#123;</span><br><span class="line">      &#x2F;&#x2F; Server sent a 100-continue even though we did not request one. Try again to read the actual</span><br><span class="line">      &#x2F;&#x2F; response status.</span><br><span class="line">      responseBuilder &#x3D; exchange.readResponseHeaders(expectContinue &#x3D; false)!!</span><br><span class="line">      if (invokeStartEvent) &#123;</span><br><span class="line">        exchange.responseHeadersStart()</span><br><span class="line">      &#125;</span><br><span class="line">      response &#x3D; responseBuilder</span><br><span class="line">          .request(request)</span><br><span class="line">          .handshake(exchange.connection()!!.handshake())</span><br><span class="line">          .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">          .build()</span><br><span class="line">      code &#x3D; response.code</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exchange.responseHeadersEnd(response)</span><br><span class="line"></span><br><span class="line">    response &#x3D; if (forWebSocket &amp;&amp; code &#x3D;&#x3D; 101) &#123;</span><br><span class="line">      &#x2F;&#x2F; Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(EMPTY_RESPONSE)</span><br><span class="line">          .build()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      response.newBuilder()</span><br><span class="line">          .body(exchange.openResponseBody(response))</span><br><span class="line">          .build()</span><br><span class="line">    &#125;</span><br><span class="line">    if (&quot;close&quot;.equals(response.request.header(&quot;Connection&quot;), ignoreCase &#x3D; true) ||</span><br><span class="line">        &quot;close&quot;.equals(response.header(&quot;Connection&quot;), ignoreCase &#x3D; true)) &#123;</span><br><span class="line">      exchange.noNewExchangesOnConnection()</span><br><span class="line">    &#125;</span><br><span class="line">    if ((code &#x3D;&#x3D; 204 || code &#x3D;&#x3D; 205) &amp;&amp; response.body?.contentLength() ?: -1L &gt; 0L) &#123;</span><br><span class="line">      throw ProtocolException(</span><br><span class="line">          &quot;HTTP $code had non-zero Content-Length: $&#123;response.body?.contentLength()&#125;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a><a class="post-meta__tags" href="/tags/OkHttp/">OkHttp</a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/05/14/AndroidQ%E9%80%82%E9%85%8D/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Android Q适配</div></div></a></div><div class="next-post pull_right"><a href="/2019/02/21/Jetpack-ViewModel/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Jetpack-ViewModel</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/01/13/Android源码编译和阅读/" title="Android源码编译和阅读"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-01-13</div><div class="relatedPosts_title">Android源码编译和阅读</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/15/Android未捕获异常处理/" title="Android 未捕获异常处理"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-15</div><div class="relatedPosts_title">Android 未捕获异常处理</div></div></a></div><div class="relatedPosts_item"><a href="/2019/02/14/Jetpack-Lifecycle/" title="Jetpack-Lifecycle"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-02-14</div><div class="relatedPosts_title">Jetpack-Lifecycle</div></div></a></div><div class="relatedPosts_item"><a href="/2018/03/03/Repo操作/" title="Repo操作"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-03-03</div><div class="relatedPosts_title">Repo操作</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/10/Handler学习小记/" title="Handler学习小记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-10</div><div class="relatedPosts_title">Handler学习小记</div></div></a></div><div class="relatedPosts_item"><a href="/2018/06/09/Transform的基本应用/" title="Transform的基本应用"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-06-09</div><div class="relatedPosts_title">Transform的基本应用</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2014 - 2020 By Bevis</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>