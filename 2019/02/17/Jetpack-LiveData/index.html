<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Jetpack-LiveData | Bevis技术小站</title><meta name="description" content="Jetpack-LiveData"><meta name="keywords" content="Android,Jetpack"><meta name="author" content="Bevis"><meta name="copyright" content="Bevis"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Jetpack-LiveData"><meta name="twitter:description" content="Jetpack-LiveData"><meta name="twitter:image" content="http://yoursite.com/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Jetpack-LiveData"><meta property="og:url" content="http://yoursite.com/2019/02/17/Jetpack-LiveData/"><meta property="og:site_name" content="Bevis技术小站"><meta property="og:description" content="Jetpack-LiveData"><meta property="og:image" content="http://yoursite.com/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/02/17/Jetpack-LiveData/"><link rel="prev" title="Jetpack-ViewModel" href="http://yoursite.com/2019/02/21/Jetpack-ViewModel/"><link rel="next" title="Jetpack-Lifecycle" href="http://yoursite.com/2019/02/14/Jetpack-Lifecycle/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Bevis技术小站" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、配置"><span class="toc-number">1.</span> <span class="toc-text">一、配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、基本使用"><span class="toc-number">2.</span> <span class="toc-text">二、基本使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、源码解析"><span class="toc-number">3.</span> <span class="toc-text">三、源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#添加观察者"><span class="toc-number">3.1.</span> <span class="toc-text">添加观察者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变化与通知"><span class="toc-number">3.2.</span> <span class="toc-text">变化与通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setValue-值更新与通知"><span class="toc-number">3.3.</span> <span class="toc-text">setValue 值更新与通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#postValue-值更新与通知"><span class="toc-number">3.4.</span> <span class="toc-text">postValue 值更新与通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#observeForever"><span class="toc-number">3.5.</span> <span class="toc-text">observeForever</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解除订阅关系"><span class="toc-number">4.</span> <span class="toc-text">解除订阅关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、MediatorLiveData"><span class="toc-number">5.</span> <span class="toc-text">四、MediatorLiveData</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Transformations"><span class="toc-number">5.1.</span> <span class="toc-text">Transformations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">5.1.1.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switchMap"><span class="toc-number">5.1.2.</span> <span class="toc-text">switchMap</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bevis技术小站</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Jetpack-LiveData</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2019-02-17 23:32:35"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-02-17</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>LiveData 算是对 Lifecycle 框架的应用，当LiveData 发生值变化时将对所订阅者进行更新，借助于Lifecycle生命周期的管理，自动对值更新、自动解绑进行了自动管理。</p>
<h1 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h1><p>基于AndroidX的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0&quot;</span><br></pre></td></tr></table></figure>

<h1 id="二、基本使用"><a href="#二、基本使用" class="headerlink" title="二、基本使用"></a>二、基本使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    private val presenter by lazy &#123;</span><br><span class="line">        MainPresenter()</span><br><span class="line">    &#125;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        inputEt.addTextChangedListener(object : TextWatcher &#123;</span><br><span class="line">            override fun afterTextChanged(s: Editable?) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) &#123;</span><br><span class="line">                presenter.data.value &#x3D; s.toString()</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        presenter.data.observe(this, Observer &#123; text -&gt;</span><br><span class="line">            Log.i(&quot;BevisLogger&quot;, &quot;text changed : $text&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        lifecycle.addObserver(presenter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MainPresenter: LifecycleObserver &#123;</span><br><span class="line">    val data &#x3D; MutableLiveData&lt;String&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上例子是对编辑框进行监控，当每次触填写字符变化时，都将相应Log输出。</p>
<p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27916/WEBRESOURCEa993828f8316bc75f186d313251dbf53"  alt="image.png"></p>
<p>每一个对编辑框编辑都触发，<code>MainPresenter.data</code> 都发起通知，Logger 输出：<br><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/27918/WEBRESOURCE05918e89e3bcd22c75bae701b93f00be"  alt="image.png"></p>
<p>例子中主要涉及步骤：</p>
<ul>
<li>创建<code>LiveData</code>对象，声明类型，例子中在 MainPresenter 声明了 <code>MutableLiveData&lt;String&gt;</code> data 对象，因为声明类型为 <code>String</code> ，在 <code>LiveData</code> 中可以通过 <code>set</code> <code>get</code>设置<code>String</code>值。</li>
<li>在需要观察的对象中，调用<code>data.observe</code> 方法，传入 <code>LifecycleOwner</code> 和 回调对象 <code>Observer&lt;T&gt;</code></li>
<li>当每次对<code>LiveData.setValue</code> 或 <code>LiveData.postValue</code> 时，则会进行通知，响应到 <code>Observer&lt;T&gt;</code> 回调中。</li>
</ul>
<h1 id="三、源码解析"><a href="#三、源码解析" class="headerlink" title="三、源码解析"></a>三、源码解析</h1><p>LiveData 为我们解决了数据适配Android生命周期的问题，防止发生内存泄露。<br>通过LiveData 可以将项目最小成本的改造为数据驱动。下面分析在LiveData的主要几个动作。</p>
<h2 id="添加观察者"><a href="#添加观察者" class="headerlink" title="添加观察者"></a>添加观察者</h2><p>对于 <code>MutableLiveData&lt;String&gt;</code> 只是个简单的包装类，实际的实现逻辑集中在 <code>LiveData</code> 抽象类中。</p>
<p>我们先从订阅方法<code>observe</code> 开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">      &#x2F;&#x2F; 必须在主线程中进行观察者添加</span><br><span class="line">      assertMainThread(&quot;observe&quot;);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 如果当前被观察者已经销毁，则忽略订阅</span><br><span class="line">      if (owner.getLifecycle().getCurrentState() &#x3D;&#x3D; DESTROYED) &#123;</span><br><span class="line">          &#x2F;&#x2F; ignore</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 包装观察者，后面对 LifecycleBoundObserver 进行解析，该对象负责:</span><br><span class="line">      &#x2F;&#x2F; 1. </span><br><span class="line">      LifecycleBoundObserver wrapper &#x3D; new LifecycleBoundObserver(owner, observer);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 缓存观察者，一个 observer 只能绑定一个被观察者LifecycleOwner</span><br><span class="line">      ObserverWrapper existing &#x3D; mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">      if (existing !&#x3D; null &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">          throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                  + &quot; with different lifecycles&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (existing !&#x3D; null) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 数据包装作为观察者，订阅生命周期变化</span><br><span class="line">      owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这流程主要为了<code>Observer</code>包装为<code>LifecycleBoundObserver</code>，该<code>LifecycleBOundObserver</code>即为<code>LifecycleEventObserver</code> Lifecycle 框架定义的观察者，包装完成后 通过传入的<code>LifecycleOwner</code>建立订阅关系。</p>
<p>了解了以上订阅流程，那么就比较清楚，这里面重要的是当生命周期发生状态变化时，<code>LifecycleBoundObserver</code>的响应处理。</p>
<h2 id="变化与通知"><a href="#变化与通知" class="headerlink" title="变化与通知"></a>变化与通知</h2><p><code>LifecycleBoundObserver</code> 的继承关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们首先看  <code>LifecycleEventObserver.onStateChanged</code> 的响应实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123;</span><br><span class="line">    ...</span><br><span class="line">    @Override</span><br><span class="line">    public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">            @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果被观察者已经 DESTROYED 则注销订阅关系并不做响应        </span><br><span class="line">        if (mOwner.getLifecycle().getCurrentState() &#x3D;&#x3D; DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 当状态发生以STARTED状态为分界点状态前后变化时触发  </span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 当前的被观察者对象的周期阶段必须在STARTED及其之后为true，否则false</span><br><span class="line">    @Override</span><br><span class="line">    boolean shouldBeActive() &#123;</span><br><span class="line">        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br><span class="line">   </span><br><span class="line">private abstract class ObserverWrapper &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 当状态发生以STARTED状态为分界点状态前后变化时触发  </span><br><span class="line">    void activeStateChanged(boolean newActive) &#123;</span><br><span class="line">        &#x2F;&#x2F; 比较和之前的激活状态，如果发生变化才允许执行通知</span><br><span class="line">        if (newActive &#x3D;&#x3D; mActive) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新激活状态值</span><br><span class="line">        mActive &#x3D; newActive;</span><br><span class="line">        &#x2F;&#x2F; 表示未发生激活</span><br><span class="line">        boolean wasInactive &#x3D; LiveData.this.mActiveCount &#x3D;&#x3D; 0;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 为激活状态进行计数，如果激活则 +1 如果失效 -1，如果被观察者正常周期结束，则会是 0 </span><br><span class="line">        LiveData.this.mActiveCount +&#x3D; mActive ? 1 : -1;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 之前为失效状态切换为当前激活状态(比如 CREATED -&gt; STARTED )，则调用 onActive</span><br><span class="line">        if (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">            onActive();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 之前为失效状态更新为失效状态()，则调用 onInactive</span><br><span class="line">        if (LiveData.this.mActiveCount &#x3D;&#x3D; 0 &amp;&amp; !mActive) &#123;</span><br><span class="line">            onInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 当前触发激活状态时，进行一次值变化通知</span><br><span class="line">        if (mActive) &#123;</span><br><span class="line">            dispatchingValue(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...    </span><br><span class="line">    </span><br><span class="line">   void dispatchingValue(@Nullable ObserverWrapper initiator) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果分发通知期间发现值发生变化，需要重新进行通知，那么标记当前分发的状</span><br><span class="line">        &#x2F;&#x2F; 态为 mDispatchInvalidated &#x3D; true </span><br><span class="line">        &#x2F;&#x2F; 非法状态，在下面循环中，如果发现该标记发生变化会重新进行通知</span><br><span class="line">        if (mDispatchingValue) &#123;</span><br><span class="line">            mDispatchInvalidated &#x3D; true;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 标记正在执行通知</span><br><span class="line">        mDispatchingValue &#x3D; true;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 循环检测 mDispatchInvalidated 标记位，防止该次通知过期，需要重新通知</span><br><span class="line">        do &#123;</span><br><span class="line">            &#x2F;&#x2F; 标记当前分发有效，如果在通知过程中，该值发生变化</span><br><span class="line">            &#x2F;&#x2F; 将重新进入该循环里面，重新进行通知</span><br><span class="line">            mDispatchInvalidated &#x3D; false;</span><br><span class="line">            &#x2F;&#x2F; 如果指定了观察者目标</span><br><span class="line">            if (initiator !&#x3D; null) &#123;</span><br><span class="line">                单独对当前指定的观察者进行通知更新</span><br><span class="line">                considerNotify(initiator);</span><br><span class="line">                initiator &#x3D; null;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 遍历通知所有订阅者</span><br><span class="line">                for (Iterator&lt;Map.Entry&lt;Observer&lt;? super T&gt;, ObserverWrapper&gt;&gt; iterator &#x3D;</span><br><span class="line">                        mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                    considerNotify(iterator.next().getValue());</span><br><span class="line">                    </span><br><span class="line">                    &#x2F;&#x2F; 如果遍历过程中发现该次通知已经失效（由于值重新更新，需要</span><br><span class="line">                    &#x2F;&#x2F; 重新遍历），则中断通知剩下的观察者</span><br><span class="line">                    if (mDispatchInvalidated) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (mDispatchInvalidated);</span><br><span class="line">        mDispatchingValue &#x3D; false;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    private void considerNotify(ObserverWrapper observer) &#123;</span><br><span class="line">        if (!observer.mActive) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 确保是被观察者处于激活状态，否则不进行分发</span><br><span class="line">        if (!observer.shouldBeActive()) &#123;</span><br><span class="line">            observer.activeStateChanged(false);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 值版本状态检查，如果最近观察者中的版本状态比</span><br><span class="line">        &#x2F;&#x2F; 当前通知的版本状态高，则该更新是非法的，值可</span><br><span class="line">        &#x2F;&#x2F; 能已经过期，不进行通知</span><br><span class="line">        if (observer.mLastVersion &gt;&#x3D; mVersion) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新观察者的值版本信息</span><br><span class="line">        observer.mLastVersion &#x3D; mVersion;</span><br><span class="line">        &#x2F;&#x2F; 执行观察者回调 onChanged</span><br><span class="line">        observer.mObserver.onChanged((T) mData);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lifecycle 定义了几种状态，它们的关系为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESTROYED &lt; INITIALIZED &lt; CREATED &lt; STARTED &lt; RESUMED</span><br></pre></td></tr></table></figure>

<p>以 STARTED 为状态分界点，从 STARTED 之前的状态切换到 STARTED及其之后 或者 STARTED 切换到之前的状态时，会触发 <code>activeStateChanged</code> 响应。因此<code>activeStateChanged</code> 仅对是否允许值变化观察负责，相当于是对是否能够触发值变化回调的开关。</p>
<h2 id="setValue-值更新与通知"><a href="#setValue-值更新与通知" class="headerlink" title="setValue 值更新与通知"></a>setValue 值更新与通知</h2><p>那么当处于激活状态下，LiveData的发生变化是怎么进行通知？<br>我们从<code>LiveData.setValue</code> 入手。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">protected void setValue(T value) &#123;</span><br><span class="line">    assertMainThread(&quot;setValue&quot;);</span><br><span class="line">    &#x2F;&#x2F; 每次值发生变化，mVersion 都进行递增</span><br><span class="line">    mVersion++;</span><br><span class="line">    mData &#x3D; value;</span><br><span class="line">    &#x2F;&#x2F; 对所有订阅者进行通知</span><br><span class="line">    dispatchingValue(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>续上上面的对<code>dispatchingValue</code>的解析就不难理解分发过程。</p>
<h2 id="postValue-值更新与通知"><a href="#postValue-值更新与通知" class="headerlink" title="postValue 值更新与通知"></a>postValue 值更新与通知</h2><p>除了<code>setValue</code>之外，LiveData 还提供了异步更新值的方法<code>postValue</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">protected void postValue(T value) &#123;</span><br><span class="line">    boolean postTask;</span><br><span class="line">    synchronized (mDataLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果 mPendingData 还未被主线程消费，则 postTask 为 fase，</span><br><span class="line">        &#x2F;&#x2F; 不允许重复启动值刷新任务</span><br><span class="line">        postTask &#x3D; mPendingData &#x3D;&#x3D; NOT_SET;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 值会在 mPostValueRunnable 任务中被消费</span><br><span class="line">        mPendingData &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; mPendingData &#x3D;&#x3D; NOT_SET 才允许被触发</span><br><span class="line">    if (!postTask) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 向主线程更新</span><br><span class="line">    ArchTaskExecutor.getInstance().postToMainThread(mPostValueRunnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private final Runnable mPostValueRunnable &#x3D; new Runnable() &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        Object newValue;</span><br><span class="line">        synchronized (mDataLock) &#123;</span><br><span class="line">            newValue &#x3D; mPendingData;</span><br><span class="line">            &#x2F;&#x2F; 标记mPendingData已经被消费</span><br><span class="line">            mPendingData &#x3D; NOT_SET;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新值</span><br><span class="line">        setValue((T) newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="observeForever"><a href="#observeForever" class="headerlink" title="observeForever"></a>observeForever</h2><p>通常情况下我们使用的值确实是跟随 Activity 、Fragment 生命周期进行更新的。但是在一些特殊情况下，我们需要提前与 <code>STARTED</code> 周期前进行值更新通知，但是受制于<code>LifecycleBoundObserver</code>中对于<code>shouldBeActive</code>的控制，仅允许在<code>STARTED</code>和<code>RESUMED</code>周期中才被允许进行值更新通知。</p>
<p>考虑到这种情况，LiveData提供了另外的注册方法<code>observerForever</code>，抛弃对生命周期的依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@MainThread</span><br><span class="line">public void observeForever(@NonNull Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">    &#x2F;&#x2F; 还是需要在主线程中调用</span><br><span class="line">    assertMainThread(&quot;observeForever&quot;);</span><br><span class="line">    AlwaysActiveObserver wrapper &#x3D; new AlwaysActiveObserver(observer);</span><br><span class="line">    ObserverWrapper existing &#x3D; mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    if (existing instanceof LiveData.LifecycleBoundObserver) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Cannot add the same observer&quot;</span><br><span class="line">                + &quot; with different lifecycles&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (existing !&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    wrapper.activeStateChanged(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在之前的<code>observer</code>中，我们可以知道对于生命周期的控制是由于在<code>observer</code>中创建 的<code>LifecycleBoundObserver</code>。</p>
<p>在以上代码中，<code>observeForever</code>通过另外的<code>AlwaysActiveObserver</code>进行包装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private class AlwaysActiveObserver extends ObserverWrapper &#123;</span><br><span class="line"></span><br><span class="line">    AlwaysActiveObserver(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">        super(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    boolean shouldBeActive() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认将 <code>shouldBeActive</code> 都是返回 true，并且不再实现<code>LifecycleEventObserver</code>接口。这样就实现了不受制激活状态约束。</p>
<p>尽管实现了目的，但是这种注册方式无法自动注销订阅关系，如果不进行主动解绑<code>removeObserver</code> 则将发生内存泄露。如果必要这么做，需要在希望生命周期结束时自己调用一些移除观察者动作，这可以借助于自己实现 <code>LifecycleEventObserver</code> 接口。</p>
<h1 id="解除订阅关系"><a href="#解除订阅关系" class="headerlink" title="解除订阅关系"></a>解除订阅关系</h1><p>在之前的源码解析中，<code>LifecycleBoundObserver</code> 实现了对生命周期的监听。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LifecycleBoundObserver extends ObserverWrapper implements LifecycleEventObserver &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">            @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">        if (mOwner.getLifecycle().getCurrentState() &#x3D;&#x3D; DESTROYED) &#123;</span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对生命周期的回调中 <code>onStateChanged</code> 在发生 DESTROYED 时，主动进行了注销 <code>removeObserver(mObserver)</code></p>
<h1 id="四、MediatorLiveData"><a href="#四、MediatorLiveData" class="headerlink" title="四、MediatorLiveData"></a>四、MediatorLiveData</h1><p>MedaitorLiveData 可以将多个被观察源 <code>LiveData</code>进行聚合，当注册的 LiveData 发生变化则通知所注册是对应的 <code>Observer</code>，MediatorLiveData 可以同时注册多个不同类型的被观察者和观察者。</p>
<blockquote>
<p>注意如果一个被观察者LiveData需要绑定多个观察者Observer，则需要调用多次 addSource</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class MediatorLiveData&lt;T&gt; extends MutableLiveData&lt;T&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 对于每一个被观察源都有一个对应的 Source 进行该观察源的状态变化跟踪</span><br><span class="line">    private SafeIterableMap&lt;LiveData&lt;?&gt;, Source&lt;?&gt;&gt; mSources &#x3D; new SafeIterableMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public &lt;S&gt; void addSource(@NonNull LiveData&lt;S&gt; source, @NonNull Observer&lt;? super S&gt; onChanged) &#123;</span><br><span class="line">        &#x2F;&#x2F; 产生跟随观察者</span><br><span class="line">        Source&lt;S&gt; e &#x3D; new Source&lt;&gt;(source, onChanged);</span><br><span class="line">        Source&lt;?&gt; existing &#x3D; mSources.putIfAbsent(source, e);</span><br><span class="line">        if (existing !&#x3D; null &amp;&amp; existing.mObserver !&#x3D; onChanged) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;This source was already added with the different observer&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (existing !&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (hasActiveObservers()) &#123;</span><br><span class="line">            e.plug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private static class Source&lt;V&gt; implements Observer&lt;V&gt; &#123;</span><br><span class="line">        final LiveData&lt;V&gt; mLiveData;</span><br><span class="line">        final Observer&lt;? super V&gt; mObserver;</span><br><span class="line">        int mVersion &#x3D; START_VERSION;</span><br><span class="line"></span><br><span class="line">        Source(LiveData&lt;V&gt; liveData, final Observer&lt;? super V&gt; observer) &#123;</span><br><span class="line">            mLiveData &#x3D; liveData;</span><br><span class="line">            mObserver &#x3D; observer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void plug() &#123;</span><br><span class="line">            mLiveData.observeForever(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        void unplug() &#123;</span><br><span class="line">            mLiveData.removeObserver(this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onChanged(@Nullable V v) &#123;</span><br><span class="line">            &#x2F;&#x2F; 很明显的看出  Souce 即是对 添加进这里的被观察源的观察者代理</span><br><span class="line">            if (mVersion !&#x3D; mLiveData.getVersion()) &#123;</span><br><span class="line">                mVersion &#x3D; mLiveData.getVersion();</span><br><span class="line">                mObserver.onChanged(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于以上的特性，LiveData 提供了一个便捷工具，可以对观察进行便捷转化。</p>
<h2 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h2><p>在该工具类中，有两个方法 <code>map</code> 和 <code>switchMap</code></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;X, Y&gt; LiveData&lt;Y&gt; map(</span><br><span class="line">          @NonNull LiveData&lt;X&gt; source,</span><br><span class="line">          @NonNull final Function&lt;X, Y&gt; mapFunction) &#123;</span><br><span class="line">      final MediatorLiveData&lt;Y&gt; result &#x3D; new MediatorLiveData&lt;&gt;();</span><br><span class="line">      result.addSource(source, new Observer&lt;X&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void onChanged(@Nullable X x) &#123;</span><br><span class="line">              result.setValue(mapFunction.apply(x));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>map 实现了在<code>source</code>发生X类型值变化时，通过<code>mapFunction</code>将被观察的 X 值转化为 Y 值，并将 Y 值通知给观察者<code>Observer</code>的能力 ，和Rx的map 一样。</p>
<h3 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h3><p>switchMap 比较有用，当<code>source</code> 发生 X 值变化时，将触发 X 值的转化，并同时返回新的被观察者源<code>LiveData&lt;Y&gt;</code>，之前的<code>source</code>将失效不在接收变化通知， 当 <code>LiveData&lt;Y&gt;</code> 再次发生值变化将激活最终的观察者们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;X, Y&gt; LiveData&lt;Y&gt; switchMap(</span><br><span class="line">            @NonNull LiveData&lt;X&gt; source,</span><br><span class="line">            @NonNull final Function&lt;X, LiveData&lt;Y&gt;&gt; switchMapFunction) &#123;</span><br><span class="line">        final MediatorLiveData&lt;Y&gt; result &#x3D; new MediatorLiveData&lt;&gt;();</span><br><span class="line">        result.addSource(source, new Observer&lt;X&gt;() &#123;</span><br><span class="line">            LiveData&lt;Y&gt; mSource;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onChanged(@Nullable X x) &#123;</span><br><span class="line">                LiveData&lt;Y&gt; newLiveData &#x3D; switchMapFunction.apply(x);</span><br><span class="line">                if (mSource &#x3D;&#x3D; newLiveData) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (mSource !&#x3D; null) &#123;</span><br><span class="line">                    result.removeSource(mSource);</span><br><span class="line">                &#125;</span><br><span class="line">                mSource &#x3D; newLiveData;</span><br><span class="line">                if (mSource !&#x3D; null) &#123;</span><br><span class="line">                    result.addSource(mSource, new Observer&lt;Y&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onChanged(@Nullable Y y) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 通知之前预注册到MediatorLiveData 的观察者们，数据发生变更</span><br><span class="line">                            result.setValue(y);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>这常用于需要满足某种条件的情况下（即激活<code>source``onChanged</code>）,才进行后续对于 Y 变化的工作，可以提前对Y的工作进行预先设置，等到X变化触发条件才执行。</p>
<p>比如 当用户登录的时，触发用户钱包相关信息的上报，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 用户信息</span><br><span class="line">private fun userInfo &#x3D; MutableLiveData&lt;UserInfo&gt;()</span><br><span class="line"></span><br><span class="line">private fun purseInfo &#x3D; </span><br><span class="line">    Transformations.switchMap(userInfo)&#123;userInfo -&gt;</span><br><span class="line">            val purseInfo &#x3D; MutableLiveData&lt;PurseInfo&gt;() </span><br><span class="line">            &#x2F;&#x2F; 执行用户名到钱包数据的转化</span><br><span class="line">            </span><br><span class="line">            purseInfo &#x3D; realPurseInfo</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F; 返回被观察者源</span><br><span class="line">            return@switchMap purseInfo</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    purseInfoResult.observe(this, Observer &#123;</span><br><span class="line">        &#x2F;&#x2F; 处理相关钱包数据上报内容之类的</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 通过网络耗时请求获得用户信息</span><br><span class="line">    fetchUserInfo() &#123; userInfo -&gt;</span><br><span class="line">        userInfo.value &#x3D; userInfo</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun fetchUserInfo(cb: Callback) &#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，我们提前对 钱包数据进行观察，在获得钱包数据前，需要对用户数据进行请求（耗时），当拉取成功后通知 userInfo 发生数据变化，该变化通知 switchMap 的 switchMapFunction 进行钱包数据的转化，并返回一个代理包装的 LiveData，之后激活之前预先注册观察钱包数据的观察者。</p>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Jetpack/">Jetpack</a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/02/21/Jetpack-ViewModel/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Jetpack-ViewModel</div></div></a></div><div class="next-post pull_right"><a href="/2019/02/14/Jetpack-Lifecycle/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Jetpack-Lifecycle</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/02/14/Jetpack-Lifecycle/" title="Jetpack-Lifecycle"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-02-14</div><div class="relatedPosts_title">Jetpack-Lifecycle</div></div></a></div><div class="relatedPosts_item"><a href="/2019/02/21/Jetpack-ViewModel/" title="Jetpack-ViewModel"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-02-21</div><div class="relatedPosts_title">Jetpack-ViewModel</div></div></a></div><div class="relatedPosts_item"><a href="/2019/01/13/Android源码编译和阅读/" title="Android源码编译和阅读"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-01-13</div><div class="relatedPosts_title">Android源码编译和阅读</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/15/Android未捕获异常处理/" title="Android 未捕获异常处理"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-15</div><div class="relatedPosts_title">Android 未捕获异常处理</div></div></a></div><div class="relatedPosts_item"><a href="/2018/03/03/Repo操作/" title="Repo操作"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-03-03</div><div class="relatedPosts_title">Repo操作</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/10/Handler学习小记/" title="Handler学习小记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-10</div><div class="relatedPosts_title">Handler学习小记</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2014 - 2020 By Bevis</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>