<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Glide-缓存机制 | Bevis技术小站</title><meta name="description" content="Glide-缓存机制"><meta name="keywords" content="Android,Glide"><meta name="author" content="Bevis"><meta name="copyright" content="Bevis"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Glide-缓存机制"><meta name="twitter:description" content="Glide-缓存机制"><meta name="twitter:image" content="http://yoursite.com/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Glide-缓存机制"><meta property="og:url" content="http://yoursite.com/2019/06/24/Glide-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="Bevis技术小站"><meta property="og:description" content="Glide-缓存机制"><meta property="og:image" content="http://yoursite.com/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2019/06/24/Glide-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"><link rel="prev" title="RxJava-操作符自定义理解" href="http://yoursite.com/2019/07/01/RxJava-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%90%86%E8%A7%A3/"><link rel="next" title="Glide-生命周期监控" href="http://yoursite.com/2019/06/20/Glide-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%91%E6%8E%A7/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Bevis技术小站" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Engin-load-加载入口"><span class="toc-number">1.</span> <span class="toc-text">Engin.load 加载入口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存资源获取"><span class="toc-number">1.1.</span> <span class="toc-text">缓存资源获取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ActiveResources"><span class="toc-number">1.1.1.</span> <span class="toc-text">ActiveResources</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ActiveResources-基础"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">ActiveResources 基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActiveResources-get-Key"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">ActiveResources.get(Key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ActiveResource-的资源释放"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">ActiveResource 的资源释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MemoryCache-缓存获取"><span class="toc-number">1.1.2.</span> <span class="toc-text">MemoryCache 缓存获取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LruResourceCache-实现-MemoryCache"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">LruResourceCache 实现 MemoryCache</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#根据屏幕像素对LruResourceCache初始容量设定"><span class="toc-number">1.1.2.0.2.</span> <span class="toc-text">根据屏幕像素对LruResourceCache初始容量设定</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#资源创建"><span class="toc-number">2.</span> <span class="toc-text">资源创建</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Bevis技术小站</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Glide-缓存机制</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date" title="发表于 2019-06-24 20:47:07"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-06-24</time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>Glide 对资源加载分为三级：</p>
<ul>
<li>通过 ActiveResource 工作缓存中进行尝试加载，如果查询到则返回该资源，否则继续</li>
<li>如果 ActiveResource 找不到，则通过 MemoryCache 进行查找加载，如果查询到则返回，并将该资源从 MemoryCache 中移除，转移到 ActiveResource 中</li>
<li>如果两者都找不到，则启动资源加载和解码任务。</li>
<li></li>
</ul>
<p>流程参照：</p>
<p><img src="/" class="lazyload" data-src="http://note.youdao.com/yws/res/30366/WEBRESOURCE2907d71943afcf90232443660029f7fe"  alt="image"></p>
<h1 id="Engin-load-加载入口"><a href="#Engin-load-加载入口" class="headerlink" title="Engin.load 加载入口"></a>Engin.load 加载入口</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public &lt;R&gt; LoadStatus load(</span><br><span class="line">    GlideContext glideContext,</span><br><span class="line">    Object model,</span><br><span class="line">    Key signature,</span><br><span class="line">    int width,</span><br><span class="line">    int height,</span><br><span class="line">    Class&lt;?&gt; resourceClass,</span><br><span class="line">    Class&lt;R&gt; transcodeClass,</span><br><span class="line">    Priority priority,</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">    boolean isTransformationRequired,</span><br><span class="line">    boolean isScaleOnlyOrNoTransform,</span><br><span class="line">    Options options,</span><br><span class="line">    boolean isMemoryCacheable,</span><br><span class="line">    boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">    boolean useAnimationPool,</span><br><span class="line">    boolean onlyRetrieveFromCache,</span><br><span class="line">    ResourceCallback cb,</span><br><span class="line">    Executor callbackExecutor) &#123;</span><br><span class="line">  long startTime &#x3D; VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 根据资源的属性进行 Key 的构造，必须保持资源Key的唯一性</span><br><span class="line">  EngineKey key &#x3D;</span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">  synchronized (this) &#123;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 从内存缓存中获取资源    </span><br><span class="line">    memoryResource &#x3D; loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有获得</span><br><span class="line">    if (memoryResource &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return waitForExistingOrStartNewJob(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          options,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          cb,</span><br><span class="line">          callbackExecutor,</span><br><span class="line">          key,</span><br><span class="line">          startTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Avoid calling back while holding the engine lock, doing so makes it easier for callers to</span><br><span class="line">  &#x2F;&#x2F; deadlock.</span><br><span class="line">  cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="缓存资源获取"><a href="#缓存资源获取" class="headerlink" title="缓存资源获取"></a>缓存资源获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private EngineResource&lt;?&gt; loadFromMemory(</span><br><span class="line">    EngineKey key, boolean isMemoryCacheable, long startTime) &#123;</span><br><span class="line">   </span><br><span class="line">  &#x2F;&#x2F; 如果设置 skipMemoryCache 则忽略从缓存进行加载  </span><br><span class="line">  if (!isMemoryCacheable) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 从工作缓存 ActiveResources 进行尝试加载</span><br><span class="line">  EngineResource&lt;?&gt; active &#x3D; loadFromActiveResources(key);</span><br><span class="line">  if (active !&#x3D; null) &#123;</span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Loaded resource from active resources&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return active;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 从资源缓存中获取资源</span><br><span class="line">  EngineResource&lt;?&gt; cached &#x3D; loadFromCache(key);</span><br><span class="line">  if (cached !&#x3D; null) &#123;</span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Loaded resource from cache&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return cached;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ActiveResources"><a href="#ActiveResources" class="headerlink" title="ActiveResources"></a>ActiveResources</h3><p><code>ActiveResource</code> 是内存缓存的获取的第一次层缓存，通过<code>ActiveResource.get</code>进行资源获取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private EngineResource&lt;?&gt; loadFromActiveResources(Key key) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取资源</span><br><span class="line">  EngineResource&lt;?&gt; active &#x3D; activeResources.get(key);</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 如果能得到资源，则对资源进行引用计数</span><br><span class="line">  if (active !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 引用计数增加，如果 EngineResource.acquired 不为 0 ，则表示资源未被释放引用，无法执行 </span><br><span class="line">    &#x2F;&#x2F; EngineResource.recycle、EngineResource.release 资源释放动作</span><br><span class="line">    active.acquire();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在解析前，对 <code>ActiveResource</code> 先进行初步了解</p>
<h4 id="ActiveResources-基础"><a href="#ActiveResources-基础" class="headerlink" title="ActiveResources 基础"></a>ActiveResources 基础</h4><p><code>ActiveResources</code> 内部提供 <code>HashMap</code> 对所引用的资源进行存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final Map&lt;Key, ResourceWeakReference&gt; activeEngineResources &#x3D; new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><code>ActiveResources</code> 通过 <code>activate(Key key, EngineResource&lt;?&gt; resource)</code>对资源进行加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">synchronized void activate(Key key, EngineResource&lt;?&gt; resource) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ResourceWeakReference 继承自 WeakReference ，通过弱引用包装，并构造时</span><br><span class="line">  &#x2F;&#x2F; 设置 ReferenceQueue resouceReferenceQueue，产生资源引用</span><br><span class="line">  ResourceWeakReference toPut &#x3D;</span><br><span class="line">      new ResourceWeakReference(</span><br><span class="line">          key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 添加到工作缓存 Map 中，如果之前已经存在，则回收之前旧资源引用</span><br><span class="line">  ResourceWeakReference removed &#x3D; activeEngineResources.put(key, toPut);</span><br><span class="line">  if (removed !&#x3D; null) &#123;</span><br><span class="line">    removed.reset();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static final class ResourceWeakReference extends WeakReference&lt;EngineResource&lt;?&gt;&gt; &#123;</span><br><span class="line">  final Key key;</span><br><span class="line">  final boolean isCacheable;</span><br><span class="line">  Resource&lt;?&gt; resource;</span><br><span class="line">  </span><br><span class="line">  ResourceWeakReference(Key key, EngineResource&lt;?&gt; referent, </span><br><span class="line">      ReferenceQueue&lt;? super EngineResource&lt;?&gt;&gt; queue, boolean isActiveResourceRetentionAllowed) &#123;</span><br><span class="line">    super(referent, queue);</span><br><span class="line">    this.key &#x3D; Preconditions.checkNotNull(key);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; isActiveResourceRetentionAllowed 通过 GlideBuilder.setIsActiveResourceRetentionAllowed </span><br><span class="line">    &#x2F;&#x2F; 进行设置，默认为 false</span><br><span class="line">    this.resource &#x3D;</span><br><span class="line">        referent.isMemoryCacheable() &amp;&amp; isActiveResourceRetentionAllowed</span><br><span class="line">            ? Preconditions.checkNotNull(referent.getResource())</span><br><span class="line">            : null;</span><br><span class="line">    isCacheable &#x3D; referent.isMemoryCacheable();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void reset() &#123;</span><br><span class="line">    resource &#x3D; null;</span><br><span class="line">    clear();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ActiveResource</code> 通过对资源弱引用包装（ResourceWeakReference） 和 ReferenceQueue 回收监控达到对工作缓存进行内存控制，以防止造成内存泄露，另一方面对于工作中的资源引用达到快速索引的要求。</p>
<h4 id="ActiveResources-get-Key"><a href="#ActiveResources-get-Key" class="headerlink" title="ActiveResources.get(Key)"></a>ActiveResources.get(Key)</h4><p>回到内存缓存获取的入口，对工作缓存进行查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> synchronized EngineResource&lt;?&gt; get(Key key) &#123;</span><br><span class="line">   ResourceWeakReference activeRef &#x3D; activeEngineResources.get(key);</span><br><span class="line">   if (activeRef &#x3D;&#x3D; null) &#123;</span><br><span class="line">     return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   EngineResource&lt;?&gt; active &#x3D; activeRef.get();</span><br><span class="line">   if (active &#x3D;&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; 资源清理    </span><br><span class="line">     cleanupActiveReference(activeRef);</span><br><span class="line">   &#125;</span><br><span class="line">   return active;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">void cleanupActiveReference(@NonNull ResourceWeakReference ref) &#123;</span><br><span class="line">   synchronized (this) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从缓存Map中移除</span><br><span class="line">     activeEngineResources.remove(ref.key);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果资源已经主动被释放则退出 </span><br><span class="line">     if (!ref.isCacheable || ref.resource &#x3D;&#x3D; null) &#123;</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 回调</span><br><span class="line">   EngineResource&lt;?&gt; newResource &#x3D;</span><br><span class="line">       new EngineResource&lt;&gt;(</span><br><span class="line">           ref.resource, &#x2F;*isMemoryCacheable&#x3D;*&#x2F; true, &#x2F;*isRecyclable&#x3D;*&#x2F; false, ref.key, listener);</span><br><span class="line">   listener.onResourceReleased(ref.key, newResource);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中，主要还是对 <code>HashMap</code> 的缓存中获取对应的资源弱引用，如果不再缓存中则返回null，当 资源弱引用<code>ResourceWeakReference</code>中资源已经被释放，则对<code>ResourceWeakReference</code>进行回收处理，将缓存从缓存Map中移除。</p>
<h4 id="ActiveResource-的资源释放"><a href="#ActiveResource-的资源释放" class="headerlink" title="ActiveResource 的资源释放"></a>ActiveResource 的资源释放</h4><p>虽然<code>ActiveResource</code> 使用 <code>ReferenceQueue</code> 进行资源回收监控，不过仅在创建时进行回收。</p>
<p>另外比较常用的回收资源手段是通过 <code>ActiveResource.deactivate</code> 的调用。</p>
<p>该方法仅在 <code>EngineResource.ResourceListener.onResourceReleased</code> 发生的回调中执行资源回收。</p>
<p><code>EngineResource.ResourceListener.onResourceReleased</code>接口被<code>Engine</code>所实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Engine</span><br><span class="line">    implements EngineJobListener,</span><br><span class="line">        MemoryCache.ResourceRemovedListener,</span><br><span class="line">        EngineResource.ResourceListener &#123;</span><br><span class="line">    ...    </span><br><span class="line">   public void onResourceReleased(Key cacheKey, EngineResource&lt;?&gt; resource) &#123;</span><br><span class="line">    activeResources.deactivate(cacheKey);</span><br><span class="line">    if (resource.isMemoryCacheable()) &#123;</span><br><span class="line">      cache.put(cacheKey, resource);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      resourceRecycler.recycle(resource, &#x2F;*forceNextFrame&#x3D;*&#x2F; false);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onResourceReleased</code> 被两个地方所调用。</p>
<ul>
<li>ActiveResources.cleanupActiveReference(ResourceWeakReference)</li>
<li>EngineResource.release()</li>
</ul>
<p>这里主要关注于 <code>EngineResource.release</code>，在之前 ActiveResource 的处理中，我们知道<code>EngineResource</code> 是资源的代理对象。</p>
<p>当追踪到代码的根源，我们会发现<code>EngineResource.release</code> 被 <code>SingleRequest.clear</code>所调用，而<code>SingleRequest.clear</code>最终被多个地方所调用，其中不免有 <code>RequestManager</code>。</p>
<p>Glide 对资源生命周期的管理中，<code>RequestMananger</code>会对<code>Fragment</code>、<code>Activity</code>等生命周期进行回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class RequestManager</span><br><span class="line">    implements ComponentCallbacks2, LifecycleListener, ModelTypes&lt;RequestBuilder&lt;Drawable&gt;&gt; &#123;</span><br><span class="line">  ...    </span><br><span class="line">  public void clear(@Nullable final Target&lt;?&gt; target) &#123;</span><br><span class="line">    if (target &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    untrackOrDelegate(target);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  private void untrackOrDelegate(@NonNull Target&lt;?&gt; target) &#123;</span><br><span class="line">    boolean isOwnedByUs &#x3D; untrack(target);</span><br><span class="line">    Request request &#x3D; target.getRequest();</span><br><span class="line">    if (!isOwnedByUs &amp;&amp; !glide.removeFromManagers(target) &amp;&amp; request !&#x3D; null) &#123;</span><br><span class="line">      target.setRequest(null);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 对 Request 进行clear处理</span><br><span class="line">      request.clear();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  public synchronized void onDestroy() &#123;</span><br><span class="line">    targetTracker.onDestroy();</span><br><span class="line">    &#x2F;&#x2F; 释放该周期对象中所有 Request 的资源</span><br><span class="line">    for (Target&lt;?&gt; target : targetTracker.getAll()) &#123;</span><br><span class="line">      clear(target);</span><br><span class="line">    &#125;</span><br><span class="line">    targetTracker.clear();</span><br><span class="line">    requestTracker.clearRequests();</span><br><span class="line">    lifecycle.removeListener(this);</span><br><span class="line">    lifecycle.removeListener(connectivityMonitor);</span><br><span class="line">    mainHandler.removeCallbacks(addSelfToLifecycle);</span><br><span class="line">    glide.unregisterRequestManager(this);</span><br><span class="line">  &#125;  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我们明显可以知道当发生<code>onDestroy</code>发生时，则会也会触发资源的销毁动作</p>
<h3 id="MemoryCache-缓存获取"><a href="#MemoryCache-缓存获取" class="headerlink" title="MemoryCache 缓存获取"></a>MemoryCache 缓存获取</h3><p>如果 <code>ActiveResource</code> 获取不到所需要的资源，则尝试从 <code>loadFromCache</code> 进行加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private final MemoryCache cache;</span><br><span class="line"></span><br><span class="line">private EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">  &#x2F;&#x2F; 从 MemoryCache 内存缓存中获取资源，如果能得到，从内存缓存中剔除，并转移到工作缓存中</span><br><span class="line">  EngineResource&lt;?&gt; cached &#x3D; getEngineResourceFromCache(key);</span><br><span class="line">  if (cached !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 进行资源使用计数    </span><br><span class="line">    cached.acquire();</span><br><span class="line">    activeResources.activate(key, cached);</span><br><span class="line">  &#125;</span><br><span class="line">  return cached;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">private EngineResource&lt;?&gt; getEngineResourceFromCache(Key key) &#123;</span><br><span class="line"> </span><br><span class="line">  Resource&lt;?&gt; cached &#x3D; cache.remove(key);</span><br><span class="line"></span><br><span class="line">  final EngineResource&lt;?&gt; result;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 如果能获取到资源对象 ，则确保通过 EngineResource 进行包装</span><br><span class="line">  if (cached &#x3D;&#x3D; null) &#123;</span><br><span class="line">    result &#x3D; null;</span><br><span class="line">  &#125; else if (cached instanceof EngineResource) &#123;</span><br><span class="line">    &#x2F;&#x2F; Save an object allocation if we&#39;ve cached an EngineResource (the typical case).</span><br><span class="line">    result &#x3D; (EngineResource&lt;?&gt;) cached;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result &#x3D;</span><br><span class="line">        new EngineResource&lt;&gt;(</span><br><span class="line">            cached, &#x2F;*isMemoryCacheable&#x3D;*&#x2F; true, &#x2F;*isRecyclable&#x3D;*&#x2F; true, key, &#x2F;*listener&#x3D;*&#x2F; this);</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在二次的内存获取中，是从 <code>MemoryCache</code>进行获取，以下还是先对 <code>MemoryCache</code> 初步了解</p>
<h5 id="LruResourceCache-实现-MemoryCache"><a href="#LruResourceCache-实现-MemoryCache" class="headerlink" title="LruResourceCache 实现 MemoryCache"></a>LruResourceCache 实现 MemoryCache</h5><p><code>MemoryCache</code> 是一个缓存接口，该缓存可以通过<code>GlideBuilder.setMemoryCache</code> 进行创建，默认情况下所构造的实现类是<code>LruResourceCache</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final class GlideBuilder &#123;</span><br><span class="line">  ...    </span><br><span class="line">  Glide build(@NonNull Context context) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (memorySizeCalculator &#x3D;&#x3D; null) &#123;</span><br><span class="line">      memorySizeCalculator &#x3D; new MemorySizeCalculator.Builder(context).build();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (memoryCache &#x3D;&#x3D; null) &#123;</span><br><span class="line">      memoryCache &#x3D; new LruResourceCache(memorySizeCalculator.getMemoryCacheSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (diskCacheFactory &#x3D;&#x3D; null) &#123;</span><br><span class="line">      diskCacheFactory &#x3D; new InternalCacheDiskCacheFactory(context);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return new Glide(</span><br><span class="line">        context,</span><br><span class="line">        engine,</span><br><span class="line">        memoryCache,</span><br><span class="line">        bitmapPool,</span><br><span class="line">        arrayPool,</span><br><span class="line">        requestManagerRetriever,</span><br><span class="line">        connectivityMonitorFactory,</span><br><span class="line">        logLevel,</span><br><span class="line">        defaultRequestOptionsFactory,</span><br><span class="line">        defaultTransitionOptions,</span><br><span class="line">        defaultRequestListeners,</span><br><span class="line">        isLoggingRequestOriginsEnabled,</span><br><span class="line">        isImageDecoderEnabledForBitmaps);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p><code>LruResourceCache</code> 默认继承自 <code>LruCache</code>实现了Lru的能力，而<code>MemoryCache</code>接口方法 默被<code>LruCache</code>所实现。<br>因此可以说 <code>LruResouceCache</code> 即为一个资源的 Lru 缓存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class LruResourceCache extends LruCache&lt;Key, Resource&lt;?&gt;&gt; implements MemoryCache &#123;</span><br><span class="line">  private ResourceRemovedListener listener;</span><br><span class="line"></span><br><span class="line">  public LruResourceCache(long size) &#123;</span><br><span class="line">    super(size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 默认被 Engine 注册    </span><br><span class="line">  @Override</span><br><span class="line">  public void setResourceRemovedListener(@NonNull ResourceRemovedListener listener) &#123;</span><br><span class="line">    this.listener &#x3D; listener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onItemEvicted(@NonNull Key key, @Nullable Resource&lt;?&gt; item) &#123;</span><br><span class="line">    if (listener !&#x3D; null &amp;&amp; item !&#x3D; null) &#123;</span><br><span class="line">      listener.onResourceRemoved(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 重写 LruCache.getSize 方法，LruCache 的 maxSize 以资源自身自己的实际 size 为计算标准    </span><br><span class="line">  @Override</span><br><span class="line">  protected int getSize(@Nullable Resource&lt;?&gt; item) &#123;</span><br><span class="line">    if (item &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return super.getSize(null);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return item.getSize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @SuppressLint(&quot;InlinedApi&quot;)</span><br><span class="line">  @Override</span><br><span class="line">  public void trimMemory(int level) &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据系统回调的缓存回收等级，进行该缓存对应的缓存释放或者缩容</span><br><span class="line">    if (level &gt;&#x3D; android.content.ComponentCallbacks2.TRIM_MEMORY_BACKGROUND) &#123;</span><br><span class="line">      &#x2F;&#x2F; 清空该缓存所有资源    </span><br><span class="line">      clearMemory();</span><br><span class="line">    &#125; else if (level &gt;&#x3D; android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN</span><br><span class="line">        || level &#x3D;&#x3D; android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL) &#123;</span><br><span class="line">      &#x2F;&#x2F; 缩容为最大容量的一半        </span><br><span class="line">      trimToSize(getMaxSize() &#x2F; 2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="根据屏幕像素对LruResourceCache初始容量设定"><a href="#根据屏幕像素对LruResourceCache初始容量设定" class="headerlink" title="根据屏幕像素对LruResourceCache初始容量设定"></a>根据屏幕像素对LruResourceCache初始容量设定</h5><p><code>LruResourceCache</code> 对应容量的设定是根据 <code>MemorySizeCalculator.getMemoryCacheSize()</code>进行设定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public final class MemorySizeCalculator &#123;</span><br><span class="line"> static final int BYTES_PER_ARGB_8888_PIXEL &#x3D; 4</span><br><span class="line"> ...    </span><br><span class="line"> public static final class Builder &#123;</span><br><span class="line">    &#x2F;&#x2F; 默认为 2 </span><br><span class="line">    @Synthetic float memoryCacheScreens &#x3D; MEMORY_CACHE_TARGET_SCREENS; </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 根据版本  Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O ? 4 : 1</span><br><span class="line">    @Synthetic float bitmapPoolScreens &#x3D; BITMAP_POOL_TARGET_SCREENS; </span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 默认为 0.4f</span><br><span class="line">    @Synthetic float maxSizeMultiplier &#x3D; MAX_SIZE_MULTIPLIER;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 默认为 0.33f</span><br><span class="line">    @Synthetic float lowMemoryMaxSizeMultiplier &#x3D; LOW_MEMORY_MAX_SIZE_MULTIPLIER</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 默认为 4 * 1024 * 1024   4MB</span><br><span class="line">    @Synthetic int arrayPoolSizeBytes &#x3D; ARRAY_POOL_SIZE_BYTES;    </span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">    </span><br><span class="line"> MemorySizeCalculator(MemorySizeCalculator.Builder builder) &#123;</span><br><span class="line">    this.context &#x3D; builder.context;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 低设备为正常设备一半的内存数量，默认为 2MB，正常设备为 4MB，该内存用于设置 LruArrayPool 初始化容量</span><br><span class="line">    arrayPoolSize &#x3D;</span><br><span class="line">        isLowMemoryDevice(builder.activityManager)</span><br><span class="line">            ? builder.arrayPoolSizeBytes &#x2F; LOW_MEMORY_BYTE_ARRAY_POOL_DIVISOR</span><br><span class="line">            : builder.arrayPoolSizeBytes;</span><br><span class="line">            </span><br><span class="line">    int maxSize &#x3D;</span><br><span class="line">        getMaxSize(</span><br><span class="line">            builder.activityManager, builder.maxSizeMultiplier, builder.lowMemoryMaxSizeMultiplier);</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    int widthPixels &#x3D; builder.screenDimensions.getWidthPixels();</span><br><span class="line">    int heightPixels &#x3D; builder.screenDimensions.getHeightPixels();</span><br><span class="line">     &#x2F;&#x2F; 计算一屏幕像素的字节数</span><br><span class="line">    int screenSize &#x3D; widthPixels * heightPixels * BYTES_PER_ARGB_8888_PIXEL;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 图片缓存池，在 Android O 之下提供 4 屏像素字节数内存，否则 1 屏</span><br><span class="line">    int targetBitmapPoolSize &#x3D; Math.round(screenSize * builder.bitmapPoolScreens);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 内存缓存的大小提供 2 屏像素字节大小</span><br><span class="line">    int targetMemoryCacheSize &#x3D; Math.round(screenSize * builder.memoryCacheScreens);</span><br><span class="line">    int availableSize &#x3D; maxSize - arrayPoolSize;</span><br><span class="line"></span><br><span class="line">    if (targetMemoryCacheSize + targetBitmapPoolSize &lt;&#x3D; availableSize) &#123;</span><br><span class="line">      memoryCacheSize &#x3D; targetMemoryCacheSize;</span><br><span class="line">      bitmapPoolSize &#x3D; targetBitmapPoolSize;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      float part &#x3D; availableSize &#x2F; (builder.bitmapPoolScreens + builder.memoryCacheScreens);</span><br><span class="line">      memoryCacheSize &#x3D; Math.round(part * builder.memoryCacheScreens);</span><br><span class="line">      bitmapPoolSize &#x3D; Math.round(part * builder.bitmapPoolScreens);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  public int getMemoryCacheSize() &#123;</span><br><span class="line">    return memoryCacheSize;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  private static int getMaxSize(</span><br><span class="line">      ActivityManager activityManager, </span><br><span class="line">      float maxSizeMultiplier, </span><br><span class="line">      float lowMemoryMaxSizeMultiplier</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#x2F;&#x2F; activityManager.getMemoryClass() 是系统所提供的API，用于返回当前进程所分配的最大物理内存</span><br><span class="line">    &#x2F;&#x2F; 包含 native heap 和 java heap ，返回单位为 M，memoryClassBytes 转化为字节数</span><br><span class="line">    final int memoryClassBytes &#x3D; activityManager.getMemoryClass() * 1024 * 1024;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 是否为低内存设备</span><br><span class="line">    final boolean isLowMemoryDevice &#x3D; isLowMemoryDevice(activityManager);</span><br><span class="line">    </span><br><span class="line">    return Math.round(memoryClassBytes * (isLowMemoryDevice ? lowMemoryMaxSizeMultiplier : maxSizeMultiplier));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 判断是否为低内存设备</span><br><span class="line">  static boolean isLowMemoryDevice(ActivityManager activityManager) &#123;</span><br><span class="line">    if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">      return activityManager.isLowRamDevice();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Glide 使用 <code>MemorySizeCalculator</code> 对内存缓存根据设备情况进行自动计算，</p>
<p>如果默认剩余可用内存大于所需要提供的 2 屏幕像素内存，则直接申请为当前屏幕的两屏幕内存，如果不足，则根据当前剩余可用内存占比，按比例申请 2 屏幕像素内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (targetMemoryCacheSize + targetBitmapPoolSize &lt;&#x3D; availableSize) &#123;</span><br><span class="line">  memoryCacheSize &#x3D; targetMemoryCacheSize;</span><br><span class="line">  bitmapPoolSize &#x3D; targetBitmapPoolSize;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  float part &#x3D; availableSize &#x2F; (builder.bitmapPoolScreens + builder.memoryCacheScreens);</span><br><span class="line">  memoryCacheSize &#x3D; Math.round(part * builder.memoryCacheScreens);</span><br><span class="line">  bitmapPoolSize &#x3D; Math.round(part * builder.bitmapPoolScreens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自此对 <code>LruResourceCache</code> 有些初步了解</p>
<h1 id="资源创建"><a href="#资源创建" class="headerlink" title="资源创建"></a>资源创建</h1><p>回到对 <code>MemoryCache</code> 获取后的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private EngineResource&lt;?&gt; loadFromCache(Key key) &#123;</span><br><span class="line">  EngineResource&lt;?&gt; cached &#x3D; getEngineResourceFromCache(key);</span><br><span class="line">  if (cached !&#x3D; null) &#123;</span><br><span class="line">    cached.acquire();</span><br><span class="line">    activeResources.activate(key, cached);</span><br><span class="line">  &#125;</span><br><span class="line">  return cached;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能从<code>MemoryCache</code>获取到指定的资源，则将该资源从<code>MemoryCache</code> 移除，并且转移到工作缓存中<code>ActiveResources</code>。</p>
<p>如果没有获得，那么就需要对资源进行主动创建了，</p>
<p>代码回到 <code>Engine.load</code>，如果资源未获得成功，则通过<code>waitForExistingOrStartNewJob</code>进行创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> public &lt;R&gt; LoadStatus load(</span><br><span class="line">      GlideContext glideContext,</span><br><span class="line">      Object model,</span><br><span class="line">      Key signature,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      Class&lt;?&gt; resourceClass,</span><br><span class="line">      Class&lt;R&gt; transcodeClass,</span><br><span class="line">      Priority priority,</span><br><span class="line">      DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">      boolean isTransformationRequired,</span><br><span class="line">      boolean isScaleOnlyOrNoTransform,</span><br><span class="line">      Options options,</span><br><span class="line">      boolean isMemoryCacheable,</span><br><span class="line">      boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">      boolean useAnimationPool,</span><br><span class="line">      boolean onlyRetrieveFromCache,</span><br><span class="line">      ResourceCallback cb,</span><br><span class="line">      Executor callbackExecutor) &#123;</span><br><span class="line">      ...</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      if (memoryResource &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 执行任务的创建</span><br><span class="line">        return waitForExistingOrStartNewJob(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            options,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            cb,</span><br><span class="line">            callbackExecutor,</span><br><span class="line">            key,</span><br><span class="line">            startTime);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">private &lt;R&gt; LoadStatus waitForExistingOrStartNewJob(</span><br><span class="line">      GlideContext glideContext,</span><br><span class="line">      Object model,</span><br><span class="line">      Key signature,</span><br><span class="line">      int width,</span><br><span class="line">      int height,</span><br><span class="line">      Class&lt;?&gt; resourceClass,</span><br><span class="line">      Class&lt;R&gt; transcodeClass,</span><br><span class="line">      Priority priority,</span><br><span class="line">      DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">      Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">      boolean isTransformationRequired,</span><br><span class="line">      boolean isScaleOnlyOrNoTransform,</span><br><span class="line">      Options options,</span><br><span class="line">      boolean isMemoryCacheable,</span><br><span class="line">      boolean useUnlimitedSourceExecutorPool,</span><br><span class="line">      boolean useAnimationPool,</span><br><span class="line">      boolean onlyRetrieveFromCache,</span><br><span class="line">      ResourceCallback cb,</span><br><span class="line">      Executor callbackExecutor,</span><br><span class="line">      EngineKey key,</span><br><span class="line">      long startTime) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; jobs 为 Jobs 的实例，目的是作为 EngineJob 的缓存容器</span><br><span class="line">    &#x2F;&#x2F; onlyRetrieveFromCache 为true则表示只加载到内存的任务</span><br><span class="line">    EngineJob&lt;?&gt; current &#x3D; jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">    if (current !&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果已经存在任务，则将当前所请求的回调添加到请求任务中，并指定回调所执行的</span><br><span class="line">      &#x2F;&#x2F; 线程池，cb ResourceCallback 一般由 SingleRequest 所实现</span><br><span class="line">      current.addCallback(cb, callbackExecutor);</span><br><span class="line">      if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">        logWithTimeAndKey(&quot;Added to existing load&quot;, startTime, key);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 返回一个执行转台的代理，允许对任务进行取消 LoadStatus.cancel 操作</span><br><span class="line">      return new LoadStatus(cb, current);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果没有则创建一个 加载任务</span><br><span class="line">    EngineJob&lt;R&gt; engineJob &#x3D;</span><br><span class="line">        engineJobFactory.build(</span><br><span class="line">            key,</span><br><span class="line">            isMemoryCacheable,</span><br><span class="line">            useUnlimitedSourceExecutorPool,</span><br><span class="line">            useAnimationPool,</span><br><span class="line">            onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 创建资源解码任务，包装加载后的操作</span><br><span class="line">    DecodeJob&lt;R&gt; decodeJob &#x3D;</span><br><span class="line">        decodeJobFactory.build(</span><br><span class="line">            glideContext,</span><br><span class="line">            model,</span><br><span class="line">            key,</span><br><span class="line">            signature,</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            resourceClass,</span><br><span class="line">            transcodeClass,</span><br><span class="line">            priority,</span><br><span class="line">            diskCacheStrategy,</span><br><span class="line">            transformations,</span><br><span class="line">            isTransformationRequired,</span><br><span class="line">            isScaleOnlyOrNoTransform,</span><br><span class="line">            onlyRetrieveFromCache,</span><br><span class="line">            options,</span><br><span class="line">            engineJob);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 添加到任务缓存池</span><br><span class="line">    jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">    engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 启动任务</span><br><span class="line">    engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">    if (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(&quot;Started new load&quot;, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    return new LoadStatus(cb, engineJob);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/Glide/">Glide</a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/07/01/RxJava-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%87%AA%E5%AE%9A%E4%B9%89%E7%90%86%E8%A7%A3/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RxJava-操作符自定义理解</div></div></a></div><div class="next-post pull_right"><a href="/2019/06/20/Glide-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9B%91%E6%8E%A7/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Glide-生命周期监控</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/06/20/Glide-生命周期监控/" title="Glide-生命周期监控"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-06-20</div><div class="relatedPosts_title">Glide-生命周期监控</div></div></a></div><div class="relatedPosts_item"><a href="/2019/01/13/Android源码编译和阅读/" title="Android源码编译和阅读"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-01-13</div><div class="relatedPosts_title">Android源码编译和阅读</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/15/Android未捕获异常处理/" title="Android 未捕获异常处理"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-15</div><div class="relatedPosts_title">Android 未捕获异常处理</div></div></a></div><div class="relatedPosts_item"><a href="/2019/02/14/Jetpack-Lifecycle/" title="Jetpack-Lifecycle"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-02-14</div><div class="relatedPosts_title">Jetpack-Lifecycle</div></div></a></div><div class="relatedPosts_item"><a href="/2018/03/03/Repo操作/" title="Repo操作"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2018-03-03</div><div class="relatedPosts_title">Repo操作</div></div></a></div><div class="relatedPosts_item"><a href="/2016/05/10/Handler学习小记/" title="Handler学习小记"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2016-05-10</div><div class="relatedPosts_title">Handler学习小记</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2014 - 2020 By Bevis</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>